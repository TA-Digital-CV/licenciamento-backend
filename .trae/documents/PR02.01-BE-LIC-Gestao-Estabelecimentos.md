# PR02.01-BE-LIC-Gestão de Estabelecimentos

## 1. Visão Geral

Este documento especifica a implementação do módulo de **Gestão de Estabelecimentos** para o Sistema de Licenciamento de Cabo Verde. O módulo é responsável pelo registro, controle e geolocalização de estabelecimentos comerciais, industriais e de serviços, incluindo validação de coordenadas GPS, gestão de documentação específica por segmento e processos de registro.

### 1.1 Objetivos

* Implementar modelo de dados normalizado para estabelecimentos com suporte geoespacial

* Implementar arquitetura DDD para gestão de estabelecimentos e registros

* Fornecer APIs REST para registro, consulta e atualização de estabelecimentos

* Garantir validações robustas de coordenadas GPS e conformidade por segmento

* Suportar upload e gestão de documentação específica

* Implementar busca por proximidade geográfica

## 2. Modelo de Dados Normalizado

### 2.1 Diagrama ER

```mermaid
erDiagram
    T_ESTABLISHMENT {
        uuid id PK
        varchar matricial_number
        varchar name
        varchar trade_name
        varchar establishment_type
        varchar segment
        varchar classification_code
        text description
        decimal latitude
        decimal longitude
        varchar address
        varchar parish
        varchar municipality
        varchar island
        varchar postal_code
        varchar status
        boolean active
        jsonb metadata
        timestamp created_at
        timestamp updated_at
        varchar created_by
        varchar updated_by
    }

    T_ESTABLISHMENT_DOCUMENT {
        uuid id PK
        uuid establishment_id_fk FK
        varchar document_type
        varchar document_name
        varchar document_url
        varchar mime_type
        bigint file_size
        varchar status
        timestamp upload_date
        timestamp expiry_date
        varchar uploaded_by
        timestamp created_at
        timestamp updated_at
    }

    T_ESTABLISHMENT_REGISTRATION {
        uuid id PK
        uuid establishment_id_fk FK
        varchar registration_number
        date registration_date
        varchar registration_type
        varchar status
        text observations
        timestamp created_at
        varchar created_by
        timestamp updated_at
        varchar updated_by
    }

    T_ESTABLISHMENT_CLASSIFICATION {
        uuid id PK
        uuid establishment_id_fk FK
        varchar classification_type
        varchar classification_code
        varchar classification_name
        text description
        boolean active
        timestamp created_at
        varchar created_by
    }

    T_ESTABLISHMENT ||--o{ T_ESTABLISHMENT_DOCUMENT : "has documents"
    T_ESTABLISHMENT ||--o{ T_ESTABLISHMENT_REGISTRATION : "has registration"
    T_ESTABLISHMENT ||--o{ T_ESTABLISHMENT_CLASSIFICATION : "has classification"
```

### 2.2 Definição das Tabelas

#### 2.2.1 Tabela T\_ESTABLISHMENT

```sql
CREATE TABLE t_establishment (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    matricial_number VARCHAR(50) UNIQUE NOT NULL,
    name VARCHAR(255) NOT NULL,
    trade_name VARCHAR(255),
    establishment_type VARCHAR(50) NOT NULL,
    segment VARCHAR(50) NOT NULL,
    classification_code VARCHAR(20),
    description TEXT,
    latitude DECIMAL(10, 8) NOT NULL,
    longitude DECIMAL(11, 8) NOT NULL,
    address TEXT NOT NULL,
    parish VARCHAR(100),
    municipality VARCHAR(100) NOT NULL,
    island VARCHAR(50) NOT NULL,
    postal_code VARCHAR(20),
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    active BOOLEAN NOT NULL DEFAULT true,
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100) NOT NULL,
    updated_by VARCHAR(100) NOT NULL,

    CONSTRAINT chk_establishment_latitude 
        CHECK (latitude >= -90 AND latitude <= 90),
    CONSTRAINT chk_establishment_longitude 
        CHECK (longitude >= -180 AND longitude <= 180),
    CONSTRAINT chk_establishment_cabo_verde_coords
        CHECK (
            latitude BETWEEN 14.8 AND 17.2 AND 
            longitude BETWEEN -25.4 AND -22.7
        ),
    CONSTRAINT chk_establishment_status
        CHECK (status IN ('ACTIVE', 'INACTIVE', 'SUSPENDED', 'PENDING'))
);
```

#### 2.2.2 Tabela T\_ESTABLISHMENT\_DOCUMENT

```sql
CREATE TABLE t_establishment_document (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    establishment_id_fk UUID NOT NULL,
    document_type VARCHAR(50) NOT NULL,
    document_name VARCHAR(255) NOT NULL,
    document_url VARCHAR(500) NOT NULL,
    mime_type VARCHAR(100) NOT NULL,
    file_size BIGINT NOT NULL CHECK (file_size > 0),
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    upload_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    expiry_date TIMESTAMP WITH TIME ZONE,
    uploaded_by VARCHAR(100) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),

    CONSTRAINT fk_establishment_document_establishment
        FOREIGN KEY (establishment_id_fk) REFERENCES t_establishment(id),
    CONSTRAINT chk_document_status
        CHECK (status IN ('ACTIVE', 'EXPIRED', 'REPLACED', 'INVALID')),
    CONSTRAINT chk_expiry_after_upload
        CHECK (expiry_date IS NULL OR expiry_date > upload_date)
);
```

#### 2.2.3 Tabela T\_ESTABLISHMENT\_REGISTRATION

```sql
CREATE TABLE t_establishment_registration (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    establishment_id_fk UUID NOT NULL,
    registration_number VARCHAR(100) UNIQUE NOT NULL,
    registration_date DATE NOT NULL,
    registration_type VARCHAR(50) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    observations TEXT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_by VARCHAR(100) NOT NULL,

    CONSTRAINT fk_establishment_registration_establishment
        FOREIGN KEY (establishment_id_fk) REFERENCES t_establishment(id),
    CONSTRAINT chk_registration_status
        CHECK (status IN ('ACTIVE', 'CANCELLED', 'SUSPENDED', 'EXPIRED'))
);
```

### 2.3 Índices Geoespaciais e de Performance

```sql
-- Índice geoespacial para consultas por proximidade
CREATE INDEX idx_establishment_location 
    ON t_establishment USING GIST (ST_Point(longitude, latitude));

-- Índices de performance
CREATE INDEX idx_establishment_matricial ON t_establishment(matricial_number);
CREATE INDEX idx_establishment_segment ON t_establishment(segment);
CREATE INDEX idx_establishment_municipality ON t_establishment(municipality, island);
CREATE INDEX idx_establishment_status ON t_establishment(status) WHERE status = 'ACTIVE';
CREATE INDEX idx_establishment_type ON t_establishment(establishment_type);

-- Índices para documentos
CREATE INDEX idx_establishment_document_establishment ON t_establishment_document(establishment_id_fk);
CREATE INDEX idx_establishment_document_type ON t_establishment_document(document_type);
CREATE INDEX idx_establishment_document_expiry ON t_establishment_document(expiry_date) 
    WHERE expiry_date IS NOT NULL AND status = 'ACTIVE';

-- Índices para registros
CREATE INDEX idx_establishment_registration_establishment ON t_establishment_registration(establishment_id_fk);
CREATE INDEX idx_establishment_registration_number ON t_establishment_registration(registration_number);
```

## 3. Arquitetura DDD

### 3.1 Domain Layer

#### 3.1.1 Aggregate Root: Establishment

```java
@Entity
@Table(name = "t_establishment")
public class Establishment extends AggregateRoot<EstablishmentId> {
    
    @EmbeddedId
    private EstablishmentId id;
    
    @Column(name = "matricial_number", nullable = false, unique = true)
    private MatricialNumber matricialNumber;
    
    @Column(name = "name", nullable = false)
    private String name;
    
    @Column(name = "trade_name")
    private String tradeName;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "establishment_type", nullable = false)
    private EstablishmentType establishmentType;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "segment", nullable = false)
    private EstablishmentSegment segment;
    
    @Embedded
    private GeoLocation location;
    
    @Embedded
    private Address address;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private EstablishmentStatus status;
    
    @OneToMany(mappedBy = "establishment", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<EstablishmentDocument> documents = new ArrayList<>();
    
    @OneToMany(mappedBy = "establishment", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<EstablishmentRegistration> registrations = new ArrayList<>();
    
    // Métodos de negócio
    public static Establishment create(
            MatricialNumber matricialNumber,
            String name,
            String tradeName,
            EstablishmentType type,
            EstablishmentSegment segment,
            GeoLocation location,
            Address address,
            String createdBy,
            GeoreferencingService georeferencingService,
            EstablishmentValidationService validationService) {
        
        validateCreationParameters(matricialNumber, name, type, segment, location, address);
        
        // Validar coordenadas GPS
        georeferencingService.validateCaboVerdeCoordinates(location);
        
        // Validar unicidade do número matricial
        validationService.validateUniqueMatricialNumber(matricialNumber);
        
        Establishment establishment = new Establishment(
            EstablishmentId.generate(),
            matricialNumber,
            name,
            tradeName,
            type,
            segment,
            location,
            address,
            EstablishmentStatus.PENDING,
            createdBy
        );
        
        establishment.addDomainEvent(new EstablishmentCreatedEvent(establishment.getId()));
        
        return establishment;
    }
    
    public void updateLocation(
            GeoLocation newLocation,
            String updatedBy,
            GeoreferencingService georeferencingService) {
        
        georeferencingService.validateCaboVerdeCoordinates(newLocation);
        
        GeoLocation oldLocation = this.location;
        this.location = newLocation;
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
        
        addDomainEvent(new EstablishmentLocationUpdatedEvent(
            this.id, oldLocation, newLocation));
    }
    
    public void addDocument(
            String documentType,
            String documentName,
            String documentUrl,
            String mimeType,
            Long fileSize,
            LocalDate expiryDate,
            String uploadedBy,
            DocumentValidationService documentValidationService) {
        
        // Validar tipo de documento para o segmento
        documentValidationService.validateDocumentTypeForSegment(documentType, this.segment);
        
        EstablishmentDocument document = EstablishmentDocument.create(
            this,
            documentType,
            documentName,
            documentUrl,
            mimeType,
            fileSize,
            expiryDate,
            uploadedBy
        );
        
        this.documents.add(document);
        
        addDomainEvent(new EstablishmentDocumentAddedEvent(
            this.id, document.getId(), documentType));
    }
    
    public void activate(String updatedBy, ComplianceService complianceService) {
        // Validar conformidade antes de ativar
        complianceService.validateEstablishmentCompliance(this);
        
        this.status = EstablishmentStatus.ACTIVE;
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
        
        addDomainEvent(new EstablishmentActivatedEvent(this.id));
    }
    
    public void suspend(String reason, String updatedBy) {
        if (this.status != EstablishmentStatus.ACTIVE) {
            throw new DomainException("Only active establishments can be suspended");
        }
        
        this.status = EstablishmentStatus.SUSPENDED;
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
        
        addDomainEvent(new EstablishmentSuspendedEvent(this.id, reason));
    }
    
    // Validações privadas
    private static void validateCreationParameters(
            MatricialNumber matricialNumber,
            String name,
            EstablishmentType type,
            EstablishmentSegment segment,
            GeoLocation location,
            Address address) {
        
        if (matricialNumber == null) {
            throw new DomainException("Matricial number is required");
        }
        if (name == null || name.trim().isEmpty()) {
            throw new DomainException("Establishment name is required");
        }
        if (type == null) {
            throw new DomainException("Establishment type is required");
        }
        if (segment == null) {
            throw new DomainException("Establishment segment is required");
        }
        if (location == null) {
            throw new DomainException("Location is required");
        }
        if (address == null) {
            throw new DomainException("Address is required");
        }
    }
}
```

#### 3.1.2 Value Objects

```java
@Embeddable
public class EstablishmentId {
    @Column(name = "id")
    private UUID value;
    
    public static EstablishmentId generate() {
        return new EstablishmentId(UUID.randomUUID());
    }
    
    public static EstablishmentId of(UUID value) {
        if (value == null) {
            throw new IllegalArgumentException("EstablishmentId cannot be null");
        }
        return new EstablishmentId(value);
    }
}

@Embeddable
public class MatricialNumber {
    @Column(name = "matricial_number")
    private String value;
    
    public static MatricialNumber of(String value) {
        validateFormat(value);
        return new MatricialNumber(value);
    }
    
    private static void validateFormat(String value) {
        if (value == null || value.trim().isEmpty()) {
            throw new DomainException("Matricial number cannot be empty");
        }
        if (!value.matches("^[A-Z]{2}\\d{8}$")) {
            throw new DomainException("Invalid matricial number format. Expected: XX12345678");
        }
    }
}

@Embeddable
public class GeoLocation {
    @Column(name = "latitude", precision = 10, scale = 8)
    private BigDecimal latitude;
    
    @Column(name = "longitude", precision = 11, scale = 8)
    private BigDecimal longitude;
    
    public static GeoLocation of(BigDecimal latitude, BigDecimal longitude) {
        validateCoordinates(latitude, longitude);
        return new GeoLocation(latitude, longitude);
    }
    
    private static void validateCoordinates(BigDecimal lat, BigDecimal lon) {
        if (lat == null || lon == null) {
            throw new DomainException("Coordinates cannot be null");
        }
        if (lat.compareTo(new BigDecimal("-90")) < 0 || lat.compareTo(new BigDecimal("90")) > 0) {
            throw new DomainException("Invalid latitude: " + lat);
        }
        if (lon.compareTo(new BigDecimal("-180")) < 0 || lon.compareTo(new BigDecimal("180")) > 0) {
            throw new DomainException("Invalid longitude: " + lon);
        }
    }
    
    public double distanceTo(GeoLocation other) {
        // Implementar cálculo de distância usando fórmula de Haversine
        double lat1Rad = Math.toRadians(this.latitude.doubleValue());
        double lat2Rad = Math.toRadians(other.latitude.doubleValue());
        double deltaLatRad = Math.toRadians(other.latitude.subtract(this.latitude).doubleValue());
        double deltaLonRad = Math.toRadians(other.longitude.subtract(this.longitude).doubleValue());
        
        double a = Math.sin(deltaLatRad / 2) * Math.sin(deltaLatRad / 2) +
                   Math.cos(lat1Rad) * Math.cos(lat2Rad) *
                   Math.sin(deltaLonRad / 2) * Math.sin(deltaLonRad / 2);
        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        
        return 6371000 * c; // Raio da Terra em metros
    }
}

## 4. REST API Specification

### 4.1 Base Configuration

**Base URL:** `/api/v1/establishments`

**Headers Obrigatórios:**
```

Content-Type: application/json
Authorization: Bearer {jwt\_token}
X-Request-ID: {unique\_request\_id}

````Markdown

**Códigos de Status Padrão:**
- `200 OK` - Operação bem-sucedida
- `201 Created` - Recurso criado com sucesso
- `400 Bad Request` - Dados inválidos na requisição
- `401 Unauthorized` - Token de autenticação inválido
- `403 Forbidden` - Acesso negado
- `404 Not Found` - Recurso não encontrado
- `409 Conflict` - Conflito de dados (ex: número matricial duplicado)
- `422 Unprocessable Entity` - Erro de validação de negócio
- `500 Internal Server Error` - Erro interno do servidor

### 4.2 Endpoints de Estabelecimentos

#### 4.2.1 Criar Estabelecimento

**POST** `/api/v1/establishments`

**Request Body:**
```json
{
  "matricialNumber": "CV12345678",
  "name": "Restaurante Cabo Verde",
  "tradeName": "Sabores da Terra",
  "establishmentType": "COMMERCIAL",
  "segment": "FOOD_SERVICE",
  "classificationCode": "56101",
  "description": "Restaurante especializado em culinária cabo-verdiana",
  "location": {
    "latitude": 14.9177,
    "longitude": -23.5092
  },
  "address": {
    "street": "Rua da Praia, 123",
    "parish": "Nossa Senhora da Graça",
    "municipality": "Praia",
    "island": "Santiago",
    "postalCode": "7600-001"
  },
  "contactInfo": {
    "primaryPhone": "+238 260 1234",
    "email": "contato@saboresdaterra.cv"
  }
}
````

**Response (201 Created):**

```json
{
  "success": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "matricialNumber": "CV12345678",
    "name": "Restaurante Cabo Verde",
    "tradeName": "Sabores da Terra",
    "establishmentType": "COMMERCIAL",
    "segment": "FOOD_SERVICE",
    "status": "PENDING",
    "location": {
      "latitude": 14.9177,
      "longitude": -23.5092
    },
    "address": {
      "street": "Rua da Praia, 123",
      "parish": "Nossa Senhora da Graça",
      "municipality": "Praia",
      "island": "Santiago",
      "postalCode": "7600-001"
    },
    "createdAt": "2025-01-15T10:30:00Z",
    "createdBy": "user123"
  },
  "message": "Estabelecimento criado com sucesso"
}
```

**Exemplo cURL:**

```bash
curl -X POST "https://api.licenciamento.cv/api/v1/establishments" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." \
  -d '{
    "matricialNumber": "CV12345678",
    "name": "Restaurante Cabo Verde",
    "establishmentType": "COMMERCIAL",
    "segment": "FOOD_SERVICE",
    "location": {
      "latitude": 14.9177,
      "longitude": -23.5092
    },
    "address": {
      "street": "Rua da Praia, 123",
      "municipality": "Praia",
      "island": "Santiago"
    }
  }'
```

#### 4.2.2 Buscar Estabelecimento por ID

**GET** `/api/v1/establishments/{id}`

**Path Parameters:**

* `id` (UUID) - ID único do estabelecimento

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "matricialNumber": "CV12345678",
    "name": "Restaurante Cabo Verde",
    "tradeName": "Sabores da Terra",
    "establishmentType": "COMMERCIAL",
    "segment": "FOOD_SERVICE",
    "status": "ACTIVE",
    "location": {
      "latitude": 14.9177,
      "longitude": -23.5092
    },
    "address": {
      "street": "Rua da Praia, 123",
      "parish": "Nossa Senhora da Graça",
      "municipality": "Praia",
      "island": "Santiago",
      "postalCode": "7600-001"
    },
    "documents": [
      {
        "id": "doc-123",
        "documentType": "BUSINESS_LICENSE",
        "documentName": "Alvará de Funcionamento",
        "status": "ACTIVE",
        "uploadDate": "2025-01-15T10:30:00Z"
      }
    ],
    "createdAt": "2025-01-15T10:30:00Z",
    "updatedAt": "2025-01-15T10:30:00Z"
  }
}
```

#### 4.2.3 Listar Estabelecimentos

**GET** `/api/v1/establishments`

**Query Parameters:**

* `page` (int, default: 0) - Número da página

* `size` (int, default: 20, max: 100) - Tamanho da página

* `sort` (string, default: "createdAt,desc") - Ordenação (campo,direção)

* `segment` (string) - Filtrar por segmento

* `municipality` (string) - Filtrar por município

* `island` (string) - Filtrar por ilha

* `status` (string) - Filtrar por status

* `search` (string) - Busca textual em nome/nome comercial

* `latitude` (decimal) - Latitude para busca por proximidade

* `longitude` (decimal) - Longitude para busca por proximidade

* `radius` (int) - Raio em metros para busca por proximidade

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "content": [
      {
        "id": "550e8400-e29b-41d4-a716-446655440000",
        "matricialNumber": "CV12345678",
        "name": "Restaurante Cabo Verde",
        "tradeName": "Sabores da Terra",
        "establishmentType": "COMMERCIAL",
        "segment": "FOOD_SERVICE",
        "status": "ACTIVE",
        "municipality": "Praia",
        "island": "Santiago",
        "createdAt": "2025-01-15T10:30:00Z"
      }
    ],
    "pageable": {
      "page": 0,
      "size": 20,
      "sort": "createdAt,desc"
    },
    "totalElements": 1,
    "totalPages": 1,
    "first": true,
    "last": true
  }
}
```

#### 4.2.4 Atualizar Estabelecimento

**PUT** `/api/v1/establishments/{id}`

**Path Parameters:**

* `id` (UUID) - ID único do estabelecimento

**Request Body:**

```json
{
  "name": "Restaurante Cabo Verde Atualizado",
  "tradeName": "Novos Sabores da Terra",
  "description": "Restaurante renovado com nova carta",
  "contactInfo": {
    "primaryPhone": "+238 260 5678",
    "secondaryPhone": "+238 260 9999",
    "email": "novo@saboresdaterra.cv"
  }
}
```

#### 4.2.5 Atualizar Localização

**PATCH** `/api/v1/establishments/{id}/location`

**Request Body:**

```json
{
  "location": {
    "latitude": 14.9200,
    "longitude": -23.5100
  },
  "address": {
    "street": "Rua Nova, 456",
    "parish": "Nossa Senhora da Graça",
    "municipality": "Praia",
    "island": "Santiago",
    "postalCode": "7600-002"
  }
}
```

#### 4.2.6 Ativar Estabelecimento

**PATCH** `/api/v1/establishments/{id}/activate`

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "status": "ACTIVE",
    "updatedAt": "2025-01-15T11:00:00Z"
  },
  "message": "Estabelecimento ativado com sucesso"
}
```

#### 4.2.7 Suspender Estabelecimento

**PATCH** `/api/v1/establishments/{id}/suspend`

**Request Body:**

```json
{
  "reason": "Documentação em falta",
  "notes": "Aguardando apresentação do alvará sanitário"
}
```

### 4.3 Endpoints de Documentos

#### 4.3.1 Adicionar Documento

**POST** `/api/v1/establishments/{establishmentId}/documents`

**Request Body (multipart/form-data):**

```
documentType: BUSINESS_LICENSE
documentName: Alvará de Funcionamento
file: [binary file data]
expiryDate: 2025-12-31
description: Alvará municipal para funcionamento do restaurante
```

**Response (201 Created):**

```json
{
  "success": true,
  "data": {
    "id": "doc-456",
    "documentType": "BUSINESS_LICENSE",
    "documentName": "Alvará de Funcionamento",
    "documentUrl": "https://storage.licenciamento.cv/docs/doc-456.pdf",
    "mimeType": "application/pdf",
    "fileSize": 2048576,
    "status": "ACTIVE",
    "uploadDate": "2025-01-15T12:00:00Z",
    "expiryDate": "2025-12-31T23:59:59Z"
  }
}
```

#### 4.3.2 Listar Documentos do Estabelecimento

**GET** `/api/v1/establishments/{establishmentId}/documents`

**Query Parameters:**

* `documentType` (string) - Filtrar por tipo de documento

* `status` (string) - Filtrar por status

### 4.4 Endpoints de Busca Geoespacial

#### 4.4.1 Buscar por Proximidade

**GET** `/api/v1/establishments/nearby`

**Query Parameters:**

* `latitude` (decimal, required) - Latitude do ponto de referência

* `longitude` (decimal, required) - Longitude do ponto de referência

* `radius` (int, default: 1000) - Raio em metros

* `segment` (string) - Filtrar por segmento

* `limit` (int, default: 50, max: 100) - Limite de resultados

**Response (200 OK):**

```json
{
  "success": true,
  "data": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "name": "Restaurante Cabo Verde",
      "segment": "FOOD_SERVICE",
      "location": {
        "latitude": 14.9177,
        "longitude": -23.5092
      },
      "distance": 250.5,
      "address": {
        "street": "Rua da Praia, 123",
        "municipality": "Praia"
      }
    }
  ]
}
```

### 4.5 Tratamento de Erros

#### 4.5.1 Erro de Validação (400 Bad Request)

```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Dados de entrada inválidos",
    "details": [
      {
        "field": "matricialNumber",
        "message": "Número matricial deve seguir o formato XX12345678"
      },
      {
        "field": "location.latitude",
        "message": "Latitude deve estar entre 14.8 e 17.2 para Cabo Verde"
      }
    ]
  },
  "timestamp": "2025-01-15T10:30:00Z",
  "path": "/api/v1/establishments"
}
```

#### 4.5.2 Erro de Negócio (422 Unprocessable Entity)

```json
{
  "success": false,
  "error": {
    "code": "BUSINESS_RULE_VIOLATION",
    "message": "Número matricial já existe",
    "details": {
      "matricialNumber": "CV12345678",
      "existingEstablishmentId": "existing-id-123"
    }
  },
  "timestamp": "2025-01-15T10:30:00Z",
  "path": "/api/v1/establishments"
}
```

#### 4.5.3 Recurso Não Encontrado (404 Not Found)

```json
{
  "success": false,
  "error": {
    "code": "ESTABLISHMENT_NOT_FOUND",
    "message": "Estabelecimento não encontrado",
    "details": {
      "establishmentId": "550e8400-e29b-41d4-a716-446655440000"
    }
  },
  "timestamp": "2025-01-15T10:30:00Z",
  "path": "/api/v1/establishments/550e8400-e29b-41d4-a716-446655440000"
}
```

@Embeddable
public class Address {
@Column(name = "address")
private String street;

```Java
@Column(name = "parish")
private String parish;

@Column(name = "municipality")
private String municipality;

@Column(name = "island")
private String island;

@Column(name = "postal_code")
private String postalCode;

public static Address of(String street, String parish, String municipality, String island, String postalCode) {
    validateAddress(street, municipality, island);
    return new Address(street, parish, municipality, island, postalCode);
}

private static void validateAddress(String street, String municipality, String island) {
    if (street == null || street.trim().isEmpty()) {
        throw new DomainException("Street address is required");
    }
    if (municipality == null || municipality.trim().isEmpty()) {
        throw new DomainException("Municipality is required");
    }
    if (island == null || island.trim().isEmpty()) {
        throw new DomainException("Island is required");
    }
}
```

}

```java

#### 3.1.3 Enums

```java
public enum EstablishmentType {
    COMMERCIAL("Comercial"),
    INDUSTRIAL("Industrial"),
    SERVICE("Serviços"),
    TOURISM("Turismo"),
    AGRICULTURE("Agricultura"),
    FISHERY("Pesca"),
    TRANSPORT("Transporte"),
    FINANCIAL("Financeiro"),
    HEALTH("Saúde"),
    EDUCATION("Educação");
    
    private final String description;
    
    EstablishmentType(String description) {
        this.description = description;
    }
}

public enum EstablishmentSegment {
    RETAIL("Varejo"),
    WHOLESALE("Atacado"),
    MANUFACTURING("Manufatura"),
    HOSPITALITY("Hospitalidade"),
    FOOD_SERVICE("Alimentação"),
    AUTOMOTIVE("Automotivo"),
    CONSTRUCTION("Construção"),
    TECHNOLOGY("Tecnologia"),
    HEALTHCARE("Cuidados de Saúde"),
    PROFESSIONAL_SERVICES("Serviços Profissionais");
    
    private final String description;
    
    EstablishmentSegment(String description) {
        this.description = description;
    }
}

public enum EstablishmentStatus {
    PENDING("Pendente"),
    ACTIVE("Ativo"),
    INACTIVE("Inativo"),
    SUSPENDED("Suspenso");
    
    private final String description;
    
    EstablishmentStatus(String description) {
        this.description = description;
    }
}
````

#### 3.1.4 Repository Interface

```java
public interface EstablishmentRepository {
    Optional<Establishment> findById(EstablishmentId id);
    Optional<Establishment> findByMatricialNumber(MatricialNumber matricialNumber);
    List<Establishment> findBySegment(EstablishmentSegment segment);
    List<Establishment> findByStatus(EstablishmentStatus status);
    List<Establishment> findByMunicipality(String municipality);
    List<Establishment> findNearby(GeoLocation location, double radiusInMeters);
    Page<Establishment> findAll(Pageable pageable);
    Page<Establishment> findByFilters(EstablishmentSearchCriteria criteria, Pageable pageable);
    Establishment save(Establishment establishment);
    void delete(Establishment establishment);
    boolean existsByMatricialNumber(MatricialNumber matricialNumber);
    long countBySegment(EstablishmentSegment segment);
    long countByMunicipality(String municipality);
}
```

#### 3.1.5 Domain Services

```java
@Service
public class GeoreferencingService {
    
    // Coordenadas dos limites de Cabo Verde
    private static final BigDecimal MIN_LATITUDE = new BigDecimal("14.8");
    private static final BigDecimal MAX_LATITUDE = new BigDecimal("17.2");
    private static final BigDecimal MIN_LONGITUDE = new BigDecimal("-25.4");
    private static final BigDecimal MAX_LONGITUDE = new BigDecimal("-22.7");
    
    public void validateCaboVerdeCoordinates(GeoLocation location) {
        if (!isWithinCaboVerde(location)) {
            throw new DomainException(
                String.format("Coordinates (%.6f, %.6f) are outside Cabo Verde territory",
                    location.getLatitude(), location.getLongitude()));
        }
    }
    
    public boolean isWithinCaboVerde(GeoLocation location) {
        return location.getLatitude().compareTo(MIN_LATITUDE) >= 0 &&
               location.getLatitude().compareTo(MAX_LATITUDE) <= 0 &&
               location.getLongitude().compareTo(MIN_LONGITUDE) >= 0 &&
               location.getLongitude().compareTo(MAX_LONGITUDE) <= 0;
    }
    
    public List<Establishment> findNearbyEstablishments(
            GeoLocation center, 
            double radiusInMeters,
            EstablishmentRepository repository) {
        
        return repository.findNearby(center, radiusInMeters);
    }
    
    public String determineIslandByCoordinates(GeoLocation location) {
        // Implementar lógica para determinar a ilha baseada nas coordenadas
        // Esta é uma implementação simplificada
        if (location.getLatitude().compareTo(new BigDecimal("16.0")) > 0) {
            return "Santo Antão";
        } else if (location.getLatitude().compareTo(new BigDecimal("15.5")) > 0) {
            return "São Vicente";
        } else {
            return "Santiago";
        }
    }
}

@Service
public class EstablishmentValidationService {
    
    private final EstablishmentRepository establishmentRepository;
    
    public void validateUniqueMatricialNumber(MatricialNumber matricialNumber) {
        if (establishmentRepository.existsByMatricialNumber(matricialNumber)) {
            throw new DomainException("Matricial number already exists: " + matricialNumber.getValue());
        }
    }
    
    public void validateEstablishmentForLicensing(Establishment establishment) {
        if (establishment.getStatus() != EstablishmentStatus.ACTIVE) {
            throw new DomainException("Only active establishments can receive licenses");
        }
        
        // Validar se tem documentação mínima necessária
        if (establishment.getDocuments().isEmpty()) {
            throw new DomainException("Establishment must have required documentation");
        }
    }
    
    public void validateSegmentCompatibility(
            EstablishmentSegment segment, 
            String licenseType) {
        // Implementar validação de compatibilidade entre segmento e tipo de licença
        // Esta lógica seria baseada em regras de negócio específicas
    }
}

@Service
public class DocumentValidationService {
    
    private final Map<EstablishmentSegment, List<String>> requiredDocumentsBySegment;
    
    public DocumentValidationService() {
        // Inicializar mapa de documentos obrigatórios por segmento
        requiredDocumentsBySegment = Map.of(
            EstablishmentSegment.FOOD_SERVICE, List.of("HEALTH_CERTIFICATE", "FIRE_SAFETY"),
            EstablishmentSegment.RETAIL, List.of("COMMERCIAL_REGISTRATION", "TAX_CLEARANCE"),
            EstablishmentSegment.MANUFACTURING, List.of("ENVIRONMENTAL_LICENSE", "SAFETY_CERTIFICATE")
        );
    }
    
    public void validateDocumentTypeForSegment(String documentType, EstablishmentSegment segment) {
        List<String> allowedTypes = getAllowedDocumentTypes(segment);
        if (!allowedTypes.contains(documentType)) {
            throw new DomainException(
                String.format("Document type %s is not allowed for segment %s", 
                    documentType, segment));
        }
    }
    
    public List<String> getRequiredDocuments(EstablishmentSegment segment) {
        return requiredDocumentsBySegment.getOrDefault(segment, List.of());
    }
    
    public boolean hasAllRequiredDocuments(Establishment establishment) {
        List<String> required = getRequiredDocuments(establishment.getSegment());
        List<String> existing = establishment.getDocuments().stream()
            .map(EstablishmentDocument::getDocumentType)
            .toList();
        
        return existing.containsAll(required);
    }
    
    private List<String> getAllowedDocumentTypes(EstablishmentSegment segment) {
        // Retornar lista completa de tipos de documentos permitidos para o segmento
        return switch (segment) {
            case FOOD_SERVICE -> List.of("HEALTH_CERTIFICATE", "FIRE_SAFETY", "COMMERCIAL_REGISTRATION");
            case RETAIL -> List.of("COMMERCIAL_REGISTRATION", "TAX_CLEARANCE", "FIRE_SAFETY");
            case MANUFACTURING -> List.of("ENVIRONMENTAL_LICENSE", "SAFETY_CERTIFICATE", "INDUSTRIAL_REGISTRATION");
            default -> List.of("COMMERCIAL_REGISTRATION", "TAX_CLEARANCE");
        };
    }
}

@Service
public class ComplianceService {
    
    private final DocumentValidationService documentValidationService;
    private final GeoreferencingService georeferencingService;
    
    public void validateEstablishmentCompliance(Establishment establishment) {
        // Validar localização
        georeferencingService.validateCaboVerdeCoordinates(establishment.getLocation());
        
        // Validar documentação obrigatória
        if (!documentValidationService.hasAllRequiredDocuments(establishment)) {
            throw new DomainException("Establishment does not have all required documents");
        }
        
        // Validar documentos não expirados
        boolean hasExpiredDocuments = establishment.getDocuments().stream()
            .anyMatch(doc -> doc.getExpiryDate() != null && 
                           doc.getExpiryDate().isBefore(LocalDate.now()));
        
        if (hasExpiredDocuments) {
            throw new DomainException("Establishment has expired documents");
        }
    }
    
    public ComplianceReport generateComplianceReport(Establishment establishment) {
        List<String> issues = new ArrayList<>();
        
        // Verificar localização
        if (!georeferencingService.isWithinCaboVerde(establishment.getLocation())) {
            issues.add("Location outside Cabo Verde territory");
        }
        
        // Verificar documentação
        List<String> missingDocs = documentValidationService.getRequiredDocuments(establishment.getSegment())
            .stream()
            .filter(required -> establishment.getDocuments().stream()
                .noneMatch(doc -> doc.getDocumentType().equals(required)))
            .toList();
        
        if (!missingDocs.isEmpty()) {
            issues.add("Missing required documents: " + String.join(", ", missingDocs));
        }
        
        return new ComplianceReport(establishment.getId(), issues.isEmpty(), issues);
    }
}
```

### 3.2 Application Layer

#### 3.2.1 Use Cases

```java
@UseCase
@Transactional
public class CreateEstablishmentUseCase {
    
    private final EstablishmentRepository establishmentRepository;
    private final GeoreferencingService georeferencingService;
    private final EstablishmentValidationService validationService;
    
    public EstablishmentResponse execute(CreateEstablishmentCommand command) {
        // Criar localização
        GeoLocation location = GeoLocation.of(command.getLatitude(), command.getLongitude());
        
        // Criar endereço
        Address address = Address.of(
            command.getAddress(),
            command.getParish(),
            command.getMunicipality(),
            command.getIsland(),
            command.getPostalCode()
        );
        
        // Criar número matricial
        MatricialNumber matricialNumber = MatricialNumber.of(command.getMatricialNumber());
        
        // Criar estabelecimento
        Establishment establishment = Establishment.create(
            matricialNumber,
            command.getName(),
            command.getTradeName(),
            command.getEstablishmentType(),
            command.getSegment(),
            location,
            address,
            command.getCreatedBy(),
            georeferencingService,
            validationService
        );
        
        // Salvar
        Establishment saved = establishmentRepository.save(establishment);
        
        return EstablishmentResponse.from(saved);
    }
}

@UseCase
@Transactional
public class UpdateEstablishmentLocationUseCase {
    
    private final EstablishmentRepository establishmentRepository;
    private final GeoreferencingService georeferencingService;
    
    public EstablishmentResponse execute(UpdateEstablishmentLocationCommand command) {
        // Buscar estabelecimento
        Establishment establishment = establishmentRepository
            .findById(command.getEstablishmentId())
            .orElseThrow(() -> new EntityNotFoundException("Establishment not found"));
        
        // Criar nova localização
        GeoLocation newLocation = GeoLocation.of(command.getLatitude(), command.getLongitude());
        
        // Atualizar localização
        establishment.updateLocation(newLocation, command.getUpdatedBy(), georeferencingService);
        
        // Salvar
        Establishment updated = establishmentRepository.save(establishment);
        
        return EstablishmentResponse.from(updated);
    }
}

@UseCase
@Transactional
public class AddEstablishmentDocumentUseCase {
    
    private final EstablishmentRepository establishmentRepository;
    private final DocumentValidationService documentValidationService;
    private final FileStorageService fileStorageService;
    
    public EstablishmentDocumentResponse execute(AddEstablishmentDocumentCommand command) {
        // Buscar estabelecimento
        Establishment establishment = establishmentRepository
            .findById(command.getEstablishmentId())
            .orElseThrow(() -> new EntityNotFoundException("Establishment not found"));
        
        // Upload do arquivo
        String documentUrl = fileStorageService.uploadDocument(
            command.getFile(),
            "establishments/" + establishment.getId().getValue()
        );
        
        // Adicionar documento
        establishment.addDocument(
            command.getDocumentType(),
            command.getDocumentName(),
            documentUrl,
            command.getFile().getContentType(),
            command.getFile().getSize(),
            command.getExpiryDate(),
            command.getUploadedBy(),
            documentValidationService
        );
        
        // Salvar
        Establishment updated = establishmentRepository.save(establishment);
        
        // Retornar documento adicionado
        EstablishmentDocument addedDocument = updated.getDocuments().stream()
            .filter(doc -> doc.getDocumentUrl().equals(documentUrl))
            .findFirst()
            .orElseThrow();
        
        return EstablishmentDocumentResponse.from(addedDocument);
    }
}

@UseCase
@Transactional(readOnly = true)
public class FindNearbyEstablishmentsUseCase {
    
    private final EstablishmentRepository establishmentRepository;
    private final GeoreferencingService georeferencingService;
    
    public List<EstablishmentResponse> execute(FindNearbyEstablishmentsQuery query) {
        GeoLocation center = GeoLocation.of(query.getLatitude(), query.getLongitude());
        
        List<Establishment> nearby = georeferencingService.findNearbyEstablishments(
            center,
            query.getRadiusInMeters(),
            establishmentRepository
        );
        
        return nearby.stream()
            .map(EstablishmentResponse::from)
            .toList();
    }
}
```

#### 3.2.2 Commands e Queries

```java
public class CreateEstablishmentCommand {
    @NotBlank(message = "Matricial number cannot be blank")
    private String matricialNumber;
    
    @NotBlank(message = "Name cannot be blank")
    @Size(max = 255, message = "Name cannot exceed 255 characters")
    private String name;
    
    @Size(max = 255, message = "Trade name cannot exceed 255 characters")
    private String tradeName;
    
    @NotNull(message = "Establishment type is required")
    private EstablishmentType establishmentType;
    
    @NotNull(message = "Segment is required")
    private EstablishmentSegment segment;
    
    @NotNull(message = "Latitude is required")
    @DecimalMin(value = "-90.0", message = "Latitude must be between -90 and 90")
    @DecimalMax(value = "90.0", message = "Latitude must be between -90 and 90")
    private BigDecimal latitude;
    
    @NotNull(message = "Longitude is required")
    @DecimalMin(value = "-180.0", message = "Longitude must be between -180 and 180")
    @DecimalMax(value = "180.0", message = "Longitude must be between -180 and 180")
    private BigDecimal longitude;
    
    @NotBlank(message = "Address cannot be blank")
    private String address;
    
    private String parish;
    
    @NotBlank(message = "Municipality cannot be blank")
    private String municipality;
    
    @NotBlank(message = "Island cannot be blank")
    private String island;
    
    private String postalCode;
    
    @NotBlank(message = "Created by cannot be blank")
    private String createdBy;
    
    // Getters e setters
}

public class UpdateEstablishmentLocationCommand {
    @NotNull(message = "Establishment ID is required")
    private EstablishmentId establishmentId;
    
    @NotNull(message = "Latitude is required")
    @DecimalMin(value = "-90.0", message = "Latitude must be between -90 and 90")
    @DecimalMax(value = "90.0", message = "Latitude must be between -90 and 90")
    private BigDecimal latitude;
    
    @NotNull(message = "Longitude is required")
    @DecimalMin(value = "-180.0", message = "Longitude must be between -180 and 180")
    @DecimalMax(value = "180.0", message = "Longitude must be between -180 and 180")
    private BigDecimal longitude;
    
    @NotBlank(message = "Updated by cannot be blank")
    private String updatedBy;
    
    // Getters e setters
}

public class FindNearbyEstablishmentsQuery {
    @NotNull(message = "Latitude is required")
    private BigDecimal latitude;
    
    @NotNull(message = "Longitude is required")
    private BigDecimal longitude;
    
    @Min(value = 1, message = "Radius must be at least 1 meter")
    @Max(value = 50000, message = "Radius cannot exceed 50km")
    private double radiusInMeters = 1000; // Default 1km
    
    // Getters e setters
}
```

#### 3.2.3 Response DTOs

```java
public class EstablishmentResponse {
    private UUID id;
    private String matricialNumber;
    private String name;
    private String tradeName;
    private EstablishmentType establishmentType;
    private EstablishmentSegment segment;
    private String classificationCode;
    private String description;
    private BigDecimal latitude;
    private BigDecimal longitude;
    private String address;
    private String parish;
    private String municipality;
    private String island;
    private String postalCode;
    private EstablishmentStatus status;
    private boolean active;
    private Map<String, Object> metadata;
    private Instant createdAt;
    private Instant updatedAt;
    private String createdBy;
    private String updatedBy;
    private List<EstablishmentDocumentResponse> documents;
    private List<EstablishmentRegistrationResponse> registrations;
    
    public static EstablishmentResponse from(Establishment establishment) {
        return EstablishmentResponse.builder()
            .id(establishment.getId().getValue())
            .matricialNumber(establishment.getMatricialNumber().getValue())
            .name(establishment.getName())
            .tradeName(establishment.getTradeName())
            .establishmentType(establishment.getEstablishmentType())
            .segment(establishment.getSegment())
            .latitude(establishment.getLocation().getLatitude())
            .longitude(establishment.getLocation().getLongitude())
            .address(establishment.getAddress().getStreet())
            .parish(establishment.getAddress().getParish())
            .municipality(establishment.getAddress().getMunicipality())
            .island(establishment.getAddress().getIsland())
            .postalCode(establishment.getAddress().getPostalCode())
            .status(establishment.getStatus())
            .active(establishment.isActive())
            .createdAt(establishment.getCreatedAt())
            .updatedAt(establishment.getUpdatedAt())
            .createdBy(establishment.getCreatedBy())
            .updatedBy(establishment.getUpdatedBy())
            .documents(establishment.getDocuments().stream()
                .map(EstablishmentDocumentResponse::from)
                .toList())
            .registrations(establishment.getRegistrations().stream()
                .map(EstablishmentRegistrationResponse::from)
                .toList())
            .build();
    }
}

public class EstablishmentDocumentResponse {
    private UUID id;
    private String documentType;
    private String documentName;
    private String documentUrl;
    private String mimeType;
    private Long fileSize;
    private String status;
    private Instant uploadDate;
    private LocalDate expiryDate;
    private String uploadedBy;
    
    public static EstablishmentDocumentResponse from(EstablishmentDocument document) {
        return EstablishmentDocumentResponse.builder()
            .id(document.getId().getValue())
            .documentType(document.getDocumentType())
            .documentName(document.getDocumentName())
            .documentUrl(document.getDocumentUrl())
            .mimeType(document.getMimeType())
            .fileSize(document.getFileSize())
            .status(document.getStatus())
            .uploadDate(document.getUploadDate())
            .expiryDate(document.getExpiryDate())
            .uploadedBy(document.getUploadedBy())
            .build();
    }
}
```

## 4. Interface Layer (REST Controllers)

### 4.1 EstablishmentController

```java
@RestController
@RequestMapping("/api/v1/establishments")
@RequiredArgsConstructor
@Validated
public class EstablishmentController {
    
    private final CreateEstablishmentUseCase createEstablishmentUseCase;
    private final UpdateEstablishmentLocationUseCase updateLocationUseCase;
    private final AddEstablishmentDocumentUseCase addDocumentUseCase;
    private final FindNearbyEstablishmentsUseCase findNearbyUseCase;
    private final EstablishmentQueryService queryService;
    
    @GetMapping
    public ResponseEntity<PagedResponse<EstablishmentResponse>> getAllEstablishments(
            @Valid @ModelAttribute EstablishmentSearchRequest request,
            Pageable pageable) {
        
        Page<EstablishmentResponse> establishments = queryService.searchEstablishments(request, pageable);
        PagedResponse<EstablishmentResponse> response = PagedResponse.from(establishments);
        
        return ResponseEntity.ok(response);
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<EstablishmentResponse> getEstablishmentById(
            @PathVariable UUID id) {
        
        EstablishmentResponse establishment = queryService.findById(EstablishmentId.of(id));
        return ResponseEntity.ok(establishment);
    }
    
    @PostMapping
    public ResponseEntity<EstablishmentResponse> createEstablishment(
            @Valid @RequestBody CreateEstablishmentCommand command) {
        
        EstablishmentResponse created = createEstablishmentUseCase.execute(command);
        
        return ResponseEntity.status(HttpStatus.CREATED)
            .location(URI.create("/api/v1/establishments/" + created.getId()))
            .body(created);
    }
    
    @PutMapping("/{id}/location")
    public ResponseEntity<EstablishmentResponse> updateLocation(
            @PathVariable UUID id,
            @Valid @RequestBody UpdateEstablishmentLocationCommand command) {
        
        command.setEstablishmentId(EstablishmentId.of(id));
        EstablishmentResponse updated = updateLocationUseCase.execute(command);
        
        return ResponseEntity.ok(updated);
    }
    
    @PostMapping("/{id}/documents")
    public ResponseEntity<EstablishmentDocumentResponse> addDocument(
            @PathVariable UUID id,
            @Valid @ModelAttribute AddEstablishmentDocumentCommand command) {
        
        command.setEstablishmentId(EstablishmentId.of(id));
        EstablishmentDocumentResponse document = addDocumentUseCase.execute(command);
        
        return ResponseEntity.status(HttpStatus.CREATED).body(document);
    }
    
    @GetMapping("/nearby")
    public ResponseEntity<List<EstablishmentResponse>> findNearbyEstablishments(
            @Valid @ModelAttribute FindNearbyEstablishmentsQuery query) {
        
        List<EstablishmentResponse> nearby = findNearbyUseCase.execute(query);
        return ResponseEntity.ok(nearby);
    }
    
    @GetMapping("/{id}/compliance")
    public ResponseEntity<ComplianceReport> getComplianceReport(
            @PathVariable UUID id) {
        
        ComplianceReport report = queryService.getComplianceReport(EstablishmentId.of(id));
        return ResponseEntity.ok(report);
    }
}
```

## 5. Testes

### 5.1 Testes Unitários de Domínio

```java
@ExtendWith(MockitoExtension.class)
class EstablishmentTest {
    
    @Mock
    private GeoreferencingService georeferencingService;
    
    @Mock
    private EstablishmentValidationService validationService;
    
    @Test
    void shouldCreateEstablishmentSuccessfully() {
        // Given
        MatricialNumber matricialNumber = MatricialNumber.of("CV12345678");
        String name = "Restaurante Cabo Verde";
        EstablishmentType type = EstablishmentType.COMMERCIAL;
        EstablishmentSegment segment = EstablishmentSegment.FOOD_SERVICE;
        GeoLocation location = GeoLocation.of(
            new BigDecimal("14.9167"), 
            new BigDecimal("-23.5167")
        );
        Address address = Address.of(
            "Rua Principal, 123", 
            "Nossa Senhora da Graça", 
            "Praia", 
            "Santiago", 
            "7600"
        );
        String createdBy = "admin";
        
        // When
        Establishment establishment = Establishment.create(
            matricialNumber, name, null, type, segment, 
            location, address, createdBy,
            georeferencingService, validationService
        );
        
        // Then
        assertThat(establishment.getId()).isNotNull();
        assertThat(establishment.getName()).isEqualTo(name);
        assertThat(establishment.getStatus()).isEqualTo(EstablishmentStatus.PENDING);
        assertThat(establishment.getDomainEvents()).hasSize(1);
        assertThat(establishment.getDomainEvents().get(0))
            .isInstanceOf(EstablishmentCreatedEvent.class);
        
        verify(georeferencingService).validateCaboVerdeCoordinates(location);
        verify(validationService).validateUniqueMatricialNumber(matricialNumber);
    }
    
    @Test
    void shouldThrowExceptionWhenCreatingWithInvalidCoordinates() {
        // Given
        GeoLocation invalidLocation = GeoLocation.of(
            new BigDecimal("0.0"), 
            new BigDecimal("0.0")
        );
        
        doThrow(new DomainException("Invalid coordinates"))
            .when(georeferencingService).validateCaboVerdeCoordinates(invalidLocation);
        
        // When & Then
        assertThatThrownBy(() -> 
            Establishment.create(
                MatricialNumber.of("CV12345678"),
                "Test Establishment",
                null,
                EstablishmentType.COMMERCIAL,
                EstablishmentSegment.RETAIL,
                invalidLocation,
                Address.of("Test", null, "Praia", "Santiago", null),
                "admin",
                georeferencingService,
                validationService
            )
        ).isInstanceOf(DomainException.class)
         .hasMessage("Invalid coordinates");
    }
}

@ExtendWith(MockitoExtension.class)
class GeoreferencingServiceTest {
    
    private GeoreferencingService georeferencingService;
    
    @BeforeEach
    void setUp() {
        georeferencingService = new GeoreferencingService();
    }
    
    @Test
    void shouldValidateCaboVerdeCoordinatesSuccessfully() {
        // Given - Coordenadas da Praia, Santiago
        GeoLocation praia = GeoLocation.of(
            new BigDecimal("14.9167"), 
            new BigDecimal("-23.5167")
        );
        
        // When & Then
        assertThatNoException()
            .isThrownBy(() -> georeferencingService.validateCaboVerdeCoordinates(praia));
    }
    
    @Test
    void shouldThrowExceptionForCoordinatesOutsideCaboVerde() {
        // Given - Coordenadas de Lisboa, Portugal
        GeoLocation lisboa = GeoLocation.of(
            new BigDecimal("38.7223"), 
            new BigDecimal("-9.1393")
        );
        
        // When & Then
        assertThatThrownBy(() -> 
            georeferencingService.validateCaboVerdeCoordinates(lisboa)
        ).isInstanceOf(DomainException.class)
         .hasMessageContaining("are outside Cabo Verde territory");
    }
    
    @Test
    void shouldCalculateDistanceBetweenLocations() {
        // Given
        GeoLocation praia = GeoLocation.of(
            new BigDecimal("14.9167"), 
            new BigDecimal("-23.5167")
        );
        GeoLocation mindelo = GeoLocation.of(
            new BigDecimal("16.8864"), 
            new BigDecimal("-24.9956")
        );
        
        // When
        double distance = praia.distanceTo(mindelo);
        
        // Then
        assertThat(distance).isGreaterThan(200000); // Mais de 200km
        assertThat(distance).isLessThan(300000);    // Menos de 300km
    }
}
```

### 5.2 Testes de Integração

```java
@SpringBootTest
@Transactional
@TestPropertySource(properties = {
    "spring.datasource.url=jdbc:h2:mem:testdb",
    "spring.jpa.hibernate.ddl-auto=create-drop"
})
class EstablishmentIntegrationTest {
    
    @Autowired
    private CreateEstablishmentUseCase createEstablishmentUseCase;
    
    @Autowired
    private EstablishmentRepository establishmentRepository;
    
    @Test
    void shouldCreateAndRetrieveEstablishment() {
        // Given
        CreateEstablishmentCommand command = CreateEstablishmentCommand.builder()
            .matricialNumber("CV12345678")
            .name("Restaurante Teste")
            .establishmentType(EstablishmentType.COMMERCIAL)
            .segment(EstablishmentSegment.FOOD_SERVICE)
            .latitude(new BigDecimal("14.9167"))
            .longitude(new BigDecimal("-23.5167"))
            .address("Rua Teste, 123")
            .municipality("Praia")
            .island("Santiago")
            .createdBy("test-user")
            .build();
        
        // When
        EstablishmentResponse created = createEstablishmentUseCase.execute(command);
        
        // Then
        assertThat(created.getId()).isNotNull();
        assertThat(created.getName()).isEqualTo("Restaurante Teste");
        assertThat(created.getStatus()).isEqualTo(EstablishmentStatus.PENDING);
        
        // Verificar persistência
        Optional<Establishment> retrieved = establishmentRepository
            .findById(EstablishmentId.of(created.getId()));
        
        assertThat(retrieved).isPresent();
        assertThat(retrieved.get().getName()).isEqualTo("Restaurante Teste");
    }
}
```

## 6. Considerações de Implementação

### 6.1 Performance e Escalabilidade

* **Índices Geoespaciais**: Usar índices GIST para consultas por proximidade

* **Cache de Coordenadas**: Implementar cache para validações de território

* **Paginação Otimizada**: Usar cursor-based pagination para grandes volumes

* **Compressão de Documentos**: Implementar compressão para arquivos grandes

### 6.2 Segurança e Conformidade

* **Validação de Uploads**: Verificar tipos de arquivo e tamanhos máximos

* **Sanitização de Coordenadas**: Validar precisão e formato de coordenadas GPS

* **Auditoria de Localização**: Registrar alterações de localização

* **Controle de Acesso**: Implementar RLS para estabelecimentos por região

### 6.3 Integração e Interoperabilidade

* **APIs Geoespaciais**: Integrar com serviços de mapas e geocodificação

* **Sincronização de Dados**: Implementar sincronização com registros comerciais

* **Notificações**: Alertar sobre documentos próximos do vencimento

* **Relatórios**: Gerar relatórios de conformidade por segmento

Este módulo serve como base para o registro e controle de estabelecimentos no sistema de licenciamento, fornecendo funcionalidades essenciais de geolocalização, documentação e conformidade regulatória.
