# PR01.03-BE-LIC - Dossier Tipo de Licença - Entidades

## 1. Visão Geral

Este documento especifica a gestão das entidades envolvidas nos processos de licenciamento, incluindo órgãos públicos, instituições privadas e outras organizações que participam na análise, aprovação e fiscalização dos diferentes tipos de licença. Este módulo é fundamental para definir o fluxo institucional e as responsabilidades de cada entidade no processo de licenciamento.

**Módulo:** Dossier de Tipo de Licença - Entidades  
**Endpoint Base:** `/api/v1/entities` e `/api/v1/license-types/{id}/entities`  
**Versão:** 1.0  
**Data:** 2025

---

## 2. Estrutura do Módulo de Entidades

### 2.1 Entidade Organizacional

<<<<<<< HEAD
#### 2.1.1 Campos da Entidade
| Campo | Tipo | Validação | Descrição |
|-------|------|-----------|----------|
| id | String | Auto-gerado | Identificador único |
| name | String | 2-200 chars, NotBlank | Nome da entidade |
| acronym | String | 2-20 chars | Sigla ou acrônimo |
| type | String | NotBlank, Must exist in OPTIONS | Tipo de entidade |
| level | String | Must exist in OPTIONS | Nível administrativo |
| parentEntityId | String | Optional | Entidade superior |
| contactInfo | Object | Valid structure | Informações de contato |
| address | Object | Valid structure | Endereço completo |
| jurisdiction | String | Must exist in OPTIONS | Âmbito de jurisdição |
| status | String | NotBlank | Status da entidade |
| competencies | Array | Valid list | Competências da entidade |
=======
- Integrar com sistema de organizações globais (REDGLOBAL.GLB_T_ORGANIZATION)

- Garantir validações robustas e integridade referencial

- Suportar múltiplos tipos de entidade parametrizáveis

## 2. Modelo de Dados Normalizado

### 2.1 Diagrama ER

```mermaid
erDiagram
    T_LICENSE_TYPE ||--o{ T_ENTITY : "has entities"
    T_ENTITY ||--o{ T_ENTITY_CONTACT : "has contacts"
    T_ENTITY {
        uuid id PK
        uuid license_type_id_fk FK
        uuid organization_id_fk FK
        varchar entity_name
        varchar entity_type
        varchar status
        timestamp created_at
        timestamp updated_at
        varchar created_by
        varchar updated_by
    }

    T_ENTITY_CONTACT {
        uuid id PK
        uuid entity_id_fk FK
        varchar contact_name
        varchar phone
        varchar email
        boolean is_primary
        varchar status
        timestamp created_at
        timestamp updated_at
        varchar created_by
        varchar updated_by
    }

    T_LICENSE_TYPE {
        uuid id PK
        varchar name
        varchar description
        uuid sector_id_fk FK
        boolean simplified_regime
        varchar regime
        boolean active
        timestamp created_at
        timestamp updated_at
    }

    T_OPTIONS {
        uuid id PK
        varchar ccode
        varchar ckey
        varchar cvalue
        varchar locale
        integer sort_order
        boolean active
        text description
        timestamp created_at
        timestamp updated_at
    }
```

### 2.2 Definição da Tabela T_ENTITY

```sql
CREATE TABLE t_entity (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    license_type_id_fk UUID NOT NULL,
    organization_id_fk UUID,
    entity_name VARCHAR(255) NOT NULL,
    entity_type VARCHAR(50) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100) NOT NULL,
    updated_by VARCHAR(100) NOT NULL,

    CONSTRAINT fk_entity_license_type
        FOREIGN KEY (license_type_id_fk) REFERENCES t_license_type(id) ON DELETE CASCADE,
    CONSTRAINT chk_entity_name_not_empty
        CHECK (LENGTH(TRIM(entity_name)) > 0),
    CONSTRAINT chk_entity_type_valid
        CHECK (entity_type IN ('DECISAO', 'PARECER', 'VISTORIA'))
);
```

### 2.3 Definição da Tabela T_ENTITY_CONTACT

```sql
CREATE TABLE t_entity_contact (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    entity_id_fk UUID NOT NULL,
    contact_name VARCHAR(255) NOT NULL,
    phone VARCHAR(20),
    email VARCHAR(255),
    is_primary BOOLEAN NOT NULL DEFAULT false,
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100) NOT NULL,
    updated_by VARCHAR(100) NOT NULL,

    CONSTRAINT fk_entity_contact_entity
        FOREIGN KEY (entity_id_fk) REFERENCES t_entity(id) ON DELETE CASCADE,
    CONSTRAINT chk_contact_name_not_empty
        CHECK (LENGTH(TRIM(contact_name)) > 0),
    CONSTRAINT chk_email_format
        CHECK (email IS NULL OR email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')
);
```

### 2.4 Índices

```sql
-- Índice principal para consultas por tipo de licença
CREATE INDEX idx_entity_license_type ON t_entity(license_type_id_fk);

-- Índice para consultas por tipo de entidade
CREATE INDEX idx_entity_type ON t_entity(entity_type);

-- Índice para consultas por status
CREATE INDEX idx_entity_status ON t_entity(status) WHERE status = 'ACTIVE';

-- Índice para auditoria
CREATE INDEX idx_entity_created_at ON t_entity(created_at DESC);

-- Índice composto para consultas filtradas
CREATE INDEX idx_entity_type_status ON t_entity(license_type_id_fk, entity_type, status);

-- Índice para busca textual por nome
CREATE INDEX idx_entity_name_search ON t_entity USING gin(to_tsvector('portuguese', entity_name));

-- Índices para tabela de contatos
CREATE INDEX idx_entity_contact_entity ON t_entity_contact(entity_id_fk);
CREATE INDEX idx_entity_contact_primary ON t_entity_contact(entity_id_fk, is_primary) WHERE is_primary = true;
CREATE INDEX idx_entity_contact_email ON t_entity_contact(email) WHERE email IS NOT NULL;
```

## 3. Arquitetura DDD

### 3.1 Domain Layer

#### 3.1.1 Aggregate Root: Entity
>>>>>>> parent of 2bd9194 (refactor(database): standardize timestamp column names to created_date and last_modified_date)

#### 2.1.2 Estrutura do DTO de Entidade
```java
<<<<<<< HEAD
@Data
@NoArgsConstructor
@AllArgsConstructor
@IgrpDTO
public class EntityRequestDTO {
    @NotNull(message = "Nome é obrigatório")
    @NotBlank(message = "Nome não pode estar vazio")
    @Size(min = 2, max = 200, message = "Nome deve ter entre 2 e 200 caracteres")
    private String name;
    
    @Size(min = 2, max = 20, message = "Sigla deve ter entre 2 e 20 caracteres")
    private String acronym;
    
    @NotNull(message = "Tipo é obrigatório")
    @NotBlank(message = "Tipo não pode estar vazio")
    private String typeKey;  // Referência para OPTIONS com ccode="ENTITY_TYPE"
    
    @NotNull(message = "Nível é obrigatório")
    @NotBlank(message = "Nível não pode estar vazio")
    private String levelKey;  // Referência para OPTIONS com ccode="ENTITY_LEVEL"
    
    private String parentEntityId;
    
=======
@Entity
@Table(name = "t_entity")
public class LicenseEntity {
    @Id
    private EntityId id;

    @Column(name = "license_type_id_fk", nullable = false)
    private LicenseTypeId licenseTypeId;

    @Column(name = "organization_id_fk")
    private OrganizationId organizationId;

    @Column(name = "entity_name", nullable = false)
    private String entityName;

    @Column(name = "entity_type", nullable = false)
    private String entityType;

    @Column(name = "status", nullable = false)
    private String status;

    @OneToMany(mappedBy = "entityId", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<EntityContact> contacts = new ArrayList<>();

    // Campos de auditoria
    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @Column(name = "created_by", nullable = false)
    private String createdBy;

    @Column(name = "updated_by", nullable = false)
    private String updatedBy;

    // Métodos de negócio
    public static LicenseEntity create(
            LicenseTypeId licenseTypeId,
            String entityName,
            String entityType,
            OrganizationId organizationId,
            String createdBy,
            EntityType entityTypeService) {

        validateCreationParameters(licenseTypeId, entityName, entityType, createdBy, entityTypeService);

        return new LicenseEntity(
            EntityId.generate(),
            licenseTypeId,
            organizationId,
            entityName.trim(),
            entityType,
            "ACTIVE",
            createdBy
        );
    }

    public void updateEntityInfo(
            String entityName,
            String entityType,
            OrganizationId organizationId,
            String updatedBy,
            EntityType entityTypeService) {

        validateUpdateParameters(entityName, entityType, updatedBy, entityTypeService);

        this.entityName = entityName.trim();
        this.entityType = entityType;
        this.organizationId = organizationId;
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
    }

    public void addContact(
            String contactName,
            String phone,
            String email,
            boolean isPrimary,
            String createdBy) {

        validateContactParameters(contactName, email);

        if (isPrimary) {
            // Remove primary flag from existing contacts
            contacts.forEach(contact -> contact.setPrimary(false));
        }

        EntityContact contact = EntityContact.create(
            this.id,
            contactName,
            phone,
            email,
            isPrimary,
            createdBy
        );

        this.contacts.add(contact);
        this.updatedAt = Instant.now();
        this.updatedBy = createdBy;
    }

    public void removeContact(EntityContactId contactId, String updatedBy) {
        contacts.removeIf(contact -> contact.getId().equals(contactId));
        this.updatedAt = Instant.now();
        this.updatedBy = updatedBy;
    }

    public void deactivate(String updatedBy) {
        this.status = "INACTIVE";
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
    }

    public void activate(String updatedBy) {
        this.status = "ACTIVE";
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
    }

    // Métodos de validação
    private static void validateCreationParameters(
            LicenseTypeId licenseTypeId,
            String entityName,
            String entityType,
            String createdBy,
            EntityType entityTypeService) {

        if (licenseTypeId == null) {
            throw new IllegalArgumentException("License type ID cannot be null");
        }

        if (entityName == null || entityName.trim().isEmpty()) {
            throw new IllegalArgumentException("Entity name cannot be null or empty");
        }

        if (entityName.trim().length() > 255) {
            throw new IllegalArgumentException("Entity name cannot exceed 255 characters");
        }

        if (!entityTypeService.isValidEntityType(entityType)) {
            throw new IllegalArgumentException("Invalid entity type: " + entityType);
        }

        if (createdBy == null || createdBy.trim().isEmpty()) {
            throw new IllegalArgumentException("Created by cannot be null or empty");
        }
    }

    private static void validateUpdateParameters(
            String entityName,
            String entityType,
            String updatedBy,
            EntityType entityTypeService) {

        if (entityName == null || entityName.trim().isEmpty()) {
            throw new IllegalArgumentException("Entity name cannot be null or empty");
        }

        if (entityName.trim().length() > 255) {
            throw new IllegalArgumentException("Entity name cannot exceed 255 characters");
        }

        if (!entityTypeService.isValidEntityType(entityType)) {
            throw new IllegalArgumentException("Invalid entity type: " + entityType);
        }

        if (updatedBy == null || updatedBy.trim().isEmpty()) {
            throw new IllegalArgumentException("Updated by cannot be null or empty");
        }
    }

    private static void validateContactParameters(String contactName, String email) {
        if (contactName == null || contactName.trim().isEmpty()) {
            throw new IllegalArgumentException("Contact name cannot be null or empty");
        }

        if (contactName.trim().length() > 255) {
            throw new IllegalArgumentException("Contact name cannot exceed 255 characters");
        }

        if (email != null && !email.matches("^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$")) {
            throw new IllegalArgumentException("Invalid email format");
        }
    }

    // Getters
    public EntityId getId() { return id; }
    public LicenseTypeId getLicenseTypeId() { return licenseTypeId; }
    public OrganizationId getOrganizationId() { return organizationId; }
    public String getEntityName() { return entityName; }
    public String getEntityType() { return entityType; }
    public String getStatus() { return status; }
    public List<EntityContact> getContacts() { return Collections.unmodifiableList(contacts); }
    public Instant getCreatedAt() { return createdAt; }
    public Instant getUpdatedAt() { return updatedAt; }
    public String getCreatedBy() { return createdBy; }
    public String getUpdatedBy() { return updatedBy; }
}
```

#### 3.1.2 Entity: EntityContact

```java
@Entity
@Table(name = "t_entity_contact")
public class EntityContact {
    @Id
    private EntityContactId id;

    @Column(name = "entity_id_fk", nullable = false)
    private EntityId entityId;

    @Column(name = "contact_name", nullable = false)
    private String contactName;

    @Column(name = "phone")
    private String phone;

    @Column(name = "email")
    private String email;

    @Column(name = "is_primary", nullable = false)
    private boolean isPrimary;

    @Column(name = "status", nullable = false)
    private String status;

    // Campos de auditoria
    @Column(name = "created_at", nullable = false)
    private Instant createdAt;

    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;

    @Column(name = "created_by", nullable = false)
    private String createdBy;

    @Column(name = "updated_by", nullable = false)
    private String updatedBy;

    public static EntityContact create(
            EntityId entityId,
            String contactName,
            String phone,
            String email,
            boolean isPrimary,
            String createdBy) {

        return new EntityContact(
            EntityContactId.generate(),
            entityId,
            contactName.trim(),
            phone != null ? phone.trim() : null,
            email != null ? email.trim() : null,
            isPrimary,
            "ACTIVE",
            createdBy
        );
    }

    public void updateContactInfo(
            String contactName,
            String phone,
            String email,
            String updatedBy) {

        this.contactName = contactName.trim();
        this.phone = phone != null ? phone.trim() : null;
        this.email = email != null ? email.trim() : null;
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
    }

    public void setPrimary(boolean isPrimary) {
        this.isPrimary = isPrimary;
        this.updatedAt = Instant.now();
    }

    // Getters
    public EntityContactId getId() { return id; }
    public EntityId getEntityId() { return entityId; }
    public String getContactName() { return contactName; }
    public String getPhone() { return phone; }
    public String getEmail() { return email; }
    public boolean isPrimary() { return isPrimary; }
    public String getStatus() { return status; }
    public Instant getCreatedAt() { return createdAt; }
    public Instant getUpdatedAt() { return updatedAt; }
    public String getCreatedBy() { return createdBy; }
    public String getUpdatedBy() { return updatedBy; }
}
```

#### 3.1.3 Value Objects

```java
@Embeddable
public class EntityId {
    @Column(name = "id")
    private UUID value;

    public static EntityId generate() {
        return new EntityId(UUID.randomUUID());
    }

    public static EntityId of(UUID value) {
        return new EntityId(value);
    }

    public static EntityId of(String value) {
        return new EntityId(UUID.fromString(value));
    }

    public UUID getValue() { return value; }
}

@Embeddable
public class EntityContactId {
    @Column(name = "id")
    private UUID value;

    public static EntityContactId generate() {
        return new EntityContactId(UUID.randomUUID());
    }

    public static EntityContactId of(UUID value) {
        return new EntityContactId(value);
    }

    public static EntityContactId of(String value) {
        return new EntityContactId(UUID.fromString(value));
    }

    public UUID getValue() { return value; }
}
```

#### 3.1.4 Domain Services

```java
@Component
public class EntityType {
    private final OptionsRepository optionsRepository;

    public EntityType(OptionsRepository optionsRepository) {
        this.optionsRepository = optionsRepository;
    }

    public boolean isValidEntityType(String entityType) {
        if (entityType == null || entityType.trim().isEmpty()) {
            return false;
        }

        List<String> validTypes = Arrays.asList("DECISAO", "PARECER", "VISTORIA");
        return validTypes.contains(entityType.toUpperCase());
    }

    public List<String> getAvailableEntityTypes() {
        return optionsRepository.findByCcodeAndActiveTrue("ENTITY_TYPE")
                .stream()
                .map(option -> option.getCvalue())
                .collect(Collectors.toList());
    }
}
```

### 3.2 Application Layer

#### 3.2.1 Application Services

```java
@Service
@Transactional
public class EntityApplicationService {
    private final EntityRepository entityRepository;
    private final LicenseTypeRepository licenseTypeRepository;
    private final OrganizationService organizationService;
    private final EntityType entityTypeService;

    public EntityApplicationService(
            EntityRepository entityRepository,
            LicenseTypeRepository licenseTypeRepository,
            OrganizationService organizationService,
            EntityType entityTypeService) {
        this.entityRepository = entityRepository;
        this.licenseTypeRepository = licenseTypeRepository;
        this.organizationService = organizationService;
        this.entityTypeService = entityTypeService;
    }

    public EntityId createEntity(CreateEntityCommand command) {
        // Validar se o tipo de licença existe
        if (!licenseTypeRepository.existsById(command.getLicenseTypeId())) {
            throw new LicenseTypeNotFoundException(command.getLicenseTypeId());
        }

        // Buscar ou criar organização se fornecida
        OrganizationId organizationId = null;
        if (command.getOrganizationName() != null) {
            organizationId = organizationService.findOrCreateOrganization(command.getOrganizationName());
        }

        LicenseEntity entity = LicenseEntity.create(
            command.getLicenseTypeId(),
            command.getEntityName(),
            command.getEntityType(),
            organizationId,
            command.getCreatedBy(),
            entityTypeService
        );

        // Adicionar contatos se fornecidos
        if (command.getContacts() != null && !command.getContacts().isEmpty()) {
            for (CreateContactCommand contactCommand : command.getContacts()) {
                entity.addContact(
                    contactCommand.getContactName(),
                    contactCommand.getPhone(),
                    contactCommand.getEmail(),
                    contactCommand.isPrimary(),
                    command.getCreatedBy()
                );
            }
        }

        entityRepository.save(entity);
        return entity.getId();
    }

    public void updateEntity(UpdateEntityCommand command) {
        LicenseEntity entity = entityRepository.findById(command.getEntityId())
                .orElseThrow(() -> new EntityNotFoundException(command.getEntityId()));

        // Buscar ou criar organização se fornecida
        OrganizationId organizationId = null;
        if (command.getOrganizationName() != null) {
            organizationId = organizationService.findOrCreateOrganization(command.getOrganizationName());
        }

        entity.updateEntityInfo(
            command.getEntityName(),
            command.getEntityType(),
            organizationId,
            command.getUpdatedBy(),
            entityTypeService
        );

        entityRepository.save(entity);
    }

    public void addEntityContact(AddEntityContactCommand command) {
        LicenseEntity entity = entityRepository.findById(command.getEntityId())
                .orElseThrow(() -> new EntityNotFoundException(command.getEntityId()));

        entity.addContact(
            command.getContactName(),
            command.getPhone(),
            command.getEmail(),
            command.isPrimary(),
            command.getCreatedBy()
        );

        entityRepository.save(entity);
    }

    public void removeEntityContact(RemoveEntityContactCommand command) {
        LicenseEntity entity = entityRepository.findById(command.getEntityId())
                .orElseThrow(() -> new EntityNotFoundException(command.getEntityId()));

        entity.removeContact(command.getContactId(), command.getUpdatedBy());
        entityRepository.save(entity);
    }

    public void deleteEntity(DeleteEntityCommand command) {
        LicenseEntity entity = entityRepository.findById(command.getEntityId())
                .orElseThrow(() -> new EntityNotFoundException(command.getEntityId()));

        entity.deactivate(command.getUpdatedBy());
        entityRepository.save(entity);
    }

    public void deleteEntities(DeleteEntitiesCommand command) {
        List<LicenseEntity> entities = entityRepository.findAllById(command.getEntityIds());

        if (entities.size() != command.getEntityIds().size()) {
            throw new IllegalArgumentException("Some entities were not found");
        }

        entities.forEach(entity -> entity.deactivate(command.getUpdatedBy()));
        entityRepository.saveAll(entities);
    }

    @Transactional(readOnly = true)
    public EntityDetailResponse getEntityDetail(EntityId entityId) {
        LicenseEntity entity = entityRepository.findById(entityId)
                .orElseThrow(() -> new EntityNotFoundException(entityId));

        return EntityDetailResponse.from(entity);
    }

    @Transactional(readOnly = true)
    public PagedResult<EntityListResponse> searchEntities(SearchEntitiesQuery query) {
        return entityRepository.searchEntities(query);
    }
}
```

#### 3.2.2 Commands

```java
public class CreateEntityCommand {
    private final LicenseTypeId licenseTypeId;
    private final String entityName;
    private final String entityType;
    private final String organizationName;
    private final List<CreateContactCommand> contacts;
    private final String createdBy;

    // Constructor, getters
}

public class CreateContactCommand {
    private final String contactName;
    private final String phone;
    private final String email;
    private final boolean isPrimary;

    // Constructor, getters
}

public class UpdateEntityCommand {
    private final EntityId entityId;
    private final String entityName;
    private final String entityType;
    private final String organizationName;
    private final String updatedBy;

    // Constructor, getters
}

public class AddEntityContactCommand {
    private final EntityId entityId;
    private final String contactName;
    private final String phone;
    private final String email;
    private final boolean isPrimary;
    private final String createdBy;

    // Constructor, getters
}

public class RemoveEntityContactCommand {
    private final EntityId entityId;
    private final EntityContactId contactId;
    private final String updatedBy;

    // Constructor, getters
}

public class DeleteEntityCommand {
    private final EntityId entityId;
    private final String updatedBy;

    // Constructor, getters
}

public class DeleteEntitiesCommand {
    private final List<EntityId> entityIds;
    private final String updatedBy;

    // Constructor, getters
}
```

#### 3.2.3 Queries

```java
public class SearchEntitiesQuery {
    private final LicenseTypeId licenseTypeId;
    private final String entityType;
    private final String entityName;
    private final String status;
    private final int page;
    private final int size;
    private final String sortBy;
    private final String sortDirection;

    // Constructor, getters
}
```

#### 3.2.4 Response DTOs

```java
public class EntityListResponse {
    private final EntityId id;
    private final String entityName;
    private final String entityType;
    private final String organizationName;
    private final int contactCount;
    private final String status;
    private final Instant createdAt;
    private final String createdBy;

    public static EntityListResponse from(LicenseEntity entity, String organizationName) {
        return new EntityListResponse(
            entity.getId(),
            entity.getEntityName(),
            entity.getEntityType(),
            organizationName,
            entity.getContacts().size(),
            entity.getStatus(),
            entity.getCreatedAt(),
            entity.getCreatedBy()
        );
    }

    // Getters
}

public class EntityDetailResponse {
    private final EntityId id;
    private final LicenseTypeId licenseTypeId;
    private final String licenseTypeName;
    private final String entityName;
    private final String entityType;
    private final String organizationName;
    private final List<EntityContactResponse> contacts;
    private final String status;
    private final Instant createdAt;
    private final Instant updatedAt;
    private final String createdBy;
    private final String updatedBy;

    public static EntityDetailResponse from(LicenseEntity entity) {
        List<EntityContactResponse> contacts = entity.getContacts().stream()
                .map(EntityContactResponse::from)
                .collect(Collectors.toList());

        return new EntityDetailResponse(
            entity.getId(),
            entity.getLicenseTypeId(),
            null, // será preenchido pelo service
            entity.getEntityName(),
            entity.getEntityType(),
            null, // será preenchido pelo service
            contacts,
            entity.getStatus(),
            entity.getCreatedAt(),
            entity.getUpdatedAt(),
            entity.getCreatedBy(),
            entity.getUpdatedBy()
        );
    }

    // Getters
}

public class EntityContactResponse {
    private final EntityContactId id;
    private final String contactName;
    private final String phone;
    private final String email;
    private final boolean isPrimary;
    private final String status;

    public static EntityContactResponse from(EntityContact contact) {
        return new EntityContactResponse(
            contact.getId(),
            contact.getContactName(),
            contact.getPhone(),
            contact.getEmail(),
            contact.isPrimary(),
            contact.getStatus()
        );
    }

    // Getters
}
```

### 3.3 Infrastructure Layer

#### 3.3.1 Repository Implementation

```java
@Repository
public class JpaEntityRepository implements EntityRepository {
    private final EntityJpaRepository jpaRepository;
    private final EntityQueryRepository queryRepository;

    public JpaEntityRepository(
            EntityJpaRepository jpaRepository,
            EntityQueryRepository queryRepository) {
        this.jpaRepository = jpaRepository;
        this.queryRepository = queryRepository;
    }

    @Override
    public void save(LicenseEntity entity) {
        jpaRepository.save(entity);
    }

    @Override
    public Optional<LicenseEntity> findById(EntityId id) {
        return jpaRepository.findById(id.getValue());
    }

    @Override
    public List<LicenseEntity> findAllById(List<EntityId> ids) {
        List<UUID> uuids = ids.stream()
                .map(EntityId::getValue)
                .collect(Collectors.toList());
        return jpaRepository.findAllById(uuids);
    }

    @Override
    public boolean existsById(EntityId id) {
        return jpaRepository.existsById(id.getValue());
    }

    @Override
    public PagedResult<EntityListResponse> searchEntities(SearchEntitiesQuery query) {
        return queryRepository.searchEntities(query);
    }

    @Override
    public void saveAll(List<LicenseEntity> entities) {
        jpaRepository.saveAll(entities);
    }
}

interface EntityJpaRepository extends JpaRepository<LicenseEntity, UUID> {
    List<LicenseEntity> findByLicenseTypeIdAndStatusOrderByEntityNameAsc(
            LicenseTypeId licenseTypeId, String status);

    List<LicenseEntity> findByEntityTypeAndStatusOrderByEntityNameAsc(
            String entityType, String status);

    @Query("SELECT e FROM LicenseEntity e WHERE e.entityName ILIKE %:name% AND e.status = :status")
    List<LicenseEntity> findByEntityNameContainingIgnoreCaseAndStatus(
            @Param("name") String name, @Param("status") String status);
}
```

#### 3.3.2 Query Repository

```java
@Repository
public class EntityQueryRepository {
    private final EntityManager entityManager;

    public EntityQueryRepository(EntityManager entityManager) {
        this.entityManager = entityManager;
    }

    public PagedResult<EntityListResponse> searchEntities(SearchEntitiesQuery query) {
        StringBuilder jpql = new StringBuilder(
            "SELECT e FROM LicenseEntity e WHERE e.status = 'ACTIVE'"
        );

        Map<String, Object> parameters = new HashMap<>();

        if (query.getLicenseTypeId() != null) {
            jpql.append(" AND e.licenseTypeId = :licenseTypeId");
            parameters.put("licenseTypeId", query.getLicenseTypeId());
        }

        if (query.getEntityType() != null && !query.getEntityType().trim().isEmpty()) {
            jpql.append(" AND e.entityType = :entityType");
            parameters.put("entityType", query.getEntityType());
        }

        if (query.getEntityName() != null && !query.getEntityName().trim().isEmpty()) {
            jpql.append(" AND LOWER(e.entityName) LIKE LOWER(:entityName)");
            parameters.put("entityName", "%" + query.getEntityName().trim() + "%");
        }

        if (query.getStatus() != null && !query.getStatus().trim().isEmpty()) {
            jpql.append(" AND e.status = :status");
            parameters.put("status", query.getStatus());
        }

        // Ordenação
        String sortBy = query.getSortBy() != null ? query.getSortBy() : "entityName";
        String sortDirection = "DESC".equalsIgnoreCase(query.getSortDirection()) ? "DESC" : "ASC";
        jpql.append(" ORDER BY e.").append(sortBy).append(" ").append(sortDirection);

        // Query para contagem
        String countJpql = jpql.toString().replace("SELECT e FROM", "SELECT COUNT(e) FROM")
                .replaceAll("ORDER BY.*", "");

        TypedQuery<Long> countQuery = entityManager.createQuery(countJpql, Long.class);
        parameters.forEach(countQuery::setParameter);
        long totalElements = countQuery.getSingleResult();

        // Query para dados
        TypedQuery<LicenseEntity> dataQuery = entityManager.createQuery(jpql.toString(), LicenseEntity.class);
        parameters.forEach(dataQuery::setParameter);
        dataQuery.setFirstResult(query.getPage() * query.getSize());
        dataQuery.setMaxResults(query.getSize());

        List<LicenseEntity> entities = dataQuery.getResultList();
        List<EntityListResponse> responses = entities.stream()
                .map(entity -> EntityListResponse.from(entity, getOrganizationName(entity.getOrganizationId())))
                .collect(Collectors.toList());

        return new PagedResult<>(
            responses,
            query.getPage(),
            query.getSize(),
            totalElements
        );
    }

    private String getOrganizationName(OrganizationId organizationId) {
        if (organizationId == null) {
            return null;
        }

        // Implementar busca do nome da organização
        // Pode ser através de um service ou query direta
        return "Organization Name"; // Placeholder
    }
}
```

## 4. Documentação da API REST

### 4.1 Endpoints Disponíveis

#### Base URL

```
http://localhost:8080/api/v1
```

### 4.2 Lista de Entidades

**Endpoint:** `GET /entities`

**Descrição:** Retorna lista paginada de entidades com filtros opcionais

**Parâmetros de Query:**

- `licenseTypeId` (UUID, opcional): ID do tipo de licença para filtrar

- `entityType` (string, opcional): Tipo de entidade (DECISAO, PARECER, VISTORIA)

- `status` (string, opcional): Status da entidade (ACTIVE, INACTIVE)

- `page` (integer, opcional): Número da página (0-based, padrão: 0)

- `size` (integer, opcional): Tamanho da página (1-100, padrão: 20)

- `sort` (string, opcional): Campo para ordenação (entityName, createdAt, updatedAt)

- `direction` (string, opcional): Direção da ordenação (ASC, DESC)

**Exemplo de Request:**

```http
GET /api/v1/entities?licenseTypeId=123e4567-e89b-12d3-a456-426614174000&entityType=DECISAO&page=0&size=10&sort=entityName&direction=ASC
Content-Type: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Exemplo de Response (200 OK):**

```json
{
  "content": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "licenseTypeId": "123e4567-e89b-12d3-a456-426614174000",
      "organizationId": "789e4567-e89b-12d3-a456-426614174000",
      "entityName": "Câmara Municipal de Praia",
      "entityType": "DECISAO",
      "status": "ACTIVE",
      "contacts": [
        {
          "id": "660e8400-e29b-41d4-a716-446655440000",
          "contactName": "João Silva",
          "phone": "+238 260 1234",
          "email": "joao.silva@cmpraia.cv",
          "isPrimary": true,
          "status": "ACTIVE"
        }
      ],
      "createdAt": "2024-01-15T10:30:00Z",
      "updatedAt": "2024-01-15T10:30:00Z",
      "createdBy": "admin",
      "updatedBy": "admin"
    }
  ],
  "pageable": {
    "sort": {
      "sorted": true,
      "unsorted": false,
      "empty": false
    },
    "pageNumber": 0,
    "pageSize": 10,
    "offset": 0,
    "paged": true,
    "unpaged": false
  },
  "totalElements": 25,
  "totalPages": 3,
  "last": false,
  "first": true,
  "numberOfElements": 10,
  "size": 10,
  "number": 0,
  "sort": {
    "sorted": true,
    "unsorted": false,
    "empty": false
  },
  "empty": false
}
```

### 4.3 Buscar Entidade por ID

**Endpoint:** `GET /entities/{id}`

**Descrição:** Retorna detalhes de uma entidade específica

**Parâmetros de Path:**

- `id` (UUID, obrigatório): ID da entidade

**Exemplo de Request:**

```http
GET /api/v1/entities/550e8400-e29b-41d4-a716-446655440000
Content-Type: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Exemplo de Response (200 OK):**

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "licenseTypeId": "123e4567-e89b-12d3-a456-426614174000",
  "organizationId": "789e4567-e89b-12d3-a456-426614174000",
  "entityName": "Câmara Municipal de Praia",
  "entityType": "DECISAO",
  "status": "ACTIVE",
  "contacts": [
    {
      "id": "660e8400-e29b-41d4-a716-446655440000",
      "contactName": "João Silva",
      "phone": "+238 260 1234",
      "email": "joao.silva@cmpraia.cv",
      "isPrimary": true,
      "status": "ACTIVE"
    },
    {
      "id": "660e8400-e29b-41d4-a716-446655440003",
      "contactName": "Ana Rodrigues",
      "phone": "+238 260 4567",
      "email": "ana.rodrigues@cmpraia.cv",
      "isPrimary": false,
      "status": "ACTIVE"
    }
  ],
  "createdAt": "2024-01-15T10:30:00Z",
  "updatedAt": "2024-01-15T10:30:00Z",
  "createdBy": "admin",
  "updatedBy": "admin"
}
```

### 4.4 Criar Nova Entidade

**Endpoint:** `POST /entities`

**Descrição:** Cria uma nova entidade no sistema

**Exemplo de Request:**

```http
POST /api/v1/entities
Content-Type: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

{
  "licenseTypeId": "123e4567-e89b-12d3-a456-426614174000",
  "organizationId": "789e4567-e89b-12d3-a456-426614174000",
  "entityName": "Instituto Nacional de Meteorologia",
  "entityType": "PARECER",
  "contacts": [
    {
      "contactName": "Carlos Mendes",
      "phone": "+238 260 7890",
      "email": "carlos.mendes@inmg.cv",
      "isPrimary": true
    }
  ]
}
```

**Exemplo de Response (201 Created):**

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440010",
  "licenseTypeId": "123e4567-e89b-12d3-a456-426614174000",
  "organizationId": "789e4567-e89b-12d3-a456-426614174000",
  "entityName": "Instituto Nacional de Meteorologia",
  "entityType": "PARECER",
  "status": "ACTIVE",
  "contacts": [
    {
      "id": "660e8400-e29b-41d4-a716-446655440010",
      "contactName": "Carlos Mendes",
      "phone": "+238 260 7890",
      "email": "carlos.mendes@inmg.cv",
      "isPrimary": true,
      "status": "ACTIVE"
    }
  ],
  "createdAt": "2024-01-22T16:45:00Z",
  "updatedAt": "2024-01-22T16:45:00Z",
  "createdBy": "user456",
  "updatedBy": "user456"
}
```

### 4.5 Atualizar Entidade

**Endpoint:** `PUT /entities/{id}`

**Descrição:** Atualiza uma entidade existente

**Parâmetros de Path:**

- `id` (UUID, obrigatório): ID da entidade

**Exemplo de Request:**

```http
PUT /api/v1/entities/550e8400-e29b-41d4-a716-446655440000
Content-Type: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

{
  "organizationId": "789e4567-e89b-12d3-a456-426614174000",
  "entityName": "Câmara Municipal da Praia - Atualizada",
  "entityType": "DECISAO",
  "status": "ACTIVE",
  "contacts": [
    {
      "id": "660e8400-e29b-41d4-a716-446655440000",
      "contactName": "João Silva Santos",
      "phone": "+238 260 1234",
      "email": "joao.silva@cmpraia.cv",
      "isPrimary": true,
      "status": "ACTIVE"
    }
  ]
}
```

**Exemplo de Response (200 OK):**

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "licenseTypeId": "123e4567-e89b-12d3-a456-426614174000",
  "organizationId": "789e4567-e89b-12d3-a456-426614174000",
  "entityName": "Câmara Municipal da Praia - Atualizada",
  "entityType": "DECISAO",
  "status": "ACTIVE",
  "contacts": [
    {
      "id": "660e8400-e29b-41d4-a716-446655440000",
      "contactName": "João Silva Santos",
      "phone": "+238 260 1234",
      "email": "joao.silva@cmpraia.cv",
      "isPrimary": true,
      "status": "ACTIVE"
    }
  ],
  "createdAt": "2024-01-15T10:30:00Z",
  "updatedAt": "2024-01-23T11:20:00Z",
  "createdBy": "admin",
  "updatedBy": "user789"
}
```

### 4.6 Remover Entidade

**Endpoint:** `DELETE /entities/{id}`

**Descrição:** Remove uma entidade do sistema (soft delete)

**Parâmetros de Path:**

- `id` (UUID, obrigatório): ID da entidade

**Exemplo de Request:**

```http
DELETE /api/v1/entities/550e8400-e29b-41d4-a716-446655440000
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Exemplo de Response (204 No Content):**

```http
HTTP/1.1 204 No Content
Date: Mon, 23 Jan 2024 12:00:00 GMT
Server: Apache/2.4.41
```

### 4.7 Códigos de Status HTTP

| Código | Descrição             | Quando Usar                                         |
| ------ | --------------------- | --------------------------------------------------- |
| 200    | OK                    | Operação realizada com sucesso (GET, PUT)           |
| 201    | Created               | Recurso criado com sucesso (POST)                   |
| 204    | No Content            | Recurso removido com sucesso (DELETE)               |
| 400    | Bad Request           | Dados de entrada inválidos ou parâmetros incorretos |
| 401    | Unauthorized          | Token de autenticação ausente ou inválido           |
| 403    | Forbidden             | Usuário não tem permissão para acessar o recurso    |
| 404    | Not Found             | Recurso não encontrado                              |
| 409    | Conflict              | Conflito de dados (ex: entidade já existe)          |
| 500    | Internal Server Error | Erro interno do servidor                            |

### 4.8 Headers Obrigatórios

**Para todas as requisições:**

- `Content-Type: application/json`

- `Authorization: Bearer {token}`

**Para respostas:**

- `Content-Type: application/json`

- `X-Request-ID: {uuid}` (para rastreamento)

### 4.9 Controller Implementation

```java
@RestController
@RequestMapping("/api/v1/entities")
@Validated
public class EntityController {
    private final EntityApplicationService entityService;

    public EntityController(EntityApplicationService entityService) {
        this.entityService = entityService;
    }

    @GetMapping
    public ResponseEntity<PagedResponse<EntityListResponse>> searchEntities(
            @RequestParam(required = false) String licenseTypeId,
            @RequestParam(required = false) String entityType,
            @RequestParam(required = false) String entityName,
            @RequestParam(required = false) String status,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(defaultValue = "entityName") String sortBy,
            @RequestParam(defaultValue = "ASC") String sortDirection) {

        SearchEntitiesQuery query = new SearchEntitiesQuery(
            licenseTypeId != null ? LicenseTypeId.of(licenseTypeId) : null,
            entityType,
            entityName,
            status,
            page,
            size,
            sortBy,
            sortDirection
        );

        PagedResult<EntityListResponse> result = entityService.searchEntities(query);
        return ResponseEntity.ok(PagedResponse.from(result));
    }

    @GetMapping("/{id}")
    public ResponseEntity<EntityDetailResponse> getEntityDetail(
            @PathVariable String id) {

        EntityDetailResponse response = entityService.getEntityDetail(EntityId.of(id));
        return ResponseEntity.ok(response);
    }

    @PostMapping
    public ResponseEntity<CreateEntityResponse> createEntity(
            @Valid @RequestBody CreateEntityRequest request,
            Authentication authentication) {

        CreateEntityCommand command = new CreateEntityCommand(
            LicenseTypeId.of(request.getLicenseTypeId()),
            request.getEntityName(),
            request.getEntityType(),
            request.getOrganizationName(),
            request.getContacts().stream()
                    .map(c -> new CreateContactCommand(
                        c.getContactName(),
                        c.getPhone(),
                        c.getEmail(),
                        c.isPrimary()))
                    .collect(Collectors.toList()),
            authentication.getName()
        );

        EntityId entityId = entityService.createEntity(command);

        CreateEntityResponse response = new CreateEntityResponse(entityId.getValue().toString());
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @PutMapping("/{id}")
    public ResponseEntity<Void> updateEntity(
            @PathVariable String id,
            @Valid @RequestBody UpdateEntityRequest request,
            Authentication authentication) {

        UpdateEntityCommand command = new UpdateEntityCommand(
            EntityId.of(id),
            request.getEntityName(),
            request.getEntityType(),
            request.getOrganizationName(),
            authentication.getName()
        );

        entityService.updateEntity(command);
        return ResponseEntity.ok().build();
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteEntity(
            @PathVariable String id,
            Authentication authentication) {

        DeleteEntityCommand command = new DeleteEntityCommand(
            EntityId.of(id),
            authentication.getName()
        );

        entityService.deleteEntity(command);
        return ResponseEntity.ok().build();
    }
}
```

### 4.2 Request/Response DTOs

```java
public class CreateEntityRequest {
    @NotBlank(message = "License type ID is required")
    private String licenseTypeId;

    @NotBlank(message = "Entity name is required")
    @Size(max = 255, message = "Entity name cannot exceed 255 characters")
    private String entityName;

    @NotBlank(message = "Entity type is required")
    private String entityType;

    private String organizationName;

>>>>>>> parent of 2bd9194 (refactor(database): standardize timestamp column names to created_date and last_modified_date)
    @Valid
    private ContactInfoDTO contactInfo;
    
    @Valid
    private AddressDTO address;
    
    private String jurisdictionKey;  // Referência para OPTIONS com ccode="JURISDICTION"
    
    @NotNull(message = "Status é obrigatório")
    @NotBlank(message = "Status não pode estar vazio")
    private String statusKey;  // Referência para OPTIONS com ccode="ENTITY_STATUS"
    
    private List<String> competencyKeys;  // Referências para OPTIONS com ccode="COMPETENCY"
    
    private Object metadata;
}

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ContactInfoDTO {
    @Email(message = "Email deve ser válido")
    private String email;
    
    @Pattern(regexp = "^\\+?[0-9\\s\\-\\(\\)]+$", message = "Telefone deve ter formato válido")
    private String phone;
    
    @Pattern(regexp = "^\\+?[0-9\\s\\-\\(\\)]+$", message = "Fax deve ter formato válido")
    private String fax;
    
    @URL(message = "Website deve ser uma URL válida")
    private String website;
    
    private String contactPerson;
    
    private String department;
}

@Data
@NoArgsConstructor
@AllArgsConstructor
public class AddressDTO {
    @NotBlank(message = "Rua é obrigatória")
    private String street;
    
    private String number;
    
    private String complement;
    
    @NotBlank(message = "Cidade é obrigatória")
    private String city;
    
    private String district;
    
    @NotBlank(message = "Código postal é obrigatório")
    private String postalCode;
    
    @NotBlank(message = "País é obrigatório")
    private String country;
    
    private Double latitude;
    
    private Double longitude;
}
```

### 2.2 Associação Tipo de Licença - Entidade

#### 2.2.1 Campos da Associação
| Campo | Tipo | Validação | Descrição |
|-------|------|-----------|----------|
| licenseTypeId | String | NotBlank, Must exist | ID do tipo de licença |
| entityId | String | NotBlank, Must exist | ID da entidade |
| role | String | Must exist in OPTIONS | Papel da entidade |
| responsibility | String | Must exist in OPTIONS | Tipo de responsabilidade |
| isRequired | Boolean | NotNull | Se a participação é obrigatória |
| processingOrder | Integer | Min: 1 | Ordem no fluxo de processo |
| maxProcessingDays | Integer | Min: 1 | Prazo máximo para análise |
| canDelegate | Boolean | NotNull | Se pode delegar a análise |
| requiresPhysicalInspection | Boolean | NotNull | Se requer inspeção física |
| feeResponsible | Boolean | NotNull | Se é responsável por taxas |

#### 2.2.2 Estrutura do DTO de Associação
```java
<<<<<<< HEAD
@Data
@NoArgsConstructor
@AllArgsConstructor
@IgrpDTO
public class LicenseTypeEntityRequestDTO {
    @NotNull(message = "ID da entidade é obrigatório")
    @NotBlank(message = "ID da entidade não pode estar vazio")
    private String entityId;
    
    @NotNull(message = "Papel é obrigatório")
    @NotBlank(message = "Papel não pode estar vazio")
    private String roleKey;  // ANALYZER, APPROVER, INSPECTOR, CONSULTANT
    
    @NotNull(message = "Responsabilidade é obrigatória")
    @NotBlank(message = "Responsabilidade não pode estar vazia")
    private String responsibilityKey;  // PRIMARY, SECONDARY, SUPPORT
    
    @NotNull(message = "Campo 'obrigatório' é obrigatório")
    private Boolean isRequired;
    
    @Min(value = 1, message = "Ordem de processamento deve ser pelo menos 1")
    private Integer processingOrder;
    
    @Min(value = 1, message = "Prazo máximo deve ser pelo menos 1 dia")
    private Integer maxProcessingDays;
    
    @NotNull(message = "Campo 'pode delegar' é obrigatório")
    private Boolean canDelegate;
    
    @NotNull(message = "Campo 'requer inspeção física' é obrigatório")
    private Boolean requiresPhysicalInspection;
    
    @NotNull(message = "Campo 'responsável por taxa' é obrigatório")
    private Boolean feeResponsible;
    
    private String delegationCriteria;
    
    private String inspectionScope;
    
    private Object metadata;
=======
@OpenAPIDefinition(
    info = @Info(
        title = "Entity Management API",
        version = "1.0",
        description = "API para gestão de entidades do sistema de licenciamento"
    )
)
@Tag(name = "Entities", description = "Operações relacionadas à gestão de entidades")
public class EntityApiDocumentation {

    @Operation(
        summary = "Listar entidades",
        description = "Retorna uma lista paginada de entidades com filtros opcionais"
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Lista de entidades retornada com sucesso"),
        @ApiResponse(responseCode = "400", description = "Parâmetros de consulta inválidos"),
        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    public ResponseEntity<PagedResponse<EntityListResponse>> searchEntities(
            @Parameter(description = "ID do tipo de licença para filtrar") String licenseTypeId,
            @Parameter(description = "Tipo de entidade (DECISAO, PARECER, VISTORIA)") String entityType,
            @Parameter(description = "Nome da entidade para busca parcial") String entityName,
            @Parameter(description = "Status da entidade") String status,
            @Parameter(description = "Número da página (0-based)") int page,
            @Parameter(description = "Tamanho da página") int size,
            @Parameter(description = "Campo para ordenação") String sortBy,
            @Parameter(description = "Direção da ordenação (ASC/DESC)") String sortDirection) {
        return null; // Implementação no controller
    }

    @Operation(
        summary = "Obter detalhes da entidade",
        description = "Retorna os detalhes completos de uma entidade específica"
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Detalhes da entidade retornados com sucesso"),
        @ApiResponse(responseCode = "404", description = "Entidade não encontrada"),
        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    public ResponseEntity<EntityDetailResponse> getEntityDetail(
            @Parameter(description = "ID da entidade", required = true) String id) {
        return null; // Implementação no controller
    }

    @Operation(
        summary = "Criar nova entidade",
        description = "Cria uma nova entidade no sistema"
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "201", description = "Entidade criada com sucesso"),
        @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos"),
        @ApiResponse(responseCode = "409", description = "Conflito - entidade já existe"),
        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    public ResponseEntity<CreateEntityResponse> createEntity(
            @Parameter(description = "Dados da nova entidade", required = true) CreateEntityRequest request) {
        return null; // Implementação no controller
    }

    @Operation(
        summary = "Atualizar entidade",
        description = "Atualiza os dados de uma entidade existente"
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Entidade atualizada com sucesso"),
        @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos"),
        @ApiResponse(responseCode = "404", description = "Entidade não encontrada"),
        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    public ResponseEntity<Void> updateEntity(
            @Parameter(description = "ID da entidade", required = true) String id,
            @Parameter(description = "Dados atualizados da entidade", required = true) UpdateEntityRequest request) {
        return null; // Implementação no controller
    }

    @Operation(
        summary = "Adicionar contato à entidade",
        description = "Adiciona um novo contato a uma entidade existente"
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "201", description = "Contato adicionado com sucesso"),
        @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos"),
        @ApiResponse(responseCode = "404", description = "Entidade não encontrada"),
        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    public ResponseEntity<Void> addEntityContact(
            @Parameter(description = "ID da entidade", required = true) String id,
            @Parameter(description = "Dados do novo contato", required = true) AddEntityContactRequest request) {
        return null; // Implementação no controller
    }

    @Operation(
        summary = "Remover contato da entidade",
        description = "Remove um contato de uma entidade"
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Contato removido com sucesso"),
        @ApiResponse(responseCode = "404", description = "Entidade ou contato não encontrado"),
        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    public ResponseEntity<Void> removeEntityContact(
            @Parameter(description = "ID da entidade", required = true) String id,
            @Parameter(description = "ID do contato", required = true) String contactId) {
        return null; // Implementação no controller
    }

    @Operation(
        summary = "Excluir entidade",
        description = "Exclui (desativa) uma entidade do sistema"
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Entidade excluída com sucesso"),
        @ApiResponse(responseCode = "404", description = "Entidade não encontrada"),
        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    public ResponseEntity<Void> deleteEntity(
            @Parameter(description = "ID da entidade", required = true) String id) {
        return null; // Implementação no controller
    }

    @Operation(
        summary = "Excluir múltiplas entidades",
        description = "Exclui (desativa) múltiplas entidades do sistema"
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Entidades excluídas com sucesso"),
        @ApiResponse(responseCode = "400", description = "Lista de IDs inválida"),
        @ApiResponse(responseCode = "404", description = "Uma ou mais entidades não encontradas"),
        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    public ResponseEntity<Void> deleteEntities(
            @Parameter(description = "Lista de IDs das entidades", required = true) DeleteEntitiesRequest request) {
        return null; // Implementação no controller
    }
}
```

## 5. Testes

### 5.1 Testes Unitários

```java
@ExtendWith(MockitoExtension.class)
class LicenseEntityTest {

    @Mock
    private EntityType entityTypeService;

    @BeforeEach
    void setUp() {
        // Criar tipo de licença para testes
        LicenseType licenseType = new LicenseType();
        licenseType.setName("Tipo Teste");
        licenseType.setDescription("Descrição teste");
        licenseType.setActive(true);
        testEntityManager.persistAndFlush(licenseType);
        licenseTypeId = licenseType.getId();
    }

    @Test
    void shouldCreateEntitySuccessfully() {
        // Given
        List<CreateContactCommand> contacts = Arrays.asList(
            new CreateContactCommand("João Silva", "123456789", "joao@test.com", true)
        );

        CreateEntityCommand command = new CreateEntityCommand(
            licenseTypeId,
            "Entidade Teste",
            "DECISAO",
            "Organização Teste",
            contacts,
            "user@test.com"
        );

        // When
        EntityId entityId = entityService.createEntity(command);

        // Then
        assertThat(entityId).isNotNull();

        Optional<LicenseEntity> savedEntity = entityRepository.findById(entityId);
        assertThat(savedEntity).isPresent();
        assertThat(savedEntity.get().getEntityName()).isEqualTo("Entidade Teste");
        assertThat(savedEntity.get().getEntityType()).isEqualTo("DECISAO");
        assertThat(savedEntity.get().getContacts()).hasSize(1);
    }

    @Test
    void shouldSearchEntitiesWithFilters() {
        // Given
        createTestEntity("Entidade A", "DECISAO");
        createTestEntity("Entidade B", "PARECER");
        createTestEntity("Entidade C", "DECISAO");

        SearchEntitiesQuery query = new SearchEntitiesQuery(
            licenseTypeId,
            "DECISAO",
            null,
            "ACTIVE",
            0,
            10,
            "entityName",
            "ASC"
        );

        // When
        PagedResult<EntityListResponse> result = entityService.searchEntities(query);

        // Then
        assertThat(result.getContent()).hasSize(2);
        assertThat(result.getTotalElements()).isEqualTo(2);
        assertThat(result.getContent().get(0).getEntityName()).isEqualTo("Entidade A");
        assertThat(result.getContent().get(1).getEntityName()).isEqualTo("Entidade C");
    }

    @Test
    void shouldUpdateEntitySuccessfully() {
        // Given
        EntityId entityId = createTestEntity("Entidade Original", "DECISAO");

        UpdateEntityCommand command = new UpdateEntityCommand(
            entityId,
            "Entidade Atualizada",
            "PARECER",
            "Nova Organização",
            "admin@test.com"
        );

        // When
        entityService.updateEntity(command);

        // Then
        Optional<LicenseEntity> updatedEntity = entityRepository.findById(entityId);
        assertThat(updatedEntity).isPresent();
        assertThat(updatedEntity.get().getEntityName()).isEqualTo("Entidade Atualizada");
        assertThat(updatedEntity.get().getEntityType()).isEqualTo("PARECER");
        assertThat(updatedEntity.get().getUpdatedBy()).isEqualTo("admin@test.com");
    }

    @Test
    void shouldDeleteEntitySuccessfully() {
        // Given
        EntityId entityId = createTestEntity("Entidade Para Deletar", "DECISAO");

        DeleteEntityCommand command = new DeleteEntityCommand(
            entityId,
            "admin@test.com"
        );

        // When
        entityService.deleteEntity(command);

        // Then
        Optional<LicenseEntity> deletedEntity = entityRepository.findById(entityId);
        assertThat(deletedEntity).isPresent();
        assertThat(deletedEntity.get().getStatus()).isEqualTo("INACTIVE");
    }

    private EntityId createTestEntity(String name, String type) {
        CreateEntityCommand command = new CreateEntityCommand(
            licenseTypeId,
            name,
            type,
            null,
            Collections.emptyList(),
            "test@test.com"
        );
        return entityService.createEntity(command);
    }
}
```

### 5.3 Testes de API

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@Transactional
class EntityControllerIntegrationTest {

    @Autowired
    private TestRestTemplate restTemplate;

    @Autowired
    private EntityRepository entityRepository;

    @Autowired
    private LicenseTypeRepository licenseTypeRepository;

    @LocalServerPort
    private int port;

    private String baseUrl;
    private LicenseTypeId licenseTypeId;

    @BeforeEach
    void setUp() {
        baseUrl = "http://localhost:" + port + "/api/v1/entities";

        // Criar tipo de licença para testes
        LicenseType licenseType = new LicenseType();
        licenseType.setName("Tipo Teste API");
        licenseType.setDescription("Descrição teste API");
        licenseType.setActive(true);
        licenseTypeRepository.save(licenseType);
        licenseTypeId = licenseType.getId();
    }

    @Test
    void shouldCreateEntityViaAPI() {
        // Given
        CreateEntityRequest request = new CreateEntityRequest();
        request.setLicenseTypeId(licenseTypeId.getValue().toString());
        request.setEntityName("Entidade API Teste");
        request.setEntityType("DECISAO");
        request.setOrganizationName("Organização API");

        CreateContactRequest contact = new CreateContactRequest();
        contact.setContactName("João API");
        contact.setPhone("987654321");
        contact.setEmail("joao.api@test.com");
        contact.setPrimary(true);
        request.setContacts(Arrays.asList(contact));

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        HttpEntity<CreateEntityRequest> entity = new HttpEntity<>(request, headers);

        // When
        ResponseEntity<CreateEntityResponse> response = restTemplate.postForEntity(
            baseUrl, entity, CreateEntityResponse.class);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().getId()).isNotNull();
    }

    @Test
    void shouldGetEntityListViaAPI() {
        // Given
        createTestEntityViaService("Entidade Lista 1", "DECISAO");
        createTestEntityViaService("Entidade Lista 2", "PARECER");

        // When
        ResponseEntity<String> response = restTemplate.getForEntity(
            baseUrl + "?licenseTypeId=" + licenseTypeId.getValue(), String.class);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody()).contains("Entidade Lista 1");
        assertThat(response.getBody()).contains("Entidade Lista 2");
    }

    @Test
    void shouldGetEntityDetailViaAPI() {
        // Given
        EntityId entityId = createTestEntityViaService("Entidade Detalhe", "VISTORIA");

        // When
        ResponseEntity<EntityDetailResponse> response = restTemplate.getForEntity(
            baseUrl + "/" + entityId.getValue(), EntityDetailResponse.class);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().getEntityName()).isEqualTo("Entidade Detalhe");
        assertThat(response.getBody().getEntityType()).isEqualTo("VISTORIA");
    }

    @Test
    void shouldReturnNotFoundForInvalidEntityId() {
        // Given
        String invalidId = UUID.randomUUID().toString();

        // When
        ResponseEntity<String> response = restTemplate.getForEntity(
            baseUrl + "/" + invalidId, String.class);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
    }

    @Test
    void shouldValidateRequiredFieldsOnCreate() {
        // Given
        CreateEntityRequest request = new CreateEntityRequest();
        // Não definir campos obrigatórios

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        HttpEntity<CreateEntityRequest> entity = new HttpEntity<>(request, headers);

        // When
        ResponseEntity<String> response = restTemplate.postForEntity(
            baseUrl, entity, String.class);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
    }

    private EntityId createTestEntityViaService(String name, String type) {
        CreateEntityCommand command = new CreateEntityCommand(
            licenseTypeId,
            name,
            type,
            null,
            Collections.emptyList(),
            "test@test.com"
        );

        EntityApplicationService service = new EntityApplicationService(
            entityRepository, licenseTypeRepository, null, new EntityType(null));
        return service.createEntity(command);
    }
}
```

## 6. Scripts de Migração de Dados

### 6.1 Criação das Tabelas

```sql
-- V001__create_entity_tables.sql
CREATE TABLE t_entity (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    license_type_id_fk UUID NOT NULL,
    organization_id_fk UUID,
    entity_name VARCHAR(255) NOT NULL,
    entity_type VARCHAR(50) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100) NOT NULL,
    updated_by VARCHAR(100) NOT NULL,

    CONSTRAINT fk_entity_license_type
        FOREIGN KEY (license_type_id_fk) REFERENCES t_license_type(id) ON DELETE CASCADE,
    CONSTRAINT chk_entity_name_not_empty
        CHECK (LENGTH(TRIM(entity_name)) > 0),
    CONSTRAINT chk_entity_type_valid
        CHECK (entity_type IN ('DECISAO', 'PARECER', 'VISTORIA'))
);

CREATE TABLE t_entity_contact (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    entity_id_fk UUID NOT NULL,
    contact_name VARCHAR(255) NOT NULL,
    phone VARCHAR(20),
    email VARCHAR(255),
    is_primary BOOLEAN NOT NULL DEFAULT false,
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100) NOT NULL,
    updated_by VARCHAR(100) NOT NULL,

    CONSTRAINT fk_entity_contact_entity
        FOREIGN KEY (entity_id_fk) REFERENCES t_entity(id) ON DELETE CASCADE,
    CONSTRAINT chk_contact_name_not_empty
        CHECK (LENGTH(TRIM(contact_name)) > 0),
    CONSTRAINT chk_email_format
        CHECK (email IS NULL OR email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$')
);

-- Índices para performance
CREATE INDEX idx_entity_license_type ON t_entity(license_type_id_fk);
CREATE INDEX idx_entity_type ON t_entity(entity_type);
CREATE INDEX idx_entity_status ON t_entity(status) WHERE status = 'ACTIVE';
CREATE INDEX idx_entity_created_at ON t_entity(created_at DESC);
CREATE INDEX idx_entity_type_status ON t_entity(license_type_id_fk, entity_type, status);
CREATE INDEX idx_entity_name_search ON t_entity USING gin(to_tsvector('portuguese', entity_name));

CREATE INDEX idx_entity_contact_entity ON t_entity_contact(entity_id_fk);
CREATE INDEX idx_entity_contact_primary ON t_entity_contact(entity_id_fk, is_primary) WHERE is_primary = true;
CREATE INDEX idx_entity_contact_email ON t_entity_contact(email) WHERE email IS NOT NULL;
```

### 6.2 Dados Iniciais

```sql
-- V002__insert_entity_options.sql
INSERT INTO t_options (ccode, ckey, cvalue, locale, sort_order, active, description) VALUES
('ENTITY_TYPE', 'DECISAO', 'Decisão', 'pt', 1, true, 'Entidade responsável por decisões no processo de licenciamento'),
('ENTITY_TYPE', 'PARECER', 'Parecer', 'pt', 2, true, 'Entidade responsável por emitir pareceres técnicos'),
('ENTITY_TYPE', 'VISTORIA', 'Vistoria', 'pt', 3, true, 'Entidade responsável por realizar vistorias');
```

## 8. Documentação de API

### 8.1 Exemplos de Uso

#### Criar Nova Entidade

```bash
curl -X POST http://localhost:8080/api/v1/entities \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <token>" \
  -d '{
    "licenseTypeId": "123e4567-e89b-12d3-a456-426614174000",
    "entityName": "Câmara Municipal de Praia",
    "entityType": "DECISAO",
    "organizationName": "Câmara Municipal de Praia",
    "contacts": [
      {
        "contactName": "João Silva",
        "phone": "+238 260 1234",
        "email": "joao.silva@cmpraia.cv",
        "isPrimary": true
      }
    ]
  }'
```

#### Listar Entidades com Filtros

```bash
curl -X GET "http://localhost:8080/api/v1/entities?entityType=DECISAO&page=0&size=10" \
  -H "Authorization: Bearer <token>"
```

#### Obter Detalhes de uma Entidade

```bash
curl -X GET http://localhost:8080/api/v1/entities/123e4567-e89b-12d3-a456-426614174000 \
  -H "Authorization: Bearer <token>"
```

#### Atualizar Entidade

```bash
curl -X PUT http://localhost:8080/api/v1/entities/123e4567-e89b-12d3-a456-426614174000 \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <token>" \
  -d '{
    "entityName": "Câmara Municipal de Praia - Atualizada",
    "entityType": "DECISAO",
    "organizationName": "Câmara Municipal de Praia"
  }'
```

#### Adicionar Contato à Entidade

```bash
curl -X POST http://localhost:8080/api/v1/entities/123e4567-e89b-12d3-a456-426614174000/contacts \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <token>" \
  -d '{
    "contactName": "Maria Santos",
    "phone": "+238 260 5678",
    "email": "maria.santos@cmpraia.cv",
    "isPrimary": false
  }'
```

#### Excluir Entidade

```bash
curl -X DELETE http://localhost:8080/api/v1/entities/123e4567-e89b-12d3-a456-426614174000 \
  -H "Authorization: Bearer <token>"
```

#### Excluir Múltiplas Entidades

```bash
curl -X DELETE http://localhost:8080/api/v1/entities \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <token>" \
  -d '{
    "entityIds": [
      "123e4567-e89b-12d3-a456-426614174000",
      "123e4567-e89b-12d3-a456-426614174001"
    ]
  }'
```

### 8.2 Códigos de Resposta

| Código | Descrição             | Exemplo de Uso                             |
| ------ | --------------------- | ------------------------------------------ |
| 200    | OK                    | Operação realizada com sucesso             |
| 201    | Created               | Entidade criada com sucesso                |
| 400    | Bad Request           | Dados de entrada inválidos                 |
| 401    | Unauthorized          | Token de autenticação inválido             |
| 403    | Forbidden             | Usuário sem permissão                      |
| 404    | Not Found             | Entidade não encontrada                    |
| 409    | Conflict              | Conflito de dados (ex: entidade duplicada) |
| 422    | Unprocessable Entity  | Erro de validação de negócio               |
| 500    | Internal Server Error | Erro interno do servidor                   |

## 9. Considerações de Segurança

### 9.1 Autenticação e Autorização

```java
@Configuration
@EnableWebSecurity
public class EntitySecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/api/v1/entities/**").hasRole("ENTITY_MANAGER")
                .requestMatchers(HttpMethod.GET, "/api/v1/entities").hasRole("ENTITY_VIEWER")
                .requestMatchers(HttpMethod.POST, "/api/v1/entities").hasRole("ENTITY_CREATOR")
                .requestMatchers(HttpMethod.PUT, "/api/v1/entities/**").hasRole("ENTITY_EDITOR")
                .requestMatchers(HttpMethod.DELETE, "/api/v1/entities/**").hasRole("ENTITY_ADMIN")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2.jwt());

        return http.build();
    }
}
```

### 9.2 Validação de Entrada

```java
@Component
public class EntityInputValidator {

    public void validateEntityName(String entityName) {
        if (entityName == null || entityName.trim().isEmpty()) {
            throw new ValidationException("Entity name cannot be null or empty");
        }

        if (entityName.length() > 255) {
            throw new ValidationException("Entity name cannot exceed 255 characters");
        }

        // Verificar caracteres especiais perigosos
        if (entityName.matches(".*[<>\"'&].*")) {
            throw new ValidationException("Entity name contains invalid characters");
        }
    }

    public void validateEmail(String email) {
        if (email != null && !email.matches("^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$")) {
            throw new ValidationException("Invalid email format");
        }
    }

    public void validatePhone(String phone) {
        if (phone != null && !phone.matches("^\\+?[0-9\\s\\-\\(\\)]{7,20}$")) {
            throw new ValidationException("Invalid phone format");
        }
    }
}
```

## 10. Performance e Otimização

### 10.1 Cache Configuration

```java
@Configuration
@EnableCaching
public class EntityCacheConfig {

    @Bean
    public CacheManager cacheManager() {
        RedisCacheManager.Builder builder = RedisCacheManager
                .RedisCacheManagerBuilder
                .fromConnectionFactory(redisConnectionFactory())
                .cacheDefaults(cacheConfiguration());

        return builder.build();
    }

    private RedisCacheConfiguration cacheConfiguration() {
        return RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(30))
                .serializeKeysWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new GenericJackson2JsonRedisSerializer()));
    }

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        return new LettuceConnectionFactory(new RedisStandaloneConfiguration("localhost", 6379));
    }
}
```

### 10.2 Query Optimization

```java
@Repository
public class OptimizedEntityQueryRepository {

    @PersistenceContext
    private EntityManager entityManager;

    @Cacheable(value = "entity-search", key = "#query.hashCode()")
    public PagedResult<EntityListResponse> searchEntitiesOptimized(SearchEntitiesQuery query) {
        // Usar query nativa para melhor performance
        String sql = """
            SELECT e.id, e.entity_name, e.entity_type, e.status, e.created_at,
                   o.name as organization_name,
                   COUNT(c.id) as contact_count
            FROM t_entity e
            LEFT JOIN redglobal.glb_t_organization o ON e.organization_id_fk = o.id
            LEFT JOIN t_entity_contact c ON e.id = c.entity_id_fk AND c.status = 'ACTIVE'
            WHERE e.status = 'ACTIVE'
            """;

        // Adicionar filtros dinamicamente
        Map<String, Object> parameters = new HashMap<>();

        if (query.getLicenseTypeId() != null) {
            sql += " AND e.license_type_id_fk = :licenseTypeId";
            parameters.put("licenseTypeId", query.getLicenseTypeId().getValue());
        }

        if (query.getEntityType() != null) {
            sql += " AND e.entity_type = :entityType";
            parameters.put("entityType", query.getEntityType());
        }

        if (query.getEntityName() != null) {
            sql += " AND e.entity_name ILIKE :entityName";
            parameters.put("entityName", "%" + query.getEntityName() + "%");
        }

        sql += " GROUP BY e.id, e.entity_name, e.entity_type, e.status, e.created_at, o.name";
        sql += " ORDER BY e." + query.getSortBy() + " " + query.getSortDirection();

        Query nativeQuery = entityManager.createNativeQuery(sql);
        parameters.forEach(nativeQuery::setParameter);

        nativeQuery.setFirstResult(query.getPage() * query.getSize());
        nativeQuery.setMaxResults(query.getSize());

        @SuppressWarnings("unchecked")
        List<Object[]> results = nativeQuery.getResultList();

        // Converter resultados para DTOs
        List<EntityListResponse> responses = results.stream()
                .map(this::mapToEntityListResponse)
                .collect(Collectors.toList());

        // Query para contagem total
        String countSql = sql.replaceAll("SELECT.*GROUP BY.*ORDER BY.*", "SELECT COUNT(DISTINCT e.id)");
        Query countQuery = entityManager.createNativeQuery(countSql);
        parameters.forEach(countQuery::setParameter);
        long totalElements = ((Number) countQuery.getSingleResult()).longValue();

        return new PagedResult<>(responses, query.getPage(), query.getSize(), totalElements);
    }

    private EntityListResponse mapToEntityListResponse(Object[] row) {
        return new EntityListResponse(
            EntityId.of((UUID) row[0]),
            (String) row[1],
            (String) row[2],
            (String) row[5],
            ((Number) row[6]).intValue(),
            (String) row[3],
            ((Timestamp) row[4]).toInstant(),
            "system" // placeholder para created_by
        );
    }
>>>>>>> parent of 2bd9194 (refactor(database): standardize timestamp column names to created_date and last_modified_date)
}
```

---

## 3. API REST - Gestão de Entidades

### 3.1 Operações CRUD de Entidades

#### 3.1.1 Listagem de Entidades
**Endpoint:** `GET /api/v1/entities`

**Parâmetros de Query:**
| Parâmetro | Tipo | Obrigatório | Padrão | Descrição |
|-----------|------|-------------|--------|-----------|
| type | string | Não | - | Tipo de entidade para filtrar |
| level | string | Não | - | Nível administrativo |
| jurisdiction | string | Não | - | Âmbito de jurisdição |
| status | string | Não | ACTIVE | Status da entidade |
| competency | string | Não | - | Competência específica |
| name | string | Não | - | Nome da entidade ou termo de busca |
| acronym | string | Não | - | Sigla da entidade |
| pageNumber | string | Não | "0" | Número da página |
| pageSize | string | Não | "20" | Tamanho da página |
| sort | string | Não | "name" | Campo de ordenação |
| direction | string | Não | "ASC" | Direção da ordenação (ASC/DESC) |

**Resposta de Sucesso (200):**
```json
{
  "pageNumber": 0,
  "pageSize": 20,
  "totalElements": 45,
  "totalPages": 3,
  "content": [
    {
      "id": "ent-001",
      "name": "Câmara Municipal da Praia",
      "acronym": "CMP",
      "typeKey": "MUNICIPAL",
      "typeName": "Câmara Municipal",
      "levelKey": "LOCAL",
      "levelName": "Local",
      "parentEntity": {
        "id": "ent-gov-cv",
        "name": "Governo de Cabo Verde",
        "acronym": "GOV-CV"
      },
      "contactInfo": {
        "email": "licenciamento@cmp.cv",
        "phone": "+238 260 89 00",
        "website": "https://www.cmp.cv",
        "contactPerson": "João Silva",
        "department": "Departamento de Licenciamento"
      },
      "address": {
        "street": "Avenida Cidade de Lisboa",
        "number": "1",
        "city": "Praia",
        "district": "Plateau",
        "postalCode": "7600",
        "country": "Cabo Verde"
      },
      "jurisdictionKey": "PRAIA",
      "jurisdictionName": "Município da Praia",
      "statusKey": "ACTIVE",
      "statusName": "Ativa",
      "competencies": [
        {
          "key": "COMMERCIAL_LICENSING",
          "name": "Licenciamento Comercial"
        },
        {
          "key": "URBAN_PLANNING",
          "name": "Planeamento Urbano"
        }
      ],
      "associatedLicenseTypes": 25,
      "metadata": {
        "establishedYear": 1975,
        "mayor": "Francisco Carvalho",
        "population": 159050,
        "area": "102.6 km²"
      }
    }
  ]
}
```

#### 3.1.2 Busca de Entidade por ID
**Endpoint:** `GET /api/v1/entities/{entitiyId}`

**Parâmetros de Path:**
| Parâmetro | Tipo | Descrição |
|-----------|------|-----------|
| entitiyId | string | ID único da entidade |

#### 3.1.3 Detalhes de Entidade
**Endpoint:** `GET /api/v1/entities/{entityId}`

**Resposta de Sucesso (200):**
```json
{
  "id": "ent-001",
  "name": "Câmara Municipal da Praia",
  "acronym": "CMP",
  "type": {
    "key": "MUNICIPAL",
    "name": "Câmara Municipal",
    "description": "Órgão de administração local municipal"
  },
  "level": {
    "key": "LOCAL",
    "name": "Local",
    "description": "Nível de administração local"
  },
  "hierarchy": {
    "parent": {
      "id": "ent-gov-cv",
      "name": "Governo de Cabo Verde",
      "level": "NATIONAL"
    },
    "children": [
      {
        "id": "ent-001-urb",
        "name": "Departamento de Urbanismo - CMP",
        "level": "DEPARTMENTAL"
      }
    ]
  },
  "contactInfo": {
    "email": "licenciamento@cmp.cv",
    "phone": "+238 260 89 00",
    "fax": "+238 260 89 01",
    "website": "https://www.cmp.cv",
    "contactPerson": "João Silva",
    "department": "Departamento de Licenciamento"
  },
  "address": {
    "street": "Avenida Cidade de Lisboa",
    "number": "1",
    "city": "Praia",
    "district": "Plateau",
    "postalCode": "7600",
    "country": "Cabo Verde",
    "latitude": 14.9177,
    "longitude": -23.5092
  },
  "jurisdiction": {
    "key": "PRAIA",
    "name": "Município da Praia",
    "coverage": "Municipal",
    "boundaries": {
      "north": 15.0000,
      "south": 14.8500,
      "east": -23.4000,
      "west": -23.6000
    }
  },
  "competencies": [
    {
      "key": "COMMERCIAL_LICENSING",
      "name": "Licenciamento Comercial",
      "description": "Análise e aprovação de licenças comerciais",
      "scope": "Municipal"
    },
    {
      "key": "URBAN_PLANNING",
      "name": "Planeamento Urbano",
      "description": "Análise de conformidade urbanística",
      "scope": "Municipal"
    }
  ],
  "operationalInfo": {
    "workingHours": {
      "weekdays": "08:00-16:00",
      "saturday": "08:00-12:00",
      "sunday": "Fechado"
    },
    "processingCapacity": {
      "dailyApplications": 50,
      "monthlyApplications": 1000,
      "averageProcessingDays": 15
    },
    "staff": {
      "totalEmployees": 25,
      "licensingOfficers": 8,
      "inspectors": 5
    }
  },
  "associatedLicenseTypes": [
    {
      "licenseTypeId": "lt-001",
      "licenseTypeName": "Licença de Restaurante",
      "role": "APPROVER",
      "responsibility": "PRIMARY"
    }
  ],
  "statistics": {
    "totalProcessedApplications": 2500,
    "averageProcessingTime": 12.5,
    "approvalRate": 85.2,
    "currentWorkload": 45
  },
  "metadata": {
    "establishedYear": 1975,
    "mayor": "Francisco Carvalho",
    "population": 159050,
    "area": "102.6 km²",
    "budget": 2500000000.00,
    "lastAudit": "2023-12-15"
  }
}
```

#### 3.1.4 Atualização de Entidade
**Endpoint:** `PUT /api/v1/entities/{entitiyId}`

**Parâmetros de Path:**
| Parâmetro | Tipo | Descrição |
|-----------|------|-----------|
| entitiyId | string | ID único da entidade |

**Payload de Requisição:** (mesmo formato da criação)

**Códigos de Status:**
- 200: Entidade atualizada com sucesso
- 400: Dados inválidos
- 404: Entidade não encontrada
- 409: Nome ou acrônimo já existe
- 500: Erro interno do servidor

#### 3.1.5 Ativação de Entidade
**Endpoint:** `PATCH /api/v1/entities/{entitiyId}/activate`

**Parâmetros de Path:**
| Parâmetro | Tipo | Descrição |
|-----------|------|-----------|
| entitiyId | string | ID único da entidade |

**Resposta de Sucesso (200):**
```json
{
  "message": "Entidade ativada com sucesso",
  "entityId": "ent-001",
  "status": "ACTIVE"
}
```

#### 3.1.6 Criação de Entidade
**Endpoint:** `POST /api/v1/entities`

**Payload de Requisição:**
```json
{
  "name": "Inspeção Geral das Atividades Económicas",
  "acronym": "IGAE",
  "typeKey": "INSPECTION_AGENCY",
  "levelKey": "NATIONAL",
  "parentEntityId": "ent-gov-cv",
  "contactInfo": {
    "email": "info@igae.gov.cv",
    "phone": "+238 260 12 00",
    "website": "https://www.igae.gov.cv",
    "contactPerson": "Maria Santos",
    "department": "Departamento de Licenciamento"
  },
  "address": {
    "street": "Avenida Combatentes da Liberdade da Pátria",
    "number": "45",
    "city": "Praia",
    "district": "Plateau",
    "postalCode": "7600",
    "country": "Cabo Verde"
  },
  "jurisdictionKey": "NATIONAL",
  "statusKey": "ACTIVE",
  "competencyKeys": [
    "ECONOMIC_INSPECTION",
    "COMPLIANCE_MONITORING",
    "LICENSING_OVERSIGHT"
  ],
  "metadata": {
    "establishedYear": 2010,
    "director": "Carlos Mendes",
    "inspectorCount": 15,
    "regionalOffices": 4
  }
}
```

---

## 4. API REST - Associações Tipo de Licença - Entidade

### 4.1 Gestão de Associações

#### 4.1.1 Listar Entidades de um Tipo de Licença
**Endpoint:** `GET /api/v1/license-types/{licenseTypeId}/entities`

**Parâmetros de Query:**
```
?role=APPROVER
&responsibility=PRIMARY
&required=true
&processingOrder=1
&active=true
```

**Resposta de Sucesso (200):**
```json
{
  "licenseTypeId": "lt-001",
  "licenseTypeName": "Licença de Restaurante",
  "totalEntities": 5,
  "requiredEntities": 3,
  "optionalEntities": 2,
  "estimatedTotalProcessingDays": 30,
  "entities": [
    {
      "associationId": "lte-001",
      "entity": {
        "id": "ent-001",
        "name": "Câmara Municipal da Praia",
        "acronym": "CMP",
        "type": "MUNICIPAL",
        "level": "LOCAL"
      },
      "role": {
        "key": "APPROVER",
        "name": "Aprovador",
        "description": "Entidade responsável pela aprovação final"
      },
      "responsibility": {
        "key": "PRIMARY",
        "name": "Primária",
        "description": "Responsabilidade principal no processo"
      },
      "isRequired": true,
      "processingOrder": 1,
      "maxProcessingDays": 15,
      "canDelegate": false,
      "requiresPhysicalInspection": true,
      "feeResponsible": true,
      "delegationCriteria": null,
      "inspectionScope": "Conformidade urbanística e segurança",
      "currentWorkload": {
        "pendingApplications": 25,
        "averageProcessingTime": 12,
        "capacity": "NORMAL"
      }
    },
    {
      "associationId": "lte-002",
      "entity": {
        "id": "ent-002",
        "name": "Delegacia de Saúde da Praia",
        "acronym": "DSP",
        "type": "HEALTH_AUTHORITY",
        "level": "LOCAL"
      },
      "role": {
        "key": "INSPECTOR",
        "name": "Inspetor",
        "description": "Entidade responsável pela inspeção técnica"
      },
      "responsibility": {
        "key": "SECONDARY",
        "name": "Secundária",
        "description": "Responsabilidade de apoio especializado"
      },
      "isRequired": true,
      "processingOrder": 2,
      "maxProcessingDays": 10,
      "canDelegate": true,
      "requiresPhysicalInspection": true,
      "feeResponsible": false,
      "delegationCriteria": "Pode delegar para técnicos certificados",
      "inspectionScope": "Segurança alimentar e condições sanitárias",
      "specialRequirements": [
        "Certificação HACCP",
        "Análise microbiológica",
        "Verificação de equipamentos"
      ]
    }
  ],
  "processFlow": {
    "sequential": true,
    "parallelSteps": [],
    "criticalPath": [
      "CMP - Análise urbanística",
      "DSP - Inspeção sanitária",
      "CMP - Aprovação final"
    ]
  }
}
```

#### 4.1.2 Associar Entidade a Tipo de Licença
**Endpoint:** `POST /api/v1/license-types/{licenseTypeId}/entities`

**Payload de Requisição:**
```json
{
  "entityId": "ent-003",
  "roleKey": "CONSULTANT",
  "responsibilityKey": "SUPPORT",
  "isRequired": false,
  "processingOrder": 3,
  "maxProcessingDays": 5,
  "canDelegate": true,
  "requiresPhysicalInspection": false,
  "feeResponsible": false,
  "delegationCriteria": "Pode delegar para consultores externos certificados",
  "inspectionScope": "Análise de impacto ambiental quando aplicável",
  "metadata": {
    "consultationTriggers": [
      "Capacidade > 100 pessoas",
      "Localização em zona sensível",
      "Atividade com impacto ambiental"
    ],
    "requiredCertifications": [
      "Avaliação Ambiental"
    ]
  }
}
```

**Resposta de Sucesso (201):**
```json
{
  "associationId": "lte-025",
  "message": "Entidade associada com sucesso",
  "licenseTypeId": "lt-001",
  "entityId": "ent-003",
  "role": "CONSULTANT",
  "responsibility": "SUPPORT",
  "processingOrder": 3,
  "estimatedImpact": {
    "additionalProcessingDays": 5,
    "newTotalProcessingDays": 35,
    "affectedApplications": 0
  }
}
```

#### 4.1.3 Fluxo de Processo por Entidades
**Endpoint:** `GET /api/v1/license-types/{licenseTypeId}/entities/process-flow`

**Resposta de Sucesso (200):**
```json
{
  "licenseTypeId": "lt-001",
  "licenseTypeName": "Licença de Restaurante",
  "processFlow": {
    "type": "SEQUENTIAL_WITH_PARALLEL",
    "totalSteps": 5,
    "estimatedDuration": 30,
    "criticalPath": 25,
    "steps": [
      {
        "stepNumber": 1,
        "type": "PARALLEL",
        "description": "Análises técnicas iniciais",
        "entities": [
          {
            "entityId": "ent-001",
            "name": "Câmara Municipal da Praia",
            "role": "ANALYZER",
            "task": "Análise urbanística",
            "maxDays": 10,
            "dependencies": []
          },
          {
            "entityId": "ent-004",
            "name": "Bombeiros da Praia",
            "role": "INSPECTOR",
            "task": "Análise de segurança contra incêndios",
            "maxDays": 7,
            "dependencies": []
          }
        ]
      },
      {
        "stepNumber": 2,
        "type": "SEQUENTIAL",
        "description": "Inspeção sanitária",
        "entities": [
          {
            "entityId": "ent-002",
            "name": "Delegacia de Saúde da Praia",
            "role": "INSPECTOR",
            "task": "Inspeção de condições sanitárias",
            "maxDays": 10,
            "dependencies": ["step-1"]
          }
        ]
      },
      {
        "stepNumber": 3,
        "type": "CONDITIONAL",
        "description": "Consulta ambiental (se aplicável)",
        "condition": "Capacidade > 100 pessoas OR Zona sensível",
        "entities": [
          {
            "entityId": "ent-003",
            "name": "Direção Nacional do Ambiente",
            "role": "CONSULTANT",
            "task": "Avaliação de impacto ambiental",
            "maxDays": 15,
            "dependencies": ["step-1", "step-2"]
          }
        ]
      },
      {
        "stepNumber": 4,
        "type": "SEQUENTIAL",
        "description": "Aprovação final",
        "entities": [
          {
            "entityId": "ent-001",
            "name": "Câmara Municipal da Praia",
            "role": "APPROVER",
            "task": "Decisão final de licenciamento",
            "maxDays": 5,
            "dependencies": ["step-1", "step-2", "step-3"]
          }
        ]
      }
    ]
  },
  "alternativeFlows": [
    {
      "condition": "Estabelecimento < 50m²",
      "description": "Fluxo simplificado",
      "skipSteps": [3],
      "estimatedDuration": 20
    }
  ]
}
```

---

## 5. Funcionalidades Avançadas

### 5.1 Análise de Capacidade

#### 5.1.1 Capacidade de Processamento por Entidade
**Endpoint:** `GET /api/v1/entities/{entityId}/capacity-analysis`

**Resposta de Sucesso (200):**
```json
{
  "entityId": "ent-001",
  "entityName": "Câmara Municipal da Praia",
  "currentCapacity": {
    "status": "NORMAL",
    "utilizationRate": 75.5,
    "pendingApplications": 45,
    "maxCapacity": 60,
    "availableSlots": 15
  },
  "processingMetrics": {
    "averageProcessingTime": 12.5,
    "targetProcessingTime": 15.0,
    "performanceRating": "GOOD",
    "bottlenecks": [
      "Inspeções físicas durante período de férias"
    ]
  },
  "workloadForecast": {
    "next7Days": {
      "expectedApplications": 12,
      "expectedCompletions": 15,
      "projectedUtilization": 70.0
    },
    "next30Days": {
      "expectedApplications": 50,
      "expectedCompletions": 55,
      "projectedUtilization": 72.0
    }
  },
  "recommendations": [
    "Considerar redistribuição de inspeções para períodos de menor demanda",
    "Avaliar possibilidade de delegação para reduzir carga de trabalho"
  ]
}
```

### 5.2 Otimização de Fluxos

#### 5.2.1 Análise de Otimização de Processo
**Endpoint:** `GET /api/v1/license-types/{licenseTypeId}/entities/optimization-analysis`

**Resposta de Sucesso (200):**
```json
{
  "licenseTypeId": "lt-001",
  "currentFlow": {
    "totalDuration": 30,
    "criticalPath": 25,
    "bottlenecks": [
      {
        "entityId": "ent-002",
        "entityName": "Delegacia de Saúde",
        "issue": "Inspeções físicas demoradas",
        "impact": 5
      }
    ]
  },
  "optimizationSuggestions": [
    {
      "type": "PARALLELIZATION",
      "description": "Executar análise urbanística e sanitária em paralelo",
      "potentialSaving": 7,
      "feasibility": "HIGH",
      "requirements": [
        "Coordenação entre CMP e DSP",
        "Protocolo de compartilhamento de informações"
      ]
    },
    {
      "type": "DELEGATION",
      "description": "Delegar inspeções simples para técnicos certificados",
      "potentialSaving": 3,
      "feasibility": "MEDIUM",
      "requirements": [
        "Certificação de técnicos externos",
        "Protocolo de supervisão"
      ]
    }
  ],
  "optimizedFlow": {
    "estimatedDuration": 20,
    "improvementPercentage": 33.3,
    "riskFactors": [
      "Necessidade de coordenação adicional",
      "Possível redução na qualidade da análise"
    ]
  }
}
```

---

## 6. Regras de Negócio Específicas

### 6.1 Validações de Associação

#### 6.1.1 Regras de Integridade
```java
// Validação de ordem de processamento
@AssertTrue(message = "Ordem de processamento deve ser única por tipo de licença")
public boolean isProcessingOrderUnique() {
    // Implementação da validação
    return true;
}

// Validação de responsabilidade primária
@AssertTrue(message = "Deve haver pelo menos uma entidade com responsabilidade primária")
public boolean hasPrimaryResponsibility() {
    // Implementação da validação
    return true;
}

// Validação de papel vs responsabilidade
@AssertTrue(message = "Aprovadores devem ter responsabilidade primária ou secundária")
public boolean isApproverResponsibilityValid() {
    return !"APPROVER".equals(roleKey) || 
           ("PRIMARY".equals(responsibilityKey) || "SECONDARY".equals(responsibilityKey));
}
```

#### 6.1.2 Regras de Fluxo
- Entidades com `processingOrder` menor devem completar antes das posteriores
- Entidades com `isRequired=true` não podem ser removidas se houver processos ativos
- Alterações em `maxProcessingDays` afetam apenas novos processos
- Delegação só é permitida se `canDelegate=true` e existirem critérios definidos

### 6.2 Regras de Jurisdição

#### 6.2.1 Validação de Competência Territorial
- Entidades só podem processar licenças dentro de sua jurisdição
- Entidades nacionais podem processar qualquer licença
- Entidades locais só processam licenças de sua área
- Conflitos de jurisdição devem ser resolvidos por entidade superior

#### 6.2.2 Hierarquia de Entidades
- Entidades filhas herdam competências da entidade pai
- Delegação deve respeitar a hierarquia organizacional
- Supervisão é exercida pela entidade imediatamente superior

---

## 7. Casos de Uso Específicos

### 7.1 UC001 - Configurar Fluxo Multi-Entidade
**Cenário:** Restaurante em zona turística (múltiplas aprovações)

**Entidades Envolvidas:**
1. Câmara Municipal (Aprovação urbanística)
2. Delegacia de Saúde (Inspeção sanitária)
3. Direção de Turismo (Conformidade turística)
4. Bombeiros (Segurança contra incêndios)
5. Polícia Nacional (Segurança pública)

**Fluxo:**
- Paralelo: CMP + Bombeiros + Polícia
- Sequencial: Delegacia de Saúde
- Condicional: Direção de Turismo (se zona turística)
- Final: CMP (Aprovação final)

### 7.2 UC002 - Delegação de Competências
**Cenário:** Sobrecarga na Delegacia de Saúde

**Fluxo:**
1. Identificar sobrecarga (>90% capacidade)
2. Verificar critérios de delegação
3. Selecionar técnicos certificados
4. Delegar inspeções simples
5. Manter supervisão da DSP

### 7.3 UC003 - Otimização de Processo
**Cenário:** Reduzir tempo de processamento

**Análise:**
1. Identificar gargalos no fluxo atual
2. Avaliar possibilidades de paralelização
3. Considerar delegação de tarefas
4. Implementar melhorias graduais
5. Monitorar impacto nas métricas

---

## 8. Integrações e Dependências

### 8.1 Sistemas Externos
- **Sistema de Gestão Documental**: Para troca de documentos
- **Sistema de Notificações**: Para comunicação entre entidades
- **Sistema de Geolocalização**: Para validação de jurisdição
- **Sistema de Agenda**: Para agendamento de inspeções

### 8.2 Módulos Internos
- **Tipos de Licença**: Definição de fluxos
- **Processos**: Execução dos fluxos
- **Solicitações**: Roteamento por entidade
- **Taxas**: Distribuição de receitas
- **Relatórios**: Análise de performance

---

## 9. Monitoramento e Métricas

### 9.1 KPIs por Entidade
- Tempo médio de processamento
- Taxa de aprovação/rejeição
- Capacidade de processamento
- Qualidade das análises
- Satisfação dos requerentes

### 9.2 Alertas Automáticos
- Sobrecarga de capacidade (>85%)
- Atrasos em processamento
- Inconsistências entre entidades
- Falhas de comunicação
- Violações de SLA

---

## 10. Considerações de Segurança

### 10.1 Controle de Acesso
- Autenticação por entidade
- Autorização baseada em competências
- Auditoria de todas as ações
- Segregação de dados por jurisdição

### 10.2 Proteção de Dados
- Criptografia de comunicações
- Backup de dados críticos
- Controle de versões de documentos
- Logs de auditoria imutáveis

Este documento estabelece a base completa para a gestão de entidades no sistema de licenciamento, garantindo coordenação eficiente e transparência nos processos multi-institucionais.