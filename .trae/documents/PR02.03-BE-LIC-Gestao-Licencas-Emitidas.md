# PR02.03 - Backend Licenciamento - Gestão de Licenças Emitidas

## 1. Visão Geral

### 1.1 Objetivos

Este módulo é responsável pela gestão completa das licenças emitidas no sistema de licenciamento de Cabo Verde, incluindo:

* **Modelo de dados** **`T_ISSUED_LICENSE`**: Estrutura principal para armazenamento de licenças emitidas

* **Arquitetura DDD**: Implementação seguindo Domain-Driven Design com Aggregate Root, Value Objects e Domain Services

* **APIs REST**: Endpoints para criação, consulta, renovação, suspensão e cancelamento de licenças

* **Validações de negócio**: Regras para emissão, renovação e gestão do ciclo de vida das licenças

* **Gestão de status**: Controle completo do estado das licenças (ativa, suspensa, expirada, cancelada)

* **Histórico de alterações**: Rastreamento completo de mudanças de status e renovações

### 1.2 Diagrama ER

## 4. REST API Specification

### 4.1 Base Configuration

**Base URL:** `/api/v1/licenses`

**Headers Obrigatórios:**

```
Content-Type: application/json
Authorization: Bearer {jwt_token}
X-Request-ID: {unique_request_id}
```

**Códigos de Status Padrão:**

* `200 OK` - Operação bem-sucedida

* `201 Created` - Recurso criado com sucesso

* `400 Bad Request` - Dados inválidos na requisição

* `401 Unauthorized` - Token de autenticação inválido

* `403 Forbidden` - Acesso negado

* `404 Not Found` - Recurso não encontrado

* `409 Conflict` - Conflito de dados (ex: número de licença duplicado)

* `422 Unprocessable Entity` - Erro de validação de negócio

* `500 Internal Server Error` - Erro interno do servidor

### 4.2 Endpoints de Licenças

#### 4.2.1 Criar Licença

**POST** `/api/v1/licenses`

**Request Body:**

```json
{
  "licenseNumber": "LIC-2025-001",
  "licenseType": "COMMERCIAL_OPERATION",
  "holderId": "holder-550e8400-e29b-41d4-a716-446655440000",
  "establishmentId": "est-550e8400-e29b-41d4-a716-446655440001",
  "issuerId": "issuer-550e8400-e29b-41d4-a716-446655440002",
  "issueDate": "2025-01-15",
  "expiryDate": "2025-01-15",
  "conditions": [
    {
      "type": "OPERATIONAL_HOURS",
      "description": "Funcionamento das 08:00 às 22:00",
      "value": "08:00-22:00"
    },
    {
      "type": "CAPACITY_LIMIT",
      "description": "Capacidade máxima de 50 pessoas",
      "value": "50"
    }
  ],
  "fees": {
    "baseFee": 5000.00,
    "processingFee": 500.00,
    "inspectionFee": 1000.00,
    "totalAmount": 6500.00,
    "currency": "CVE"
  },
  "documents": [
    {
      "documentType": "BUSINESS_PLAN",
      "documentName": "Plano de Negócios",
      "required": true
    },
    {
      "documentType": "SAFETY_CERTIFICATE",
      "documentName": "Certificado de Segurança",
      "required": true
    }
  ]
}
```

**Response (201 Created):**

```json
{
  "success": true,
  "data": {
    "id": "license-550e8400-e29b-41d4-a716-446655440000",
    "licenseNumber": "LIC-2025-001",
    "licenseType": "COMMERCIAL_OPERATION",
    "status": "PENDING",
    "holder": {
      "id": "holder-550e8400-e29b-41d4-a716-446655440000",
      "name": "João Silva Santos",
      "holderType": "INDIVIDUAL"
    },
    "establishment": {
      "id": "est-550e8400-e29b-41d4-a716-446655440001",
      "name": "Restaurante Sabores da Terra",
      "municipality": "Praia"
    },
    "issuer": {
      "id": "issuer-550e8400-e29b-41d4-a716-446655440002",
      "name": "Câmara Municipal da Praia"
    },
    "issueDate": "2025-01-15",
    "expiryDate": "2025-01-15",
    "daysUntilExpiry": 365,
    "isRenewable": true,
    "createdAt": "2025-01-15T10:30:00Z",
    "createdBy": "user123"
  },
  "message": "Licença criada com sucesso"
}
```

**Exemplo cURL:**

```bash
curl -X POST "https://api.licenciamento.cv/api/v1/licenses" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." \
  -d '{
    "licenseNumber": "LIC-2025-001",
    "licenseType": "COMMERCIAL_OPERATION",
    "holderId": "holder-550e8400-e29b-41d4-a716-446655440000",
    "establishmentId": "est-550e8400-e29b-41d4-a716-446655440001",
    "issuerId": "issuer-550e8400-e29b-41d4-a716-446655440002",
    "issueDate": "2025-01-15",
    "expiryDate": "2025-01-15"
  }'
```

#### 4.2.2 Buscar Licença por ID

**GET** `/api/v1/licenses/{id}`

**Path Parameters:**

* `id` (UUID) - ID único da licença

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "id": "license-550e8400-e29b-41d4-a716-446655440000",
    "licenseNumber": "LIC-2025-001",
    "licenseType": "COMMERCIAL_OPERATION",
    "status": "ACTIVE",
    "holder": {
      "id": "holder-550e8400-e29b-41d4-a716-446655440000",
      "name": "João Silva Santos",
      "holderType": "INDIVIDUAL",
      "identification": {
        "type": "NATIONAL_ID",
        "number": "123456789"
      }
    },
    "establishment": {
      "id": "est-550e8400-e29b-41d4-a716-446655440001",
      "name": "Restaurante Sabores da Terra",
      "matricialNumber": "CV12345678",
      "municipality": "Praia",
      "island": "Santiago"
    },
    "issuer": {
      "id": "issuer-550e8400-e29b-41d4-a716-446655440002",
      "name": "Câmara Municipal da Praia",
      "jurisdiction": "Praia"
    },
    "issueDate": "2025-01-15",
    "expiryDate": "2025-01-15",
    "daysUntilExpiry": 365,
    "conditions": [
      {
        "type": "OPERATIONAL_HOURS",
        "description": "Funcionamento das 08:00 às 22:00",
        "value": "08:00-22:00",
        "isActive": true
      }
    ],
    "fees": {
      "baseFee": 5000.00,
      "processingFee": 500.00,
      "totalAmount": 6500.00,
      "currency": "CVE",
      "paymentStatus": "PAID",
      "paidAt": "2025-01-15T09:00:00Z"
    },
    "documents": [
      {
        "id": "doc-123",
        "documentType": "BUSINESS_PLAN",
        "documentName": "Plano de Negócios",
        "status": "APPROVED",
        "uploadDate": "2025-01-10T14:30:00Z"
      }
    ],
    "renewals": [
      {
        "id": "renewal-456",
        "renewalDate": "2023-01-15",
        "previousExpiryDate": "2025-01-15",
        "newExpiryDate": "2025-01-15",
        "status": "COMPLETED"
      }
    ],
    "isRenewable": true,
    "canBeRevoked": true,
    "createdAt": "2025-01-15T10:30:00Z",
    "updatedAt": "2025-01-15T10:30:00Z"
  }
}
```

#### 4.2.3 Buscar Licença por Número

**GET** `/api/v1/licenses/by-number/{licenseNumber}`

**Path Parameters:**

* `licenseNumber` (string) - Número da licença

#### 4.2.4 Listar Licenças

**GET** `/api/v1/licenses`

**Query Parameters:**

* `page` (int, default: 0) - Número da página

* `size` (int, default: 20, max: 100) - Tamanho da página

* `sort` (string, default: "createdAt,desc") - Ordenação

* `licenseType` (string) - Filtrar por tipo de licença

* `status` (string) - Filtrar por status

* `holderId` (UUID) - Filtrar por titular

* `establishmentId` (UUID) - Filtrar por estabelecimento

* `issuerId` (UUID) - Filtrar por emissor

* `municipality` (string) - Filtrar por município

* `island` (string) - Filtrar por ilha

* `issueDate` (date) - Filtrar por data de emissão

* `expiryDate` (date) - Filtrar por data de expiração

* `expiringInDays` (int) - Licenças que expiram em X dias

* `search` (string) - Busca textual em número ou nome do titular

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "content": [
      {
        "id": "license-550e8400-e29b-41d4-a716-446655440000",
        "licenseNumber": "LIC-2025-001",
        "licenseType": "COMMERCIAL_OPERATION",
        "status": "ACTIVE",
        "holder": {
          "id": "holder-550e8400-e29b-41d4-a716-446655440000",
          "name": "João Silva Santos"
        },
        "establishment": {
          "id": "est-550e8400-e29b-41d4-a716-446655440001",
          "name": "Restaurante Sabores da Terra",
          "municipality": "Praia"
        },
        "issuer": {
          "name": "Câmara Municipal da Praia"
        },
        "issueDate": "2025-01-15",
        "expiryDate": "2025-01-15",
        "daysUntilExpiry": 365,
        "isRenewable": true,
        "createdAt": "2025-01-15T10:30:00Z"
      }
    ],
    "pageable": {
      "page": 0,
      "size": 20,
      "sort": "createdAt,desc"
    },
    "totalElements": 1,
    "totalPages": 1,
    "first": true,
    "last": true
  }
}
```

#### 4.2.5 Atualizar Licença

**PUT** `/api/v1/licenses/{id}`

**Request Body:**

```json
{
  "conditions": [
    {
      "type": "OPERATIONAL_HOURS",
      "description": "Funcionamento das 07:00 às 23:00",
      "value": "07:00-23:00"
    },
    {
      "type": "CAPACITY_LIMIT",
      "description": "Capacidade máxima de 60 pessoas",
      "value": "60"
    }
  ],
  "notes": "Condições atualizadas conforme solicitação do titular"
}
```

#### 4.2.6 Alterar Status da Licença

**PATCH** `/api/v1/licenses/{id}/status`

**Request Body:**

```json
{
  "status": "SUSPENDED",
  "reason": "Violação das condições de funcionamento",
  "notes": "Estabelecimento funcionando fora do horário permitido",
  "effectiveDate": "2025-01-20T00:00:00Z",
  "suspensionPeriod": 30,
  "reviewDate": "2025-02-20T00:00:00Z"
}
```

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "id": "license-550e8400-e29b-41d4-a716-446655440000",
    "status": "SUSPENDED",
    "statusHistory": [
      {
        "previousStatus": "ACTIVE",
        "newStatus": "SUSPENDED",
        "changedAt": "2025-01-20T10:00:00Z",
        "changedBy": "inspector123",
        "reason": "Violação das condições de funcionamento"
      }
    ],
    "updatedAt": "2025-01-20T10:00:00Z"
  },
  "message": "Status da licença alterado com sucesso"
}
```

### 4.3 Endpoints de Renovação

#### 4.3.1 Iniciar Renovação

**POST** `/api/v1/licenses/{id}/renewals`

**Request Body:**

```json
{
  "newExpiryDate": "2026-01-15",
  "renewalType": "STANDARD",
  "fees": {
    "renewalFee": 3000.00,
    "inspectionFee": 500.00,
    "totalAmount": 3500.00,
    "currency": "CVE"
  },
  "requiredDocuments": [
    "UPDATED_BUSINESS_PLAN",
    "SAFETY_INSPECTION_REPORT"
  ],
  "notes": "Renovação padrão para mais 12 meses"
}
```

**Response (201 Created):**

```json
{
  "success": true,
  "data": {
    "id": "renewal-789",
    "licenseId": "license-550e8400-e29b-41d4-a716-446655440000",
    "renewalType": "STANDARD",
    "status": "PENDING",
    "currentExpiryDate": "2025-01-15",
    "newExpiryDate": "2026-01-15",
    "requestedAt": "2025-12-15T10:00:00Z",
    "estimatedCompletionDate": "2025-12-30T17:00:00Z",
    "fees": {
      "renewalFee": 3000.00,
      "totalAmount": 3500.00,
      "paymentStatus": "PENDING"
    }
  },
  "message": "Processo de renovação iniciado com sucesso"
}
```

#### 4.3.2 Listar Renovações da Licença

**GET** `/api/v1/licenses/{id}/renewals`

**Query Parameters:**

* `status` (string) - Filtrar por status da renovação

* `includeCompleted` (boolean, default: true) - Incluir renovações concluídas

#### 4.3.3 Aprovar Renovação

**PATCH** `/api/v1/licenses/{licenseId}/renewals/{renewalId}/approve`

**Request Body:**

```json
{
  "approverNotes": "Documentação completa e em conformidade",
  "approvedBy": "approver123",
  "approvalDate": "2025-12-28T15:30:00Z",
  "effectiveDate": "2025-01-15T00:00:00Z"
}
```

### 4.4 Endpoints de Condições

#### 4.4.1 Adicionar Condição

**POST** `/api/v1/licenses/{id}/conditions`

**Request Body:**

```json
{
  "type": "ENVIRONMENTAL_COMPLIANCE",
  "description": "Cumprimento das normas ambientais",
  "value": "ISO14001",
  "isActive": true,
  "effectiveDate": "2025-02-01T00:00:00Z",
  "notes": "Condição adicionada após inspeção ambiental"
}
```

#### 4.4.2 Atualizar Condição

**PUT** `/api/v1/licenses/{licenseId}/conditions/{conditionId}`

#### 4.4.3 Remover Condição

**DELETE** `/api/v1/licenses/{licenseId}/conditions/{conditionId}`

### 4.5 Endpoints de Documentos

#### 4.5.1 Listar Documentos da Licença

**GET** `/api/v1/licenses/{id}/documents`

**Query Parameters:**

* `documentType` (string) - Filtrar por tipo de documento

* `status` (string) - Filtrar por status

* `required` (boolean) - Filtrar por obrigatórios

#### 4.5.2 Adicionar Documento

**POST** `/api/v1/licenses/{id}/documents`

**Request Body (multipart/form-data):**

```
documentType: SAFETY_CERTIFICATE
documentName: Certificado de Segurança Atualizado
file: [binary file data]
expiryDate: 2025-12-31
description: Certificado de segurança renovado
required: true
```

#### 4.5.3 Aprovar/Rejeitar Documento

**PATCH** `/api/v1/licenses/{licenseId}/documents/{documentId}/review`

**Request Body:**

```json
{
  "status": "APPROVED",
  "reviewerNotes": "Documento válido e em conformidade",
  "reviewedBy": "reviewer123",
  "reviewDate": "2025-01-18T14:30:00Z"
}
```

### 4.6 Endpoints de Validação

#### 4.6.1 Validar Número de Licença

**POST** `/api/v1/licenses/validate-number`

**Request Body:**

```json
{
  "licenseNumber": "LIC-2025-001",
  "excludeLicenseId": "license-123" // Opcional, para excluir da validação
}
```

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "isValid": true,
    "isUnique": false,
    "formatValid": true,
    "existingLicense": {
      "id": "license-existing-123",
      "licenseNumber": "LIC-2025-001",
      "status": "ACTIVE",
      "holder": "João Silva Santos"
    },
    "validationDetails": {
      "formatChecks": {
        "prefixValid": true,
        "yearValid": true,
        "sequenceValid": true
      }
    }
  }
}
```

#### 4.6.2 Verificar Elegibilidade para Renovação

**POST** `/api/v1/licenses/{id}/check-renewal-eligibility`

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "isEligible": true,
    "eligibilityScore": 90,
    "checks": {
      "statusCheck": {
        "status": "PASSED",
        "details": "Licença ativa e em conformidade"
      },
      "documentCheck": {
        "status": "PASSED",
        "details": "Todos os documentos válidos"
      },
      "complianceCheck": {
        "status": "PASSED",
        "details": "Nenhuma violação registrada"
      }
    },
    "requirements": [],
    "warnings": [
      "Certificado de segurança expira em 60 dias"
    ],
    "recommendedActions": [
      "Renovar certificado de segurança antes da renovação"
    ]
  }
}
```

### 4.7 Endpoints de Busca Avançada

#### 4.7.1 Busca por Critérios Múltiplos

**POST** `/api/v1/licenses/search`

**Request Body:**

```json
{
  "criteria": {
    "licenseTypes": ["COMMERCIAL_OPERATION", "INDUSTRIAL"],
    "statuses": ["ACTIVE", "PENDING"],
    "location": {
      "islands": ["Santiago", "São Vicente"],
      "municipalities": ["Praia", "Mindelo"]
    },
    "dateRange": {
      "issueDate": {
        "from": "2025-01-01",
        "to": "2025-12-31"
      },
      "expiryDate": {
        "from": "2025-01-01",
        "to": "2025-12-31"
      }
    },
    "holderType": "INDIVIDUAL",
    "hasActiveViolations": false,
    "renewalStatus": "ELIGIBLE"
  },
  "pagination": {
    "page": 0,
    "size": 50
  },
  "sorting": [
    {
      "field": "expiryDate",
      "direction": "ASC"
    }
  ]
}
```

#### 4.7.2 Licenças Próximas ao Vencimento

**GET** `/api/v1/licenses/expiring-soon`

**Query Parameters:**

* `days` (int, default: 30) - Dias até o vencimento

* `licenseType` (string) - Filtrar por tipo

* `municipality` (string) - Filtrar por município

* `notificationSent` (boolean) - Filtrar por notificação enviada

### 4.8 Endpoints de Relatórios

#### 4.8.1 Estatísticas de Licenças

**GET** `/api/v1/licenses/statistics`

**Query Parameters:**

* `period` (string) - Período (DAILY, WEEKLY, MONTHLY, YEARLY)

* `fromDate` (date) - Data inicial

* `toDate` (date) - Data final

* `groupBy` (string) - Agrupar por (licenseType, status, municipality)

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "totalLicenses": 2500,
    "activeLicenses": 2100,
    "byType": {
      "COMMERCIAL_OPERATION": 1200,
      "INDUSTRIAL": 800,
      "TOURISM": 500
    },
    "byStatus": {
      "ACTIVE": 2100,
      "PENDING": 200,
      "SUSPENDED": 150,
      "REVOKED": 50
    },
    "expiringIn30Days": 120,
    "renewalsThisMonth": 85,
    "newLicensesThisMonth": 45,
    "revenueThisMonth": {
      "totalFees": 325000.00,
      "renewalFees": 180000.00,
      "newLicenseFees": 145000.00,
      "currency": "CVE"
    }
  }
}
```

### 4.9 Tratamento de Erros

#### 4.9.1 Erro de Validação (400 Bad Request)

```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Dados de entrada inválidos",
    "details": [
      {
        "field": "licenseNumber",
        "message": "Número de licença deve seguir o formato LIC-YYYY-NNN"
      },
      {
        "field": "expiryDate",
        "message": "Data de expiração deve ser posterior à data de emissão"
      },
      {
        "field": "holderId",
        "message": "Titular não encontrado ou inativo"
      }
    ]
  },
  "timestamp": "2025-01-15T10:30:00Z",
  "path": "/api/v1/licenses"
}
```

#### 4.9.2 Número de Licença Duplicado (409 Conflict)

```json
{
  "success": false,
  "error": {
    "code": "DUPLICATE_LICENSE_NUMBER",
    "message": "Número de licença já existe",
    "details": {
      "licenseNumber": "LIC-2025-001",
      "existingLicenseId": "license-existing-123",
      "existingLicenseHolder": "João Silva Santos",
      "issueDate": "2025-01-10T10:00:00Z"
    }
  },
  "timestamp": "2025-01-15T10:30:00Z",
  "path": "/api/v1/licenses"
}
```

#### 4.9.3 Licença Não Encontrada (404 Not Found)

```json
{
  "success": false,
  "error": {
    "code": "LICENSE_NOT_FOUND",
    "message": "Licença não encontrada",
    "details": {
      "licenseId": "license-550e8400-e29b-41d4-a716-446655440000"
    }
  },
  "timestamp": "2025-01-15T10:30:00Z",
  "path": "/api/v1/licenses/license-550e8400-e29b-41d4-a716-446655440000"
}
```

#### 4.9.4 Operação Não Permitida (422 Unprocessable Entity)

```json
{
  "success": false,
  "error": {
    "code": "OPERATION_NOT_ALLOWED",
    "message": "Operação não permitida no status atual da licença",
    "details": {
      "licenseId": "license-123",
      "currentStatus": "REVOKED",
      "attemptedOperation": "RENEWAL",
      "allowedOperations": ["VIEW", "ARCHIVE"],
      "reason": "Licenças revogadas não podem ser renovadas"
    }
  },
  "timestamp": "2025-01-15T10:30:00Z",
  "path": "/api/v1/licenses/license-123/renewals"
}
```

## 5. Considerações de Implementação

### 5.1 Performance

* Implementar cache para consultas frequentes de licenças

* Usar índices otimizados para buscas por número e status

* Considerar particionamento por data de emissão

### 5.2 Segurança

* Implementar assinatura digital para licenças

* Criptografar dados sensíveis

* Implementar auditoria completa de alterações

### 5.3 Integração

* Preparar APIs para integração com sistemas externos

* Implementar webhooks para notificações de mudanças

* Considerar sincronização com registros oficiais

```mermaid
erDiagram
    T_ISSUED_LICENSE {
        uuid id PK
        varchar license_number UK
        uuid license_type_id_fk FK
        uuid license_holder_id_fk FK
        uuid establishment_id_fk FK
        uuid issuer_id_fk FK
        varchar license_status
        date issue_date
        date expiry_date
        date effective_date
        varchar validity_period
        varchar validity_unit
        boolean is_provisional
        text conditions
        text restrictions
        decimal fees_paid
        varchar payment_status
        varchar payment_reference
        date payment_date
        text notes
        varchar created_by
        timestamp created_at
        varchar updated_by
        timestamp updated_at
        integer version
    }
    
    T_LICENSE_STATUS_HISTORY {
        uuid id PK
        uuid issued_license_id_fk FK
        varchar previous_status
        varchar new_status
        varchar reason_code
        text reason_description
        varchar changed_by
        timestamp changed_at
        text additional_notes
    }
    
    T_LICENSE_RENEWAL {
        uuid id PK
        uuid issued_license_id_fk FK
        varchar renewal_number UK
        date renewal_date
        date new_expiry_date
        varchar renewal_type
        decimal renewal_fees
        varchar payment_status
        varchar payment_reference
        date payment_date
        text renewal_notes
        varchar processed_by
        timestamp processed_at
    }
    
    T_LICENSE_DOCUMENT {
        uuid id PK
        uuid issued_license_id_fk FK
        varchar document_type
        varchar document_name
        varchar file_path
        varchar mime_type
        bigint file_size
        varchar document_status
        varchar uploaded_by
        timestamp uploaded_at
        date expiry_date
        text description
    }
    
    T_ISSUED_LICENSE ||--o{ T_LICENSE_STATUS_HISTORY : has
    T_ISSUED_LICENSE ||--o{ T_LICENSE_RENEWAL : has
    T_ISSUED_LICENSE ||--o{ T_LICENSE_DOCUMENT : has
```

## 2. Modelo de Dados

### 2.1 Definição das Tabelas

#### 2.1.1 Tabela T\_ISSUED\_LICENSE

```sql
CREATE TABLE t_issued_license (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    license_number VARCHAR(50) UNIQUE NOT NULL,
    license_type_id_fk UUID NOT NULL,
    license_holder_id_fk UUID NOT NULL,
    establishment_id_fk UUID,
    issuer_id_fk UUID NOT NULL,
    license_status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE' 
        CHECK (license_status IN ('ACTIVE', 'SUSPENDED', 'EXPIRED', 'CANCELLED', 'PENDING_RENEWAL')),
    issue_date DATE NOT NULL,
    expiry_date DATE,
    effective_date DATE NOT NULL,
    validity_period INTEGER,
    validity_unit VARCHAR(10) CHECK (validity_unit IN ('DAYS', 'MONTHS', 'YEARS')),
    is_provisional BOOLEAN DEFAULT FALSE,
    conditions TEXT,
    restrictions TEXT,
    fees_paid DECIMAL(15,2) DEFAULT 0.00,
    payment_status VARCHAR(20) DEFAULT 'PENDING' 
        CHECK (payment_status IN ('PENDING', 'PAID', 'PARTIAL', 'OVERDUE', 'WAIVED')),
    payment_reference VARCHAR(100),
    payment_date DATE,
    notes TEXT,
    created_by VARCHAR(100) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_by VARCHAR(100),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    version INTEGER DEFAULT 1
);
```

#### 2.1.2 Tabela T\_LICENSE\_STATUS\_HISTORY

```sql
CREATE TABLE t_license_status_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    issued_license_id_fk UUID NOT NULL REFERENCES t_issued_license(id) ON DELETE CASCADE,
    previous_status VARCHAR(20),
    new_status VARCHAR(20) NOT NULL,
    reason_code VARCHAR(50),
    reason_description TEXT,
    changed_by VARCHAR(100) NOT NULL,
    changed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    additional_notes TEXT
);
```

#### 2.1.3 Tabela T\_LICENSE\_RENEWAL

```sql
CREATE TABLE t_license_renewal (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    issued_license_id_fk UUID NOT NULL REFERENCES t_issued_license(id) ON DELETE CASCADE,
    renewal_number VARCHAR(50) UNIQUE NOT NULL,
    renewal_date DATE NOT NULL,
    new_expiry_date DATE NOT NULL,
    renewal_type VARCHAR(20) DEFAULT 'STANDARD' 
        CHECK (renewal_type IN ('STANDARD', 'EARLY', 'LATE', 'EMERGENCY')),
    renewal_fees DECIMAL(15,2) DEFAULT 0.00,
    payment_status VARCHAR(20) DEFAULT 'PENDING' 
        CHECK (payment_status IN ('PENDING', 'PAID', 'PARTIAL', 'OVERDUE', 'WAIVED')),
    payment_reference VARCHAR(100),
    payment_date DATE,
    renewal_notes TEXT,
    processed_by VARCHAR(100) NOT NULL,
    processed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### 2.1.4 Tabela T\_LICENSE\_DOCUMENT

```sql
CREATE TABLE t_license_document (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    issued_license_id_fk UUID NOT NULL REFERENCES t_issued_license(id) ON DELETE CASCADE,
    document_type VARCHAR(50) NOT NULL 
        CHECK (document_type IN ('LICENSE_CERTIFICATE', 'SUPPORTING_DOCUMENT', 'INSPECTION_REPORT', 'COMPLIANCE_CERTIFICATE')),
    document_name VARCHAR(255) NOT NULL,
    file_path VARCHAR(500) NOT NULL,
    mime_type VARCHAR(100),
    file_size BIGINT,
    document_status VARCHAR(20) DEFAULT 'ACTIVE' 
        CHECK (document_status IN ('ACTIVE', 'ARCHIVED', 'DELETED')),
    uploaded_by VARCHAR(100) NOT NULL,
    uploaded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    expiry_date DATE,
    description TEXT
);
```

### 2.2 Índices de Performance

```sql
-- Índices para T_ISSUED_LICENSE
CREATE INDEX idx_issued_license_license_number ON t_issued_license(license_number);
CREATE INDEX idx_issued_license_license_type ON t_issued_license(license_type_id_fk);
CREATE INDEX idx_issued_license_holder ON t_issued_license(license_holder_id_fk);
CREATE INDEX idx_issued_license_establishment ON t_issued_license(establishment_id_fk);
CREATE INDEX idx_issued_license_issuer ON t_issued_license(issuer_id_fk);
CREATE INDEX idx_issued_license_status ON t_issued_license(license_status);
CREATE INDEX idx_issued_license_issue_date ON t_issued_license(issue_date DESC);
CREATE INDEX idx_issued_license_expiry_date ON t_issued_license(expiry_date);
CREATE INDEX idx_issued_license_effective_date ON t_issued_license(effective_date);
CREATE INDEX idx_issued_license_payment_status ON t_issued_license(payment_status);
CREATE INDEX idx_issued_license_created_at ON t_issued_license(created_at DESC);

-- Índices para T_LICENSE_STATUS_HISTORY
CREATE INDEX idx_license_status_history_license ON t_license_status_history(issued_license_id_fk);
CREATE INDEX idx_license_status_history_changed_at ON t_license_status_history(changed_at DESC);
CREATE INDEX idx_license_status_history_status ON t_license_status_history(new_status);

-- Índices para T_LICENSE_RENEWAL
CREATE INDEX idx_license_renewal_license ON t_license_renewal(issued_license_id_fk);
CREATE INDEX idx_license_renewal_number ON t_license_renewal(renewal_number);
CREATE INDEX idx_license_renewal_date ON t_license_renewal(renewal_date DESC);
CREATE INDEX idx_license_renewal_payment_status ON t_license_renewal(payment_status);

-- Índices para T_LICENSE_DOCUMENT
CREATE INDEX idx_license_document_license ON t_license_document(issued_license_id_fk);
CREATE INDEX idx_license_document_type ON t_license_document(document_type);
CREATE INDEX idx_license_document_status ON t_license_document(document_status);
CREATE INDEX idx_license_document_uploaded_at ON t_license_document(uploaded_at DESC);
```

## 3. Arquitetura DDD

### 3.1 Aggregate Root

#### 3.1.1 IssuedLicense

```java
@Entity
@Table(name = "t_issued_license")
public class IssuedLicense extends AggregateRoot<IssuedLicenseId> {
    
    @EmbeddedId
    private IssuedLicenseId id;
    
    @Column(name = "license_number", unique = true, nullable = false)
    private String licenseNumber;
    
    @Column(name = "license_type_id_fk", nullable = false)
    private UUID licenseTypeId;
    
    @Column(name = "license_holder_id_fk", nullable = false)
    private UUID licenseHolderId;
    
    @Column(name = "establishment_id_fk")
    private UUID establishmentId;
    
    @Column(name = "issuer_id_fk", nullable = false)
    private UUID issuerId;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "license_status", nullable = false)
    private LicenseStatus status;
    
    @Column(name = "issue_date", nullable = false)
    private LocalDate issueDate;
    
    @Column(name = "expiry_date")
    private LocalDate expiryDate;
    
    @Column(name = "effective_date", nullable = false)
    private LocalDate effectiveDate;
    
    @Embedded
    @AttributeOverrides({
        @AttributeOverride(name = "period", column = @Column(name = "validity_period")),
        @AttributeOverride(name = "unit", column = @Column(name = "validity_unit"))
    })
    private ValidityPeriod validityPeriod;
    
    @Column(name = "is_provisional")
    private boolean isProvisional;
    
    @Column(name = "conditions")
    private String conditions;
    
    @Column(name = "restrictions")
    private String restrictions;
    
    @Embedded
    @AttributeOverrides({
        @AttributeOverride(name = "amount", column = @Column(name = "fees_paid")),
        @AttributeOverride(name = "status", column = @Column(name = "payment_status")),
        @AttributeOverride(name = "reference", column = @Column(name = "payment_reference")),
        @AttributeOverride(name = "paymentDate", column = @Column(name = "payment_date"))
    })
    private PaymentInfo paymentInfo;
    
    @Column(name = "notes")
    private String notes;
    
    @Embedded
    private AuditInfo auditInfo;
    
    @Version
    @Column(name = "version")
    private Integer version;
    
    @OneToMany(mappedBy = "issuedLicense", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<LicenseStatusHistory> statusHistory = new ArrayList<>();
    
    @OneToMany(mappedBy = "issuedLicense", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<LicenseRenewal> renewals = new ArrayList<>();
    
    @OneToMany(mappedBy = "issuedLicense", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<LicenseDocument> documents = new ArrayList<>();
    
    protected IssuedLicense() {}
    
    // Método de criação para licença definitiva
    public static IssuedLicense issue(
            String licenseNumber,
            UUID licenseTypeId,
            UUID licenseHolderId,
            UUID establishmentId,
            UUID issuerId,
            LocalDate issueDate,
            LocalDate effectiveDate,
            ValidityPeriod validityPeriod,
            String conditions,
            String restrictions,
            PaymentInfo paymentInfo,
            String createdBy) {
        
        validateIssueParameters(licenseNumber, licenseTypeId, licenseHolderId, 
                               issuerId, issueDate, effectiveDate, validityPeriod, createdBy);
        
        IssuedLicense license = new IssuedLicense();
        license.id = IssuedLicenseId.generate();
        license.licenseNumber = licenseNumber.trim().toUpperCase();
        license.licenseTypeId = licenseTypeId;
        license.licenseHolderId = licenseHolderId;
        license.establishmentId = establishmentId;
        license.issuerId = issuerId;
        license.status = LicenseStatus.ACTIVE;
        license.issueDate = issueDate;
        license.effectiveDate = effectiveDate;
        license.validityPeriod = validityPeriod;
        license.expiryDate = calculateExpiryDate(effectiveDate, validityPeriod);
        license.isProvisional = false;
        license.conditions = conditions;
        license.restrictions = restrictions;
        license.paymentInfo = paymentInfo != null ? paymentInfo : PaymentInfo.pending();
        license.auditInfo = AuditInfo.create(createdBy);
        license.version = 1;
        
        // Adicionar evento de domínio
        license.addDomainEvent(new LicenseIssuedEvent(license.id, license.licenseNumber, 
                                                     license.licenseHolderId, license.licenseTypeId));
        
        // Adicionar histórico inicial
        license.addStatusHistory(null, LicenseStatus.ACTIVE, "INITIAL_ISSUE", 
                               "License initially issued", createdBy);
        
        return license;
    }
    
    // Método de criação para licença provisória
    public static IssuedLicense issueProvisional(
            String licenseNumber,
            UUID licenseTypeId,
            UUID licenseHolderId,
            UUID establishmentId,
            UUID issuerId,
            LocalDate issueDate,
            LocalDate effectiveDate,
            ValidityPeriod validityPeriod,
            String conditions,
            String restrictions,
            String createdBy) {
        
        validateIssueParameters(licenseNumber, licenseTypeId, licenseHolderId, 
                               issuerId, issueDate, effectiveDate, validityPeriod, createdBy);
        
        IssuedLicense license = new IssuedLicense();
        license.id = IssuedLicenseId.generate();
        license.licenseNumber = licenseNumber.trim().toUpperCase();
        license.licenseTypeId = licenseTypeId;
        license.licenseHolderId = licenseHolderId;
        license.establishmentId = establishmentId;
        license.issuerId = issuerId;
        license.status = LicenseStatus.ACTIVE;
        license.issueDate = issueDate;
        license.effectiveDate = effectiveDate;
        license.validityPeriod = validityPeriod;
        license.expiryDate = calculateExpiryDate(effectiveDate, validityPeriod);
        license.isProvisional = true;
        license.conditions = conditions;
        license.restrictions = restrictions;
        license.paymentInfo = PaymentInfo.pending();
        license.auditInfo = AuditInfo.create(createdBy);
        license.version = 1;
        
        // Adicionar evento de domínio
        license.addDomainEvent(new ProvisionalLicenseIssuedEvent(license.id, license.licenseNumber, 
                                                                license.licenseHolderId, license.licenseTypeId));
        
        // Adicionar histórico inicial
        license.addStatusHistory(null, LicenseStatus.ACTIVE, "PROVISIONAL_ISSUE", 
                               "Provisional license issued", createdBy);
        
        return license;
    }
    
    // Métodos de negócio
    public void suspend(String reasonCode, String reasonDescription, String suspendedBy) {
        validateStatusTransition(this.status, LicenseStatus.SUSPENDED);
        
        LicenseStatus previousStatus = this.status;
        this.status = LicenseStatus.SUSPENDED;
        this.auditInfo = this.auditInfo.update(suspendedBy);
        
        addStatusHistory(previousStatus, LicenseStatus.SUSPENDED, reasonCode, reasonDescription, suspendedBy);
        addDomainEvent(new LicenseSuspendedEvent(this.id, this.licenseNumber, reasonCode));
    }
    
    public void reactivate(String reasonDescription, String reactivatedBy) {
        if (this.status != LicenseStatus.SUSPENDED) {
            throw new DomainException("Only suspended licenses can be reactivated");
        }
        
        // Verificar se não está expirada
        if (isExpired()) {
            throw new DomainException("Cannot reactivate expired license");
        }
        
        LicenseStatus previousStatus = this.status;
        this.status = LicenseStatus.ACTIVE;
        this.auditInfo = this.auditInfo.update(reactivatedBy);
        
        addStatusHistory(previousStatus, LicenseStatus.ACTIVE, "REACTIVATION", reasonDescription, reactivatedBy);
        addDomainEvent(new LicenseReactivatedEvent(this.id, this.licenseNumber));
    }
    
    public void cancel(String reasonCode, String reasonDescription, String cancelledBy) {
        validateStatusTransition(this.status, LicenseStatus.CANCELLED);
        
        LicenseStatus previousStatus = this.status;
        this.status = LicenseStatus.CANCELLED;
        this.auditInfo = this.auditInfo.update(cancelledBy);
        
        addStatusHistory(previousStatus, LicenseStatus.CANCELLED, reasonCode, reasonDescription, cancelledBy);
        addDomainEvent(new LicenseCancelledEvent(this.id, this.licenseNumber, reasonCode));
    }
    
    public LicenseRenewal renew(String renewalNumber, LocalDate renewalDate, 
                               LocalDate newExpiryDate, RenewalType renewalType,
                               BigDecimal renewalFees, String processedBy) {
        
        if (this.status != LicenseStatus.ACTIVE && this.status != LicenseStatus.PENDING_RENEWAL) {
            throw new DomainException("Only active or pending renewal licenses can be renewed");
        }
        
        validateRenewalParameters(renewalNumber, renewalDate, newExpiryDate, renewalFees);
        
        // Criar renovação
        LicenseRenewal renewal = LicenseRenewal.create(
            this, renewalNumber, renewalDate, newExpiryDate, 
            renewalType, renewalFees, processedBy);
        
        this.renewals.add(renewal);
        
        // Atualizar data de expiração
        this.expiryDate = newExpiryDate;
        this.status = LicenseStatus.ACTIVE;
        this.auditInfo = this.auditInfo.update(processedBy);
        
        addStatusHistory(this.status, LicenseStatus.ACTIVE, "RENEWAL", 
                        "License renewed until " + newExpiryDate, processedBy);
        addDomainEvent(new LicenseRenewedEvent(this.id, this.licenseNumber, newExpiryDate));
        
        return renewal;
    }
    
    public void updatePaymentInfo(PaymentInfo newPaymentInfo, String updatedBy) {
        if (newPaymentInfo == null) {
            throw new DomainException("Payment information cannot be null");
        }
        
        PaymentInfo previousPaymentInfo = this.paymentInfo;
        this.paymentInfo = newPaymentInfo;
        this.auditInfo = this.auditInfo.update(updatedBy);
        
        addDomainEvent(new LicensePaymentUpdatedEvent(this.id, this.licenseNumber, 
                                                     previousPaymentInfo.getStatus(), 
                                                     newPaymentInfo.getStatus()));
    }
    
    public void addDocument(String documentType, String documentName, String filePath, 
                           String mimeType, Long fileSize, LocalDate expiryDate, 
                           String description, String uploadedBy) {
        
        LicenseDocument document = LicenseDocument.create(
            this, documentType, documentName, filePath, mimeType, 
            fileSize, expiryDate, description, uploadedBy);
        
        this.documents.add(document);
        
        addDomainEvent(new LicenseDocumentAddedEvent(this.id, this.licenseNumber, 
                                                    documentType, documentName));
    }
    
    public void convertToDefinitive(PaymentInfo paymentInfo, String convertedBy) {
        if (!this.isProvisional) {
            throw new DomainException("License is already definitive");
        }
        
        if (paymentInfo == null || paymentInfo.getStatus() != PaymentStatus.PAID) {
            throw new DomainException("Payment must be completed to convert to definitive license");
        }
        
        this.isProvisional = false;
        this.paymentInfo = paymentInfo;
        this.auditInfo = this.auditInfo.update(convertedBy);
        
        addStatusHistory(this.status, this.status, "CONVERSION", 
                        "Converted from provisional to definitive license", convertedBy);
        addDomainEvent(new LicenseConvertedToDefinitiveEvent(this.id, this.licenseNumber));
    }
    
    // Métodos de consulta
    public boolean isActive() {
        return this.status == LicenseStatus.ACTIVE;
    }
    
    public boolean isExpired() {
        return this.expiryDate != null && this.expiryDate.isBefore(LocalDate.now());
    }
    
    public boolean isNearExpiry(int daysBeforeExpiry) {
        if (this.expiryDate == null) {
            return false;
        }
        return this.expiryDate.isBefore(LocalDate.now().plusDays(daysBeforeExpiry));
    }
    
    public boolean canBeRenewed() {
        return (this.status == LicenseStatus.ACTIVE || this.status == LicenseStatus.PENDING_RENEWAL) &&
               !this.isProvisional;
    }
    
    public boolean hasValidPayment() {
        return this.paymentInfo != null && this.paymentInfo.getStatus() == PaymentStatus.PAID;
    }
    
    public List<LicenseDocument> getActiveDocuments() {
        return this.documents.stream()
            .filter(doc -> doc.getStatus() == DocumentStatus.ACTIVE)
            .toList();
    }
    
    public Optional<LicenseRenewal> getLatestRenewal() {
        return this.renewals.stream()
            .max(Comparator.comparing(LicenseRenewal::getRenewalDate));
    }
    
    // Métodos privados de validação
    private static void validateIssueParameters(String licenseNumber, UUID licenseTypeId, 
                                              UUID licenseHolderId, UUID issuerId,
                                              LocalDate issueDate, LocalDate effectiveDate,
                                              ValidityPeriod validityPeriod, String createdBy) {
        if (licenseNumber == null || licenseNumber.trim().isEmpty()) {
            throw new DomainException("License number is required");
        }
        if (licenseTypeId == null) {
            throw new DomainException("License type ID is required");
        }
        if (licenseHolderId == null) {
            throw new DomainException("License holder ID is required");
        }
        if (issuerId == null) {
            throw new DomainException("Issuer ID is required");
        }
        if (issueDate == null) {
            throw new DomainException("Issue date is required");
        }
        if (effectiveDate == null) {
            throw new DomainException("Effective date is required");
        }
        if (effectiveDate.isBefore(issueDate)) {
            throw new DomainException("Effective date cannot be before issue date");
        }
        if (validityPeriod == null) {
            throw new DomainException("Validity period is required");
        }
        if (createdBy == null || createdBy.trim().isEmpty()) {
            throw new DomainException("Created by is required");
        }
    }
    
    private static LocalDate calculateExpiryDate(LocalDate effectiveDate, ValidityPeriod validityPeriod) {
        if (validityPeriod.isIndefinite()) {
            return null;
        }
        
        return switch (validityPeriod.getUnit()) {
            case DAYS -> effectiveDate.plusDays(validityPeriod.getPeriod());
            case MONTHS -> effectiveDate.plusMonths(validityPeriod.getPeriod());
            case YEARS -> effectiveDate.plusYears(validityPeriod.getPeriod());
        };
    }
    
    private void validateStatusTransition(LicenseStatus from, LicenseStatus to) {
        boolean isValidTransition = switch (from) {
            case ACTIVE -> to == LicenseStatus.SUSPENDED || to == LicenseStatus.CANCELLED || 
                          to == LicenseStatus.EXPIRED || to == LicenseStatus.PENDING_RENEWAL;
            case SUSPENDED -> to == LicenseStatus.ACTIVE || to == LicenseStatus.CANCELLED;
            case PENDING_RENEWAL -> to == LicenseStatus.ACTIVE || to == LicenseStatus.EXPIRED || 
                                   to == LicenseStatus.CANCELLED;
            case EXPIRED -> to == LicenseStatus.CANCELLED;
            case CANCELLED -> false; // Licenças canceladas não podem mudar de status
        };
        
        if (!isValidTransition) {
            throw new DomainException(
                String.format("Invalid status transition from %s to %s", from, to));
        }
    }
    
    private void validateRenewalParameters(String renewalNumber, LocalDate renewalDate, 
                                         LocalDate newExpiryDate, BigDecimal renewalFees) {
        if (renewalNumber == null || renewalNumber.trim().isEmpty()) {
            throw new DomainException("Renewal number is required");
        }
        if (renewalDate == null) {
            throw new DomainException("Renewal date is required");
        }
        if (newExpiryDate == null) {
            throw new DomainException("New expiry date is required");
        }
        if (newExpiryDate.isBefore(renewalDate)) {
            throw new DomainException("New expiry date cannot be before renewal date");
        }
        if (renewalFees != null && renewalFees.compareTo(BigDecimal.ZERO) < 0) {
            throw new DomainException("Renewal fees cannot be negative");
        }
    }
    
    private void addStatusHistory(LicenseStatus previousStatus, LicenseStatus newStatus, 
                                 String reasonCode, String reasonDescription, String changedBy) {
        LicenseStatusHistory history = LicenseStatusHistory.create(
            this, previousStatus, newStatus, reasonCode, reasonDescription, changedBy);
        this.statusHistory.add(history);
    }
    
    // Getters
    public IssuedLicenseId getId() { return id; }
    public String getLicenseNumber() { return licenseNumber; }
    public UUID getLicenseTypeId() { return licenseTypeId; }
    public UUID getLicenseHolderId() { return licenseHolderId; }
    public UUID getEstablishmentId() { return establishmentId; }
    public UUID getIssuerId() { return issuerId; }
    public LicenseStatus getStatus() { return status; }
    public LocalDate getIssueDate() { return issueDate; }
    public LocalDate getExpiryDate() { return expiryDate; }
    public LocalDate getEffectiveDate() { return effectiveDate; }
    public ValidityPeriod getValidityPeriod() { return validityPeriod; }
    public boolean isProvisional() { return isProvisional; }
    public String getConditions() { return conditions; }
    public String getRestrictions() { return restrictions; }
    public PaymentInfo getPaymentInfo() { return paymentInfo; }
    public String getNotes() { return notes; }
    public AuditInfo getAuditInfo() { return auditInfo; }
    public Integer getVersion() { return version; }
    public List<LicenseStatusHistory> getStatusHistory() { return Collections.unmodifiableList(statusHistory); }
    public List<LicenseRenewal> getRenewals() { return Collections.unmodifiableList(renewals); }
    public List<LicenseDocument> getDocuments() { return Collections.unmodifiableList(documents); }
}
```

