# PR02.04 - Backend Licenciamento - Gestão de Emissores de Licenças

## 1. Visão Geral

### 1.1 Objetivos

Este módulo é responsável pela gestão completa dos emissores de licenças no sistema de licenciamento de Cabo Verde, incluindo:

* **Modelo de dados** **`T_LICENSE_ISSUER`**: Estrutura principal para armazenamento de emissores

* **Arquitetura DDD**: Implementação seguindo Domain-Driven Design com Aggregate Root, Value Objects e Domain Services

* **APIs REST**: Endpoints para criação, consulta, atualização e gestão de emissores

* **Validações de negócio**: Regras para credenciamento, competências e jurisdições

* **Gestão de competências**: Controle de tipos de licenças que cada emissor pode emitir

* **Controle de jurisdição**: Definição de áreas geográficas de atuação dos emissores

### 1.2 Diagrama ER

```mermaid
erDiagram
    T_LICENSE_ISSUER {
        uuid id PK
        varchar issuer_code UK
        varchar issuer_name
        varchar issuer_type
        varchar organization_level
        varchar jurisdiction_type
        text jurisdiction_description
        varchar contact_person
        varchar contact_email
        varchar contact_phone
        text address
        varchar issuer_status
        date accreditation_date
        date accreditation_expiry
        varchar accreditation_authority
        text notes
        varchar created_by
        timestamp created_date
        varchar last_modified_by
        timestamp last_modified_date
        integer version
    }
    
    T_ISSUER_COMPETENCE {
        uuid id PK
        uuid issuer_id_fk FK
        uuid license_type_id_fk FK
        varchar competence_level
        date valid_from
        date valid_until
        varchar granted_by
        timestamp granted_at
        text competence_notes
        varchar competence_status
    }
    
    T_ISSUER_JURISDICTION {
        uuid id PK
        uuid issuer_id_fk FK
        varchar jurisdiction_code
        varchar jurisdiction_name
        varchar jurisdiction_level
        varchar geographic_scope
        text geographic_description
        date valid_from
        date valid_until
        varchar jurisdiction_status
    }
    
    T_ISSUER_DELEGATION {
        uuid id PK
        uuid delegating_issuer_id_fk FK
        uuid delegate_issuer_id_fk FK
        varchar delegation_type
        text delegation_scope
        date delegation_start
        date delegation_end
        varchar delegation_status
        varchar authorized_by
        timestamp authorized_at
        text delegation_notes
    }
    
    T_LICENSE_ISSUER ||--o{ T_ISSUER_COMPETENCE : has
    T_LICENSE_ISSUER ||--o{ T_ISSUER_JURISDICTION : has
    T_LICENSE_ISSUER ||--o{ T_ISSUER_DELEGATION : delegates_to
    T_LICENSE_ISSUER ||--o{ T_ISSUER_DELEGATION : receives_from
```

## 2. Modelo de Dados

### 2.1 Definição das Tabelas

#### 2.1.1 Tabela T\_LICENSE\_ISSUER

```sql
CREATE TABLE t_license_issuer (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    issuer_code VARCHAR(20) UNIQUE NOT NULL,
    issuer_name VARCHAR(255) NOT NULL,
    issuer_type VARCHAR(30) NOT NULL 
        CHECK (issuer_type IN ('GOVERNMENT_AGENCY', 'MUNICIPAL_AUTHORITY', 'REGULATORY_BODY', 'DELEGATED_ENTITY')),
    organization_level VARCHAR(20) NOT NULL 
        CHECK (organization_level IN ('NATIONAL', 'REGIONAL', 'MUNICIPAL', 'LOCAL')),
    jurisdiction_type VARCHAR(30) NOT NULL 
        CHECK (jurisdiction_type IN ('TERRITORIAL', 'SECTORAL', 'FUNCTIONAL', 'MIXED')),
    jurisdiction_description TEXT,
    contact_person VARCHAR(255),
    contact_email VARCHAR(255),
    contact_phone VARCHAR(50),
    address TEXT,
    issuer_status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE' 
        CHECK (issuer_status IN ('ACTIVE', 'INACTIVE', 'SUSPENDED', 'REVOKED')),
    accreditation_date DATE,
    accreditation_expiry DATE,
    accreditation_authority VARCHAR(255),
    notes TEXT,
    created_by VARCHAR(100) NOT NULL,
    created_date TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    last_modified_by VARCHAR(100),
    last_modified_date TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    version INTEGER DEFAULT 1
);
```

#### 2.1.2 Tabela T\_ISSUER\_COMPETENCE

```sql
CREATE TABLE t_issuer_competence (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    issuer_id_fk UUID NOT NULL REFERENCES t_license_issuer(id) ON DELETE CASCADE,
    license_type_id_fk UUID NOT NULL,
    competence_level VARCHAR(20) NOT NULL DEFAULT 'FULL' 
        CHECK (competence_level IN ('FULL', 'LIMITED', 'CONDITIONAL', 'TEMPORARY')),
    valid_from DATE NOT NULL,
    valid_until DATE,
    granted_by VARCHAR(100) NOT NULL,
    granted_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    competence_notes TEXT,
    competence_status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE' 
        CHECK (competence_status IN ('ACTIVE', 'SUSPENDED', 'REVOKED', 'EXPIRED'))
);
```

#### 2.1.3 Tabela T\_ISSUER\_JURISDICTION

```sql
CREATE TABLE t_issuer_jurisdiction (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    issuer_id_fk UUID NOT NULL REFERENCES t_license_issuer(id) ON DELETE CASCADE,
    jurisdiction_code VARCHAR(20) NOT NULL,
    jurisdiction_name VARCHAR(255) NOT NULL,
    jurisdiction_level VARCHAR(20) NOT NULL 
        CHECK (jurisdiction_level IN ('NATIONAL', 'REGIONAL', 'MUNICIPAL', 'DISTRICT', 'NEIGHBORHOOD')),
    geographic_scope VARCHAR(30) NOT NULL 
        CHECK (geographic_scope IN ('ISLAND', 'MUNICIPALITY', 'PARISH', 'DISTRICT', 'ZONE', 'CUSTOM')),
    geographic_description TEXT,
    valid_from DATE NOT NULL,
    valid_until DATE,
    jurisdiction_status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE' 
        CHECK (jurisdiction_status IN ('ACTIVE', 'SUSPENDED', 'REVOKED', 'EXPIRED'))
);
```

#### 2.1.4 Tabela T\_ISSUER\_DELEGATION

```sql
CREATE TABLE t_issuer_delegation (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    delegating_issuer_id_fk UUID NOT NULL REFERENCES t_license_issuer(id),
    delegate_issuer_id_fk UUID NOT NULL REFERENCES t_license_issuer(id),
    delegation_type VARCHAR(30) NOT NULL 
        CHECK (delegation_type IN ('FULL_DELEGATION', 'PARTIAL_DELEGATION', 'TEMPORARY_DELEGATION', 'EMERGENCY_DELEGATION')),
    delegation_scope TEXT NOT NULL,
    delegation_start DATE NOT NULL,
    delegation_end DATE,
    delegation_status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE' 
        CHECK (delegation_status IN ('ACTIVE', 'SUSPENDED', 'REVOKED', 'EXPIRED')),
    authorized_by VARCHAR(100) NOT NULL,
    authorized_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    delegation_notes TEXT,
    
    CONSTRAINT chk_different_issuers CHECK (delegating_issuer_id_fk != delegate_issuer_id_fk)
);
```

### 2.2 Índices de Performance

```sql
-- Índices para T_LICENSE_ISSUER
CREATE INDEX idx_license_issuer_code ON t_license_issuer(issuer_code);
CREATE INDEX idx_license_issuer_name ON t_license_issuer(issuer_name);
CREATE INDEX idx_license_issuer_type ON t_license_issuer(issuer_type);
CREATE INDEX idx_license_issuer_status ON t_license_issuer(issuer_status);
CREATE INDEX idx_license_issuer_organization_level ON t_license_issuer(organization_level);
CREATE INDEX idx_license_issuer_jurisdiction_type ON t_license_issuer(jurisdiction_type);
CREATE INDEX idx_license_issuer_accreditation_expiry ON t_license_issuer(accreditation_expiry);
CREATE INDEX idx_license_issuer_created_date ON t_license_issuer(created_date DESC);

-- Índices para T_ISSUER_COMPETENCE
CREATE INDEX idx_issuer_competence_issuer ON t_issuer_competence(issuer_id_fk);
CREATE INDEX idx_issuer_competence_license_type ON t_issuer_competence(license_type_id_fk);
CREATE INDEX idx_issuer_competence_status ON t_issuer_competence(competence_status);
CREATE INDEX idx_issuer_competence_valid_from ON t_issuer_competence(valid_from);
CREATE INDEX idx_issuer_competence_valid_until ON t_issuer_competence(valid_until);
CREATE UNIQUE INDEX idx_issuer_competence_unique ON t_issuer_competence(issuer_id_fk, license_type_id_fk) 
    WHERE competence_status = 'ACTIVE';

-- Índices para T_ISSUER_JURISDICTION
CREATE INDEX idx_issuer_jurisdiction_issuer ON t_issuer_jurisdiction(issuer_id_fk);
CREATE INDEX idx_issuer_jurisdiction_code ON t_issuer_jurisdiction(jurisdiction_code);
CREATE INDEX idx_issuer_jurisdiction_level ON t_issuer_jurisdiction(jurisdiction_level);
CREATE INDEX idx_issuer_jurisdiction_scope ON t_issuer_jurisdiction(geographic_scope);
CREATE INDEX idx_issuer_jurisdiction_status ON t_issuer_jurisdiction(jurisdiction_status);
CREATE INDEX idx_issuer_jurisdiction_valid_from ON t_issuer_jurisdiction(valid_from);
CREATE INDEX idx_issuer_jurisdiction_valid_until ON t_issuer_jurisdiction(valid_until);

-- Índices para T_ISSUER_DELEGATION
CREATE INDEX idx_issuer_delegation_delegating ON t_issuer_delegation(delegating_issuer_id_fk);
CREATE INDEX idx_issuer_delegation_delegate ON t_issuer_delegation(delegate_issuer_id_fk);
CREATE INDEX idx_issuer_delegation_type ON t_issuer_delegation(delegation_type);
CREATE INDEX idx_issuer_delegation_status ON t_issuer_delegation(delegation_status);
CREATE INDEX idx_issuer_delegation_start ON t_issuer_delegation(delegation_start);
CREATE INDEX idx_issuer_delegation_end ON t_issuer_delegation(delegation_end);
```

## 3. Arquitetura DDD

### 3.1 Aggregate Root

#### 3.1.1 LicenseIssuer

```java
@Entity
@Table(name = "t_license_issuer")
public class LicenseIssuer extends AggregateRoot<LicenseIssuerId> {
    
    @EmbeddedId
    private LicenseIssuerId id;
    
    @Column(name = "issuer_code", unique = true, nullable = false)
    private String issuerCode;
    
    @Column(name = "issuer_name", nullable = false)
    private String issuerName;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "issuer_type", nullable = false)
    private IssuerType issuerType;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "organization_level", nullable = false)
    private OrganizationLevel organizationLevel;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "jurisdiction_type", nullable = false)
    private JurisdictionType jurisdictionType;
    
    @Column(name = "jurisdiction_description")
    private String jurisdictionDescription;
    
    @Embedded
    @AttributeOverrides({
        @AttributeOverride(name = "contactPerson", column = @Column(name = "contact_person")),
        @AttributeOverride(name = "email", column = @Column(name = "contact_email")),
        @AttributeOverride(name = "phone", column = @Column(name = "contact_phone")),
        @AttributeOverride(name = "address", column = @Column(name = "address"))
    })
    private IssuerContactInfo contactInfo;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "issuer_status", nullable = false)
    private IssuerStatus status;
    
    @Embedded
    @AttributeOverrides({
        @AttributeOverride(name = "accreditationDate", column = @Column(name = "accreditation_date")),
        @AttributeOverride(name = "expiryDate", column = @Column(name = "accreditation_expiry")),
        @AttributeOverride(name = "authority", column = @Column(name = "accreditation_authority"))
    })
    private AccreditationInfo accreditationInfo;
    
    @Column(name = "notes")
    private String notes;
    
    @Embedded
    private AuditInfo auditInfo;
    
    @Version
    @Column(name = "version")
    private Integer version;
    
    @OneToMany(mappedBy = "issuer", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<IssuerCompetence> competences = new ArrayList<>();
    
    @OneToMany(mappedBy = "issuer", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<IssuerJurisdiction> jurisdictions = new ArrayList<>();
    
    @OneToMany(mappedBy = "delegatingIssuer", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<IssuerDelegation> outgoingDelegations = new ArrayList<>();
    
    @OneToMany(mappedBy = "delegateIssuer", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<IssuerDelegation> incomingDelegations = new ArrayList<>();
    
    protected LicenseIssuer() {}
    
    // Método de criação
    public static LicenseIssuer create(
            String issuerCode,
            String issuerName,
            IssuerType issuerType,
            OrganizationLevel organizationLevel,
            JurisdictionType jurisdictionType,
            String jurisdictionDescription,
            IssuerContactInfo contactInfo,
            AccreditationInfo accreditationInfo,
            String notes,
            String createdBy) {
        
        validateCreationParameters(issuerCode, issuerName, issuerType, 
                                 organizationLevel, jurisdictionType, createdBy);
        
        LicenseIssuer issuer = new LicenseIssuer();
        issuer.id = LicenseIssuerId.generate();
        issuer.issuerCode = issuerCode.trim().toUpperCase();
        issuer.issuerName = issuerName.trim();
        issuer.issuerType = issuerType;
        issuer.organizationLevel = organizationLevel;
        issuer.jurisdictionType = jurisdictionType;
        issuer.jurisdictionDescription = jurisdictionDescription;
        issuer.contactInfo = contactInfo;
        issuer.status = IssuerStatus.ACTIVE;
        issuer.accreditationInfo = accreditationInfo;
        issuer.notes = notes;
        issuer.auditInfo = AuditInfo.create(createdBy);
        issuer.version = 1;
        
        // Adicionar evento de domínio
        issuer.addDomainEvent(new LicenseIssuerCreatedEvent(issuer.id, issuer.issuerCode, issuer.issuerName));
        
        return issuer;
    }
    
    // Métodos de negócio
    public void updateContactInfo(IssuerContactInfo newContactInfo, String updatedBy) {
        if (newContactInfo == null) {
            throw new DomainException("Contact information cannot be null");
        }
        
        this.contactInfo = newContactInfo;
        this.auditInfo = this.auditInfo.update(updatedBy);
        
        addDomainEvent(new IssuerContactInfoUpdatedEvent(this.id, this.issuerCode));
    }
    
    public void updateAccreditation(AccreditationInfo newAccreditationInfo, String updatedBy) {
        if (newAccreditationInfo == null) {
            throw new DomainException("Accreditation information cannot be null");
        }
        
        AccreditationInfo previousAccreditation = this.accreditationInfo;
        this.accreditationInfo = newAccreditationInfo;
        this.auditInfo = this.auditInfo.update(updatedBy);
        
        addDomainEvent(new IssuerAccreditationUpdatedEvent(this.id, this.issuerCode, 
                                                          previousAccreditation, newAccreditationInfo));
    }
    
    public void suspend(String reason, String suspendedBy) {
        if (this.status == IssuerStatus.SUSPENDED) {
            throw new DomainException("Issuer is already suspended");
        }
        if (this.status == IssuerStatus.REVOKED) {
            throw new DomainException("Cannot suspend revoked issuer");
        }
        
        IssuerStatus previousStatus = this.status;
        this.status = IssuerStatus.SUSPENDED;
        this.auditInfo = this.auditInfo.update(suspendedBy);
        
        // Suspender todas as competências ativas
        this.competences.stream()
            .filter(comp -> comp.getStatus() == CompetenceStatus.ACTIVE)
            .forEach(comp -> comp.suspend("ISSUER_SUSPENDED", suspendedBy));
        
        addDomainEvent(new IssuerSuspendedEvent(this.id, this.issuerCode, reason));
    }
    
    public void reactivate(String reason, String reactivatedBy) {
        if (this.status != IssuerStatus.SUSPENDED) {
            throw new DomainException("Only suspended issuers can be reactivated");
        }
        
        // Verificar se a acreditação ainda é válida
        if (this.accreditationInfo != null && this.accreditationInfo.isExpired()) {
            throw new DomainException("Cannot reactivate issuer with expired accreditation");
        }
        
        this.status = IssuerStatus.ACTIVE;
        this.auditInfo = this.auditInfo.update(reactivatedBy);
        
        addDomainEvent(new IssuerReactivatedEvent(this.id, this.issuerCode, reason));
    }
    
    public void revoke(String reason, String revokedBy) {
        if (this.status == IssuerStatus.REVOKED) {
            throw new DomainException("Issuer is already revoked");
        }
        
        this.status = IssuerStatus.REVOKED;
        this.auditInfo = this.auditInfo.update(revokedBy);
        
        // Revogar todas as competências ativas
        this.competences.stream()
            .filter(comp -> comp.getStatus() == CompetenceStatus.ACTIVE || 
                           comp.getStatus() == CompetenceStatus.SUSPENDED)
            .forEach(comp -> comp.revoke("ISSUER_REVOKED", revokedBy));
        
        // Revogar todas as delegações ativas
        this.outgoingDelegations.stream()
            .filter(del -> del.getStatus() == DelegationStatus.ACTIVE)
            .forEach(del -> del.revoke("ISSUER_REVOKED", revokedBy));
        
        addDomainEvent(new IssuerRevokedEvent(this.id, this.issuerCode, reason));
    }
    
    public IssuerCompetence grantCompetence(
            UUID licenseTypeId,
            CompetenceLevel competenceLevel,
            LocalDate validFrom,
            LocalDate validUntil,
            String competenceNotes,
            String grantedBy) {
        
        validateCompetenceGrant(licenseTypeId, competenceLevel, validFrom, validUntil, grantedBy);
        
        // Verificar se já existe competência ativa para este tipo de licença
        boolean hasActiveCompetence = this.competences.stream()
            .anyMatch(comp -> comp.getLicenseTypeId().equals(licenseTypeId) &&
                             comp.getStatus() == CompetenceStatus.ACTIVE);
        
        if (hasActiveCompetence) {
            throw new DomainException(
                "Active competence for this license type already exists");
        }
        
        IssuerCompetence competence = IssuerCompetence.create(
            this, licenseTypeId, competenceLevel, validFrom, validUntil, 
            competenceNotes, grantedBy);
        
        this.competences.add(competence);
        
        addDomainEvent(new IssuerCompetenceGrantedEvent(this.id, this.issuerCode, 
                                                       licenseTypeId, competenceLevel));
        
        return competence;
    }
    
    public IssuerJurisdiction addJurisdiction(
            String jurisdictionCode,
            String jurisdictionName,
            JurisdictionLevel jurisdictionLevel,
            GeographicScope geographicScope,
            String geographicDescription,
            LocalDate validFrom,
            LocalDate validUntil) {
        
        validateJurisdictionAddition(jurisdictionCode, jurisdictionName, 
                                   jurisdictionLevel, geographicScope, validFrom);
        
        // Verificar se já existe jurisdição ativa com o mesmo código
        boolean hasActiveJurisdiction = this.jurisdictions.stream()
            .anyMatch(jur -> jur.getJurisdictionCode().equals(jurisdictionCode) &&
                            jur.getStatus() == JurisdictionStatus.ACTIVE);
        
        if (hasActiveJurisdiction) {
            throw new DomainException(
                "Active jurisdiction with this code already exists");
        }
        
        IssuerJurisdiction jurisdiction = IssuerJurisdiction.create(
            this, jurisdictionCode, jurisdictionName, jurisdictionLevel, 
            geographicScope, geographicDescription, validFrom, validUntil);
        
        this.jurisdictions.add(jurisdiction);
        
        addDomainEvent(new IssuerJurisdictionAddedEvent(this.id, this.issuerCode, 
                                                       jurisdictionCode, jurisdictionName));
        
        return jurisdiction;
    }
    
    public IssuerDelegation delegateTo(
            LicenseIssuer delegateIssuer,
            DelegationType delegationType,
            String delegationScope,
            LocalDate delegationStart,
            LocalDate delegationEnd,
            String delegationNotes,
            String authorizedBy) {
        
        validateDelegation(delegateIssuer, delegationType, delegationScope, 
                          delegationStart, delegationEnd, authorizedBy);
        
        IssuerDelegation delegation = IssuerDelegation.create(
            this, delegateIssuer, delegationType, delegationScope, 
            delegationStart, delegationEnd, delegationNotes, authorizedBy);
        
        this.outgoingDelegations.add(delegation);
        delegateIssuer.incomingDelegations.add(delegation);
        
        addDomainEvent(new IssuerDelegationCreatedEvent(this.id, delegateIssuer.getId(), 
                                                       delegationType, delegationScope));
        
        return delegation;
    }
    
    // Métodos de consulta
    public boolean isActive() {
        return this.status == IssuerStatus.ACTIVE;
    }
    
    public boolean hasValidAccreditation() {
        return this.accreditationInfo != null && !this.accreditationInfo.isExpired();
    }
    
    public boolean canIssue(UUID licenseTypeId) {
        if (!isActive() || !hasValidAccreditation()) {
            return false;
        }
        
        return hasActiveCompetenceFor(licenseTypeId);
    }
    
    public boolean hasActiveCompetenceFor(UUID licenseTypeId) {
        return this.competences.stream()
            .anyMatch(comp -> comp.getLicenseTypeId().equals(licenseTypeId) &&
                             comp.getStatus() == CompetenceStatus.ACTIVE &&
                             comp.isValidAt(LocalDate.now()));
    }
    
    public boolean hasJurisdictionOver(String jurisdictionCode) {
        return this.jurisdictions.stream()
            .anyMatch(jur -> jur.getJurisdictionCode().equals(jurisdictionCode) &&
                            jur.getStatus() == JurisdictionStatus.ACTIVE &&
                            jur.isValidAt(LocalDate.now()));
    }
    
    public List<IssuerCompetence> getActiveCompetences() {
        return this.competences.stream()
            .filter(comp -> comp.getStatus() == CompetenceStatus.ACTIVE &&
                           comp.isValidAt(LocalDate.now()))
            .toList();
    }
    
    public List<IssuerJurisdiction> getActiveJurisdictions() {
        return this.jurisdictions.stream()
            .filter(jur -> jur.getStatus() == JurisdictionStatus.ACTIVE &&
                          jur.isValidAt(LocalDate.now()))
            .toList();
    }
    
    public List<IssuerDelegation> getActiveDelegations() {
        return this.outgoingDelegations.stream()
            .filter(del -> del.getStatus() == DelegationStatus.ACTIVE &&
                          del.isValidAt(LocalDate.now()))
            .toList();
    }
    
    public List<UUID> getAuthorizedLicenseTypes() {
        return getActiveCompetences().stream()
            .map(IssuerCompetence::getLicenseTypeId)
            .distinct()
            .toList();
    }
    
    // Métodos privados de validação
    private static void validateCreationParameters(
            String issuerCode, String issuerName, IssuerType issuerType,
            OrganizationLevel organizationLevel, JurisdictionType jurisdictionType,
            String createdBy) {
        
        if (issuerCode == null || issuerCode.trim().isEmpty()) {
            throw new DomainException("Issuer code is required");
        }
        if (issuerName == null || issuerName.trim().isEmpty()) {
            throw new DomainException("Issuer name is required");
        }
        if (issuerType == null) {
            throw new DomainException("Issuer type is required");
        }
        if (organizationLevel == null) {
            throw new DomainException("Organization level is required");
        }
        if (jurisdictionType == null) {
            throw new DomainException("Jurisdiction type is required");
        }
        if (createdBy == null || createdBy.trim().isEmpty()) {
            throw new DomainException("Created by is required");
        }
    }
    
    private void validateCompetenceGrant(
            UUID licenseTypeId, CompetenceLevel competenceLevel,
            LocalDate validFrom, LocalDate validUntil, String grantedBy) {
        
        if (licenseTypeId == null) {
            throw new DomainException("License type ID is required");
        }
        if (competenceLevel == null) {
            throw new DomainException("Competence level is required");
        }
        if (validFrom == null) {
            throw new DomainException("Valid from date is required");
        }
        if (validUntil != null && validUntil.isBefore(validFrom)) {
            throw new DomainException("Valid until date cannot be before valid from date");
        }
        if (grantedBy == null || grantedBy.trim().isEmpty()) {
            throw new DomainException("Granted by is required");
        }
        
        if (!isActive()) {
            throw new DomainException("Cannot grant competence to inactive issuer");
        }
    }
    
    private void validateJurisdictionAddition(
            String jurisdictionCode, String jurisdictionName,
            JurisdictionLevel jurisdictionLevel, GeographicScope geographicScope,
            LocalDate validFrom) {
        
        if (jurisdictionCode == null || jurisdictionCode.trim().isEmpty()) {
            throw new DomainException("Jurisdiction code is required");
        }
        if (jurisdictionName == null || jurisdictionName.trim().isEmpty()) {
            throw new DomainException("Jurisdiction name is required");
        }
        if (jurisdictionLevel == null) {
            throw new DomainException("Jurisdiction level is required");
        }
        if (geographicScope == null) {
            throw new DomainException("Geographic scope is required");
        }
        if (validFrom == null) {
            throw new DomainException("Valid from date is required");
        }
    }
    
    private void validateDelegation(
            LicenseIssuer delegateIssuer, DelegationType delegationType,
            String delegationScope, LocalDate delegationStart,
            LocalDate delegationEnd, String authorizedBy) {
        
        if (delegateIssuer == null) {
            throw new DomainException("Delegate issuer is required");
        }
        if (delegateIssuer.getId().equals(this.id)) {
            throw new DomainException("Cannot delegate to self");
        }
        if (delegationType == null) {
            throw new DomainException("Delegation type is required");
        }
        if (delegationScope == null || delegationScope.trim().isEmpty()) {
            throw new DomainException("Delegation scope is required");
        }
        if (delegationStart == null) {
            throw new DomainException("Delegation start date is required");
        }
        if (delegationEnd != null && delegationEnd.isBefore(delegationStart)) {
            throw new DomainException("Delegation end date cannot be before start date");
        }
        if (authorizedBy == null || authorizedBy.trim().isEmpty()) {
            throw new DomainException("Authorized by is required");
        }
        
        if (!isActive()) {
            throw new DomainException("Cannot create delegation from inactive issuer");
        }
        if (!delegateIssuer.isActive()) {
            throw new DomainException("Cannot delegate to inactive issuer");
        }
    }
    
    // Getters
    public LicenseIssuerId getId() { return id; }
    public String getIssuerCode() { return issuerCode; }
    public String getIssuerName() { return issuerName; }
    public IssuerType getIssuerType() { return issuerType; }
    public OrganizationLevel getOrganizationLevel() { return organizationLevel; }
    public JurisdictionType getJurisdictionType() { return jurisdictionType; }
    public String getJurisdictionDescription() { return jurisdictionDescription; }
    public IssuerContactInfo getContactInfo() { return contactInfo; }
    public IssuerStatus getStatus() { return status; }
    public AccreditationInfo getAccreditationInfo() { return accreditationInfo; }
    public String getNotes() { return notes; }
    public AuditInfo getAuditInfo() { return auditInfo; }
    public Integer getVersion() { return version; }
    public List<IssuerCompetence> getCompetences() { return Collections.unmodifiableList(competences); }
    public List<IssuerJurisdiction> getJurisdictions() { return Collections.unmodifiableList(jurisdictions); }
    public List<IssuerDelegation> getOutgoingDelegations() { return Collections.unmodifiableList(outgoingDelegations); }
    public List<IssuerDelegation> getIncomingDelegations() { return Collections.unmodifiableList(incomingDelegations); }
}
```

### 3.2 Value Objects

#### 3.2.1 LicenseIssuerId

```java
@Embeddable
public class LicenseIssuerId implements Serializable {
    
    @Column(name = "id")
    private UUID value;
    
    protected LicenseIssuerId() {}
    
    private LicenseIssuerId(UUID value) {
        if (value == null) {
            throw new IllegalArgumentException("LicenseIssuerId cannot be null");
        }
        this.value = value;
    }
    
    public static LicenseIssuerId of(UUID value) {
        return new LicenseIssuerId(value);
    }
    
    public static LicenseIssuerId of(String value) {
        try {
            return new LicenseIssuerId(UUID.fromString(value));
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Invalid LicenseIssuerId format: " + value);
        }
    }
    
    public static LicenseIssuerId generate() {
        return new LicenseIssuerId(UUID.randomUUID());
    }
    
    public UUID getValue() { return value; }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        LicenseIssuerId that = (LicenseIssuerId) o;
        return Objects.equals(value, that.value);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }
    
    @Override
    public String toString() {
        return value.toString();
    }
}
```

#### 3.2.2 IssuerContactInfo

```java
@Embeddable
public class IssuerContactInfo {
    
    @Column(name = "contact_person")
    private String contactPerson;
    
    @Column(name = "contact_email")
    private String email;
    
    @Column(name = "contact_phone")
    private String phone;
    
    @Column(name = "address")
    private String address;
    
    protected IssuerContactInfo() {}
    
    private IssuerContactInfo(String contactPerson, String email, String phone, String address) {
        this.contactPerson = contactPerson;
        this.email = email;
        this.phone = phone;
        this.address = address;
    }
    
    public static IssuerContactInfo of(String contactPerson, String email, String phone, String address) {
        validateContactInfo(contactPerson, email, phone, address);
        return new IssuerContactInfo(contactPerson, email, phone, address);
    }
    
    private static void validateContactInfo(String contactPerson, String email, String phone, String address) {
        if (email != null && !email.trim().isEmpty() && !isValidEmail(email)) {
            throw new IllegalArgumentException("Invalid email format");
        }
        if (phone != null && !phone.trim().isEmpty() && !isValidPhone(phone)) {
            throw new IllegalArgumentException("Invalid phone format");
        }
    }
    
    private static boolean isValidEmail(String email) {
        return email.matches("^[A-Za-z0-9+_.-]+@([A-Za-z0-9.-]+\\.[A-Za-z]{2,})$");
    }
    
    private static boolean isValidPhone(String phone) {
        return phone.matches("^[+]?[0-9\\s\\-\\(\\)]{7,20}$");
    }
    
    public boolean hasContactPerson() {
        return contactPerson != null && !contactPerson.trim().isEmpty();
    }
    
    public boolean hasEmail() {
        return email != null && !email.trim().isEmpty();
    }
    
    public boolean hasPhone() {
        return phone != null && !phone.trim().isEmpty();
    }
    
    public boolean hasAddress() {
        return address != null && !address.trim().isEmpty();
    }
    
    // Getters
    public String getContactPerson() { return contactPerson; }
    public String getEmail() { return email; }
    public String getPhone() { return phone; }
    public String getAddress() { return address; }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        IssuerContactInfo that = (IssuerContactInfo) o;
        return Objects.equals(contactPerson, that.contactPerson) &&
               Objects.equals(email, that.email) &&
               Objects.equals(phone, that.phone) &&
               Objects.equals(address, that.address);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(contactPerson, email, phone, address);
    }
}
```

#### 3.2.3 AccreditationInfo

```java
@Embeddable
public class AccreditationInfo {
    
    @Column(name = "accreditation_date")
    private LocalDate accreditationDate;
    
    @Column(name = "accreditation_expiry")
    private LocalDate expiryDate;
    
    @Column(name = "accreditation_authority")
    private String authority;
    
    protected AccreditationInfo() {}
    
    private AccreditationInfo(LocalDate accreditationDate, LocalDate expiryDate, String authority) {
        this.accreditationDate = accreditationDate;
        this.expiryDate = expiryDate;
        this.authority = authority;
    }
    
    public static AccreditationInfo of(LocalDate accreditationDate, LocalDate expiryDate, String authority) {
        validateAccreditationInfo(accreditationDate, expiryDate, authority);
        return new AccreditationInfo(accreditationDate, expiryDate, authority);
    }
    
    private static void validateAccreditationInfo(LocalDate accreditationDate, LocalDate expiryDate, String authority) {
        if (accreditationDate == null) {
            throw new IllegalArgumentException("Accreditation date is required");
        }
        if (expiryDate != null && expiryDate.isBefore(accreditationDate)) {
            throw new IllegalArgumentException("Expiry date cannot be before accreditation date");
        }
        if (authority == null || authority.trim().isEmpty()) {
            throw new IllegalArgumentException("Accreditation authority is required");
        }
    }
    
    public boolean isExpired() {
        return expiryDate != null && LocalDate.now().isAfter(expiryDate);
    }
    
    public boolean isExpiredAt(LocalDate date) {
        return expiryDate != null && date.isAfter(expiryDate);
    }
    
    public boolean isValidAt(LocalDate date) {
        return !date.isBefore(accreditationDate) && 
               (expiryDate == null || !date.isAfter(expiryDate));
    }
    
    public long getDaysUntilExpiry() {
        if (expiryDate == null) {
            return Long.MAX_VALUE;
        }
        return ChronoUnit.DAYS.between(LocalDate.now(), expiryDate);
    }
    
    // Getters
    public LocalDate getAccreditationDate() { return accreditationDate; }
    public LocalDate getExpiryDate() { return expiryDate; }
    public String getAuthority() { return authority; }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        AccreditationInfo that = (AccreditationInfo) o;
        return Objects.equals(accreditationDate, that.accreditationDate) &&
               Objects.equals(expiryDate, that.expiryDate) &&
               Objects.equals(authority, that.authority);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(accreditationDate, expiryDate, authority);
    }
}
```

### 3.3 Enums

#### 3.3.1 IssuerType

```java
public enum IssuerType {
    GOVERNMENT_AGENCY("Government Agency", "Órgão Governamental"),
    MUNICIPAL_AUTHORITY("Municipal Authority", "Autoridade Municipal"),
    REGULATORY_BODY("Regulatory Body", "Órgão Regulador"),
    DELEGATED_ENTITY("Delegated Entity", "Entidade Delegada");
    
    private final String displayName;
    private final String displayNamePt;
    
    IssuerType(String displayName, String displayNamePt) {
        this.displayName = displayName;
        this.displayNamePt = displayNamePt;
    }
    
    public String getDisplayName() { return displayName; }
    public String getDisplayNamePt() { return displayNamePt; }
}
```

#### 3.3.2 OrganizationLevel

```java
public enum OrganizationLevel {
    NATIONAL("National", "Nacional"),
    REGIONAL("Regional", "Regional"),
    MUNICIPAL("Municipal", "Municipal"),
    LOCAL("Local", "Local");
    
    private final String displayName;
    private final String displayNamePt;
    
    OrganizationLevel(String displayName, String displayNamePt) {
        this.displayName = displayName;
        this.displayNamePt = displayNamePt;
    }
    
    public String getDisplayName() { return displayName; }
    public String getDisplayNamePt() { return displayNamePt; }
}
```

#### 3.3.3 JurisdictionType

```java
public enum JurisdictionType {
    TERRITORIAL("Territorial", "Territorial"),
    SECTORAL("Sectoral", "Setorial"),
    FUNCTIONAL("Functional", "Funcional"),
    MIXED("Mixed", "Mista");
    
    private final String displayName;
    private final String displayNamePt;
    
    JurisdictionType(String displayName, String displayNamePt) {
        this.displayName = displayName;
        this.displayNamePt = displayNamePt;
    }
    
    public String getDisplayName() { return displayName; }
    public String getDisplayNamePt() { return displayNamePt; }
}
```

#### 3.3.4 IssuerStatus

```java
public enum IssuerStatus {
    ACTIVE("Active", "Ativo"),
    INACTIVE("Inactive", "Inativo"),
    SUSPENDED("Suspended", "Suspenso"),
    REVOKED("Revoked", "Revogado");
    
    private final String displayName;
    private final String displayNamePt;
    
    IssuerStatus(String displayName, String displayNamePt) {
        this.displayName = displayName;
        this.displayNamePt = displayNamePt;
    }
    
    public String getDisplayName() { return displayName; }
    public String getDisplayNamePt() { return displayNamePt; }
    
    public boolean isActive() {
        return this == ACTIVE;
    }
}
```

#### 3.3.5 CompetenceLevel

```java
public enum CompetenceLevel {
    FULL("Full", "Completa"),
    LIMITED("Limited", "Limitada"),
    CONDITIONAL("Conditional", "Condicional"),
    TEMPORARY("Temporary", "Temporária");
    
    private final String displayName;
    private final String displayNamePt;
    
    CompetenceLevel(String displayName, String displayNamePt) {
        this.displayName = displayName;
        this.displayNamePt = displayNamePt;
    }
    
    public String getDisplayName() { return displayName; }
    public String getDisplayNamePt() { return displayNamePt; }
}
```

#### 3.3.6 CompetenceStatus

```java
public enum CompetenceStatus {
    ACTIVE("Active", "Ativa"),
    SUSPENDED("Suspended", "Suspensa"),
    REVOKED("Revoked", "Revogada"),
    EXPIRED("Expired", "Expirada");
    
    private final String displayName;
    private final String displayNamePt;
    
    CompetenceStatus(String displayName, String displayNamePt) {
        this.displayName = displayName;
        this.displayNamePt = displayNamePt;
    }
    
    public String getDisplayName() { return displayName; }
    public String getDisplayNamePt() { return displayNamePt; }
    
    public boolean isActive() {
        return this == ACTIVE;
    }
}
```

### 3.4 Interfaces de Repositório

#### 3.4.1 LicenseIssuerRepository

```java
public interface LicenseIssuerRepository extends Repository<LicenseIssuer, LicenseIssuerId> {
    
    // Métodos básicos
    Optional<LicenseIssuer> findById(LicenseIssuerId id);
    Optional<LicenseIssuer> findByIssuerCode(String issuerCode);
    List<LicenseIssuer> findByIssuerName(String issuerName);
    
    // Busca por critérios
    List<LicenseIssuer> findByIssuerType(IssuerType issuerType);
    List<LicenseIssuer> findByOrganizationLevel(OrganizationLevel organizationLevel);
    List<LicenseIssuer> findByStatus(IssuerStatus status);
    List<LicenseIssuer> findByJurisdictionType(JurisdictionType jurisdictionType);
    
    // Busca com filtros combinados
    Page<LicenseIssuer> findByCriteria(
        IssuerType issuerType,
        OrganizationLevel organizationLevel,
        IssuerStatus status,
        JurisdictionType jurisdictionType,
        String searchTerm,
        Pageable pageable
    );
    
    // Busca por competências
    List<LicenseIssuer> findByLicenseTypeCompetence(UUID licenseTypeId);
    List<LicenseIssuer> findByActiveLicenseTypeCompetence(UUID licenseTypeId);
    
    // Busca por jurisdição
    List<LicenseIssuer> findByJurisdictionCode(String jurisdictionCode);
    List<LicenseIssuer> findByActiveJurisdictionCode(String jurisdictionCode);
    
    // Busca por acreditação
    List<LicenseIssuer> findByAccreditationExpiring(LocalDate beforeDate);
    List<LicenseIssuer> findByExpiredAccreditation();
    
    // Verificações de existência
    boolean existsByIssuerCode(String issuerCode);
    boolean existsByIssuerCodeAndIdNot(String issuerCode, LicenseIssuerId id);
    
    // Estatísticas
    long countByStatus(IssuerStatus status);
    long countByIssuerType(IssuerType issuerType);
    long countByOrganizationLevel(OrganizationLevel organizationLevel);
    
    Map<IssuerStatus, Long> getStatusStatistics();
    Map<IssuerType, Long> getTypeStatistics();
    Map<OrganizationLevel, Long> getOrganizationLevelStatistics();
    
    // Operações de persistência
    LicenseIssuer save(LicenseIssuer issuer);
    void delete(LicenseIssuer issuer);
    void deleteById(LicenseIssuerId id);
}
```

### 3.5 Domain Services

#### 3.5.1 IssuerValidationService

```java
@DomainService
public class IssuerValidationService {
    
    private final LicenseIssuerRepository issuerRepository;
    
    public IssuerValidationService(LicenseIssuerRepository issuerRepository) {
        this.issuerRepository = issuerRepository;
    }
    
    public void validateIssuerCodeUniqueness(String issuerCode) {
        if (issuerRepository.existsByIssuerCode(issuerCode)) {
            throw new DomainException(
                String.format("Issuer with code '%s' already exists", issuerCode));
        }
    }
    
    public void validateIssuerCodeUniquenessForUpdate(String issuerCode, LicenseIssuerId issuerId) {
        if (issuerRepository.existsByIssuerCodeAndIdNot(issuerCode, issuerId)) {
            throw new DomainException(
                String.format("Issuer with code '%s' already exists", issuerCode));
        }
    }
    
    public void validateIssuerExists(LicenseIssuerId issuerId) {
        if (!issuerRepository.findById(issuerId).isPresent()) {
            throw new DomainException(
                String.format("Issuer with ID '%s' not found", issuerId));
        }
    }
    
    public void validateIssuerCanIssue(LicenseIssuerId issuerId, UUID licenseTypeId) {
        LicenseIssuer issuer = issuerRepository.findById(issuerId)
            .orElseThrow(() -> new DomainException(
                String.format("Issuer with ID '%s' not found", issuerId)));
        
        if (!issuer.canIssue(licenseTypeId)) {
            throw new DomainException(
                String.format("Issuer '%s' cannot issue license type '%s'", 
                             issuer.getIssuerCode(), licenseTypeId));
        }
    }
    
    public void validateIssuerHasJurisdiction(LicenseIssuerId issuerId, String jurisdictionCode) {
        LicenseIssuer issuer = issuerRepository.findById(issuerId)
            .orElseThrow(() -> new DomainException(
                String.format("Issuer with ID '%s' not found", issuerId)));
        
        if (!issuer.hasJurisdictionOver(jurisdictionCode)) {
            throw new DomainException(
                String.format("Issuer '%s' has no jurisdiction over '%s'", 
                             issuer.getIssuerCode(), jurisdictionCode));
        }
    }
}
```

#### 3.5.2 IssuerCompetenceService

```java
@DomainService
public class IssuerCompetenceService {
    
    private final LicenseIssuerRepository issuerRepository;
    private final LicenseTypeRepository licenseTypeRepository;
    
    public IssuerCompetenceService(
            LicenseIssuerRepository issuerRepository,
            LicenseTypeRepository licenseTypeRepository) {
        this.issuerRepository = issuerRepository;
        this.licenseTypeRepository = licenseTypeRepository;
    }
    
    public void validateLicenseTypeExists(UUID licenseTypeId) {
        if (!licenseTypeRepository.existsById(licenseTypeId)) {
            throw new DomainException(
                String.format("License type with ID '%s' not found", licenseTypeId));
        }
    }
    
    public List<LicenseIssuer> findAuthorizedIssuers(UUID licenseTypeId) {
        return issuerRepository.findByActiveLicenseTypeCompetence(licenseTypeId);
    }
    
    public List<LicenseIssuer> findAuthorizedIssuersInJurisdiction(
            UUID licenseTypeId, String jurisdictionCode) {
        
        List<LicenseIssuer> authorizedIssuers = findAuthorizedIssuers(licenseTypeId);
        
        return authorizedIssuers.stream()
            .filter(issuer -> issuer.hasJurisdictionOver(jurisdictionCode))
            .toList();
    }
    
    public boolean canIssueInJurisdiction(
            LicenseIssuerId issuerId, UUID licenseTypeId, String jurisdictionCode) {
        
        LicenseIssuer issuer = issuerRepository.findById(issuerId)
            .orElse(null);
        
        if (issuer == null) {
            return false;
        }
        
        return issuer.canIssue(licenseTypeId) && 
               issuer.hasJurisdictionOver(jurisdictionCode);
    }
    
    public void checkCompetenceExpiry() {
        // Este método seria chamado por um job agendado
        List<LicenseIssuer> allIssuers = issuerRepository.findByStatus(IssuerStatus.ACTIVE);
        
        for (LicenseIssuer issuer : allIssuers) {
            List<IssuerCompetence> expiredCompetences = issuer.getCompetences().stream()
                .filter(comp -> comp.getStatus() == CompetenceStatus.ACTIVE &&
                               comp.isExpired())
                .toList();
            
            for (IssuerCompetence competence : expiredCompetences) {
                competence.expire("AUTOMATIC_EXPIRY");
            }
            
            if (!expiredCompetences.isEmpty()) {
                issuerRepository.save(issuer);
            }
        }
    }
}
```

## 4. Camada de Aplicação

### 4.1 Use Cases

#### 4.1.1 CreateLicenseIssuerUseCase

```java
@UseCase
@Transactional
public class CreateLicenseIssuerUseCase {
    
    private final LicenseIssuerRepository issuerRepository;
    private final IssuerValidationService issuerValidationService;
    private final DomainEventPublisher eventPublisher;
    
    public CreateLicenseIssuerUseCase(
            LicenseIssuerRepository issuerRepository,
            IssuerValidationService issuerValidationService,
            DomainEventPublisher eventPublisher) {
        this.issuerRepository = issuerRepository;
        this.issuerValidationService = issuerValidationService;
        this.eventPublisher = eventPublisher;
    }
    
    public CreateLicenseIssuerResponse execute(CreateLicenseIssuerCommand command) {
        // Validações
        issuerValidationService.validateIssuerCodeUniqueness(command.getIssuerCode());
        
        // Criar Value Objects
        IssuerContactInfo contactInfo = IssuerContactInfo.of(
            command.getContactPerson(),
            command.getContactEmail(),
            command.getContactPhone(),
            command.getAddress()
        );
        
        AccreditationInfo accreditationInfo = null;
        if (command.getAccreditationDate() != null) {
            accreditationInfo = AccreditationInfo.of(
                command.getAccreditationDate(),
                command.getAccreditationExpiry(),
                command.getAccreditationAuthority()
            );
        }
        
        // Criar agregado
        LicenseIssuer issuer = LicenseIssuer.create(
            command.getIssuerCode(),
            command.getIssuerName(),
            command.getIssuerType(),
            command.getOrganizationLevel(),
            command.getJurisdictionType(),
            command.getJurisdictionDescription(),
            contactInfo,
            accreditationInfo,
            command.getNotes(),
            command.getCreatedBy()
        );
        
        // Persistir
        LicenseIssuer savedIssuer = issuerRepository.save(issuer);
        
        // Publicar eventos
        eventPublisher.publishAll(savedIssuer.getDomainEvents());
        savedIssuer.clearDomainEvents();
        
        return CreateLicenseIssuerResponse.from(savedIssuer);
    }
}
```

#### 4.1.2 GrantIssuerCompetenceUseCase

```java
@UseCase
@Transactional
public class GrantIssuerCompetenceUseCase {
    
    private final LicenseIssuerRepository issuerRepository;
    private final IssuerValidationService issuerValidationService;
    private final IssuerCompetenceService competenceService;
    private final DomainEventPublisher eventPublisher;
    
    public GrantIssuerCompetenceUseCase(
            LicenseIssuerRepository issuerRepository,
            IssuerValidationService issuerValidationService,
            IssuerCompetenceService competenceService,
            DomainEventPublisher eventPublisher) {
        this.issuerRepository = issuerRepository;
        this.issuerValidationService = issuerValidationService;
        this.competenceService = competenceService;
        this.eventPublisher = eventPublisher;
    }
    
    public GrantIssuerCompetenceResponse execute(GrantIssuerCompetenceCommand command) {
        // Validações
        issuerValidationService.validateIssuerExists(command.getIssuerId());
        competenceService.validateLicenseTypeExists(command.getLicenseTypeId());
        
        // Buscar agregado
        LicenseIssuer issuer = issuerRepository.findById(command.getIssuerId())
            .orElseThrow(() -> new DomainException("Issuer not found"));
        
        // Executar operação de domínio
        IssuerCompetence competence = issuer.grantCompetence(
            command.getLicenseTypeId(),
            command.getCompetenceLevel(),
            command.getValidFrom(),
            command.getValidUntil(),
            command.getCompetenceNotes(),
            command.getGrantedBy()
        );
        
        // Persistir
        LicenseIssuer savedIssuer = issuerRepository.save(issuer);
        
        // Publicar eventos
        eventPublisher.publishAll(savedIssuer.getDomainEvents());
        savedIssuer.clearDomainEvents();
        
        return GrantIssuerCompetenceResponse.from(competence);
     }
 }
```

### 4.2 DTOs

#### 4.2.1 Command DTOs

##### CreateLicenseIssuerCommand

```java
public class CreateLicenseIssuerCommand {
    
    @NotBlank(message = "Issuer code is required")
    @Size(max = 20, message = "Issuer code must not exceed 20 characters")
    private String issuerCode;
    
    @NotBlank(message = "Issuer name is required")
    @Size(max = 255, message = "Issuer name must not exceed 255 characters")
    private String issuerName;
    
    @NotNull(message = "Issuer type is required")
    private IssuerType issuerType;
    
    @NotNull(message = "Organization level is required")
    private OrganizationLevel organizationLevel;
    
    @NotNull(message = "Jurisdiction type is required")
    private JurisdictionType jurisdictionType;
    
    @Size(max = 1000, message = "Jurisdiction description must not exceed 1000 characters")
    private String jurisdictionDescription;
    
    @Size(max = 255, message = "Contact person must not exceed 255 characters")
    private String contactPerson;
    
    @Email(message = "Invalid email format")
    @Size(max = 255, message = "Contact email must not exceed 255 characters")
    private String contactEmail;
    
    @Size(max = 50, message = "Contact phone must not exceed 50 characters")
    private String contactPhone;
    
    @Size(max = 1000, message = "Address must not exceed 1000 characters")
    private String address;
    
    private LocalDate accreditationDate;
    
    @Future(message = "Accreditation expiry must be in the future")
    private LocalDate accreditationExpiry;
    
    @Size(max = 255, message = "Accreditation authority must not exceed 255 characters")
    private String accreditationAuthority;
    
    @Size(max = 1000, message = "Notes must not exceed 1000 characters")
    private String notes;
    
    @NotBlank(message = "Created by is required")
    private String createdBy;
    
    // Getters and setters
    public String getIssuerCode() { return issuerCode; }
    public void setIssuerCode(String issuerCode) { this.issuerCode = issuerCode; }
    
    public String getIssuerName() { return issuerName; }
    public void setIssuerName(String issuerName) { this.issuerName = issuerName; }
    
    public IssuerType getIssuerType() { return issuerType; }
    public void setIssuerType(IssuerType issuerType) { this.issuerType = issuerType; }
    
    public OrganizationLevel getOrganizationLevel() { return organizationLevel; }
    public void setOrganizationLevel(OrganizationLevel organizationLevel) { this.organizationLevel = organizationLevel; }
    
    public JurisdictionType getJurisdictionType() { return jurisdictionType; }
    public void setJurisdictionType(JurisdictionType jurisdictionType) { this.jurisdictionType = jurisdictionType; }
    
    public String getJurisdictionDescription() { return jurisdictionDescription; }
    public void setJurisdictionDescription(String jurisdictionDescription) { this.jurisdictionDescription = jurisdictionDescription; }
    
    public String getContactPerson() { return contactPerson; }
    public void setContactPerson(String contactPerson) { this.contactPerson = contactPerson; }
    
    public String getContactEmail() { return contactEmail; }
    public void setContactEmail(String contactEmail) { this.contactEmail = contactEmail; }
    
    public String getContactPhone() { return contactPhone; }
    public void setContactPhone(String contactPhone) { this.contactPhone = contactPhone; }
    
    public String getAddress() { return address; }
    public void setAddress(String address) { this.address = address; }
    
    public LocalDate getAccreditationDate() { return accreditationDate; }
    public void setAccreditationDate(LocalDate accreditationDate) { this.accreditationDate = accreditationDate; }
    
    public LocalDate getAccreditationExpiry() { return accreditationExpiry; }
    public void setAccreditationExpiry(LocalDate accreditationExpiry) { this.accreditationExpiry = accreditationExpiry; }
    
    public String getAccreditationAuthority() { return accreditationAuthority; }
    public void setAccreditationAuthority(String accreditationAuthority) { this.accreditationAuthority = accreditationAuthority; }
    
    public String getNotes() { return notes; }
    public void setNotes(String notes) { this.notes = notes; }
    
    public String getCreatedBy() { return createdBy; }
    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }
}
```

##### GrantIssuerCompetenceCommand

```java
public class GrantIssuerCompetenceCommand {
    
    @NotNull(message = "Issuer ID is required")
    private LicenseIssuerId issuerId;
    
    @NotNull(message = "License type ID is required")
    private UUID licenseTypeId;
    
    @NotNull(message = "Competence level is required")
    private CompetenceLevel competenceLevel;
    
    @NotNull(message = "Valid from date is required")
    @PastOrPresent(message = "Valid from date cannot be in the future")
    private LocalDate validFrom;
    
    @Future(message = "Valid until date must be in the future")
    private LocalDate validUntil;
    
    @Size(max = 1000, message = "Competence notes must not exceed 1000 characters")
    private String competenceNotes;
    
    @NotBlank(message = "Granted by is required")
    private String grantedBy;
    
    // Getters and setters
    public LicenseIssuerId getIssuerId() { return issuerId; }
    public void setIssuerId(LicenseIssuerId issuerId) { this.issuerId = issuerId; }
    
    public UUID getLicenseTypeId() { return licenseTypeId; }
    public void setLicenseTypeId(UUID licenseTypeId) { this.licenseTypeId = licenseTypeId; }
    
    public CompetenceLevel getCompetenceLevel() { return competenceLevel; }
    public void setCompetenceLevel(CompetenceLevel competenceLevel) { this.competenceLevel = competenceLevel; }
    
    public LocalDate getValidFrom() { return validFrom; }
    public void setValidFrom(LocalDate validFrom) { this.validFrom = validFrom; }
    
    public LocalDate getValidUntil() { return validUntil; }
    public void setValidUntil(LocalDate validUntil) { this.validUntil = validUntil; }
    
    public String getCompetenceNotes() { return competenceNotes; }
    public void setCompetenceNotes(String competenceNotes) { this.competenceNotes = competenceNotes; }
    
    public String getGrantedBy() { return grantedBy; }
    public void setGrantedBy(String grantedBy) { this.grantedBy = grantedBy; }
}
```

#### 4.2.2 Response DTOs

##### LicenseIssuerResponse

```java
public class LicenseIssuerResponse {
    
    private String id;
    private String issuerCode;
    private String issuerName;
    private IssuerType issuerType;
    private OrganizationLevel organizationLevel;
    private JurisdictionType jurisdictionType;
    private String jurisdictionDescription;
    private IssuerContactInfoResponse contactInfo;
    private IssuerStatus status;
    private AccreditationInfoResponse accreditationInfo;
    private String notes;
    private AuditInfoResponse auditInfo;
    private Integer version;
    private List<IssuerCompetenceResponse> competences;
    private List<IssuerJurisdictionResponse> jurisdictions;
    
    public static LicenseIssuerResponse from(LicenseIssuer issuer) {
        LicenseIssuerResponse response = new LicenseIssuerResponse();
        response.id = issuer.getId().toString();
        response.issuerCode = issuer.getIssuerCode();
        response.issuerName = issuer.getIssuerName();
        response.issuerType = issuer.getIssuerType();
        response.organizationLevel = issuer.getOrganizationLevel();
        response.jurisdictionType = issuer.getJurisdictionType();
        response.jurisdictionDescription = issuer.getJurisdictionDescription();
        response.contactInfo = IssuerContactInfoResponse.from(issuer.getContactInfo());
        response.status = issuer.getStatus();
        response.accreditationInfo = AccreditationInfoResponse.from(issuer.getAccreditationInfo());
        response.notes = issuer.getNotes();
        response.auditInfo = AuditInfoResponse.from(issuer.getAuditInfo());
        response.version = issuer.getVersion();
        response.competences = issuer.getCompetences().stream()
            .map(IssuerCompetenceResponse::from)
            .toList();
        response.jurisdictions = issuer.getJurisdictions().stream()
            .map(IssuerJurisdictionResponse::from)
            .toList();
        return response;
    }
    
    // Getters and setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    
    public String getIssuerCode() { return issuerCode; }
    public void setIssuerCode(String issuerCode) { this.issuerCode = issuerCode; }
    
    public String getIssuerName() { return issuerName; }
    public void setIssuerName(String issuerName) { this.issuerName = issuerName; }
    
    public IssuerType getIssuerType() { return issuerType; }
    public void setIssuerType(IssuerType issuerType) { this.issuerType = issuerType; }
    
    public OrganizationLevel getOrganizationLevel() { return organizationLevel; }
    public void setOrganizationLevel(OrganizationLevel organizationLevel) { this.organizationLevel = organizationLevel; }
    
    public JurisdictionType getJurisdictionType() { return jurisdictionType; }
    public void setJurisdictionType(JurisdictionType jurisdictionType) { this.jurisdictionType = jurisdictionType; }
    
    public String getJurisdictionDescription() { return jurisdictionDescription; }
    public void setJurisdictionDescription(String jurisdictionDescription) { this.jurisdictionDescription = jurisdictionDescription; }
    
    public IssuerContactInfoResponse getContactInfo() { return contactInfo; }
    public void setContactInfo(IssuerContactInfoResponse contactInfo) { this.contactInfo = contactInfo; }
    
    public IssuerStatus getStatus() { return status; }
    public void setStatus(IssuerStatus status) { this.status = status; }
    
    public AccreditationInfoResponse getAccreditationInfo() { return accreditationInfo; }
    public void setAccreditationInfo(AccreditationInfoResponse accreditationInfo) { this.accreditationInfo = accreditationInfo; }
    
    public String getNotes() { return notes; }
    public void setNotes(String notes) { this.notes = notes; }
    
    public AuditInfoResponse getAuditInfo() { return auditInfo; }
    public void setAuditInfo(AuditInfoResponse auditInfo) { this.auditInfo = auditInfo; }
    
    public Integer getVersion() { return version; }
    public void setVersion(Integer version) { this.version = version; }
    
    public List<IssuerCompetenceResponse> getCompetences() { return competences; }
    public void setCompetences(List<IssuerCompetenceResponse> competences) { this.competences = competences; }
    
    public List<IssuerJurisdictionResponse> getJurisdictions() { return jurisdictions; }
    public void setJurisdictions(List<IssuerJurisdictionResponse> jurisdictions) { this.jurisdictions = jurisdictions; }
}
```

## 5. Controladores REST

### 5.1 LicenseIssuerController

```java
@RestController
@RequestMapping("/api/v1/license-issuers")
@Validated
public class LicenseIssuerController {
    
    private final CreateLicenseIssuerUseCase createLicenseIssuerUseCase;
    private final GrantIssuerCompetenceUseCase grantIssuerCompetenceUseCase;
    private final LicenseIssuerQueryService licenseIssuerQueryService;
    
    public LicenseIssuerController(
            CreateLicenseIssuerUseCase createLicenseIssuerUseCase,
            GrantIssuerCompetenceUseCase grantIssuerCompetenceUseCase,
            LicenseIssuerQueryService licenseIssuerQueryService) {
        this.createLicenseIssuerUseCase = createLicenseIssuerUseCase;
        this.grantIssuerCompetenceUseCase = grantIssuerCompetenceUseCase;
        this.licenseIssuerQueryService = licenseIssuerQueryService;
    }
    
    @PostMapping
    public ResponseEntity<ApiResponse<CreateLicenseIssuerResponse>> createIssuer(
            @Valid @RequestBody CreateLicenseIssuerCommand command) {
        
        CreateLicenseIssuerResponse response = createLicenseIssuerUseCase.execute(command);
        
        return ResponseEntity.status(HttpStatus.CREATED)
            .body(ApiResponse.success(response, "License issuer created successfully"));
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<LicenseIssuerResponse>> getIssuerById(
            @PathVariable String id) {
        
        LicenseIssuerResponse response = licenseIssuerQueryService.findById(id);
        
        return ResponseEntity.ok(
            ApiResponse.success(response, "License issuer retrieved successfully"));
    }
    
    @GetMapping
    public ResponseEntity<ApiResponse<PagedResponse<LicenseIssuerResponse>>> getIssuers(
            @RequestParam(required = false) IssuerType issuerType,
            @RequestParam(required = false) OrganizationLevel organizationLevel,
            @RequestParam(required = false) IssuerStatus status,
            @RequestParam(required = false) JurisdictionType jurisdictionType,
            @RequestParam(required = false) String search,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(defaultValue = "issuerName") String sortBy,
            @RequestParam(defaultValue = "asc") String sortDirection) {
        
        PagedResponse<LicenseIssuerResponse> response = licenseIssuerQueryService.findByCriteria(
            issuerType, organizationLevel, status, jurisdictionType, search,
            page, size, sortBy, sortDirection);
        
        return ResponseEntity.ok(
            ApiResponse.success(response, "License issuers retrieved successfully"));
    }
    
    @PostMapping("/{id}/competences")
    public ResponseEntity<ApiResponse<GrantIssuerCompetenceResponse>> grantCompetence(
            @PathVariable String id,
            @Valid @RequestBody GrantIssuerCompetenceCommand command) {
        
        command.setIssuerId(LicenseIssuerId.of(id));
        GrantIssuerCompetenceResponse response = grantIssuerCompetenceUseCase.execute(command);
        
        return ResponseEntity.status(HttpStatus.CREATED)
            .body(ApiResponse.success(response, "Competence granted successfully"));
    }
    
    @GetMapping("/{id}/competences")
    public ResponseEntity<ApiResponse<List<IssuerCompetenceResponse>>> getIssuerCompetences(
            @PathVariable String id) {
        
        List<IssuerCompetenceResponse> response = licenseIssuerQueryService.findCompetencesByIssuerId(id);
        
        return ResponseEntity.ok(
            ApiResponse.success(response, "Issuer competences retrieved successfully"));
    }
    
    @GetMapping("/by-license-type/{licenseTypeId}")
    public ResponseEntity<ApiResponse<List<LicenseIssuerResponse>>> getIssuersByLicenseType(
            @PathVariable String licenseTypeId) {
        
        List<LicenseIssuerResponse> response = licenseIssuerQueryService
            .findAuthorizedIssuers(UUID.fromString(licenseTypeId));
        
        return ResponseEntity.ok(
            ApiResponse.success(response, "Authorized issuers retrieved successfully"));
    }
    
    @GetMapping("/statistics")
    public ResponseEntity<ApiResponse<IssuerStatisticsResponse>> getStatistics() {
        
        IssuerStatisticsResponse response = licenseIssuerQueryService.getStatistics();
        
        return ResponseEntity.ok(
            ApiResponse.success(response, "Issuer statistics retrieved successfully"));
    }
}
```

## 6. Testes

### 6.1 Testes Unitários de Domínio

#### 6.1.1 LicenseIssuerTest

```java
class LicenseIssuerTest {
    
    @Test
    void shouldCreateLicenseIssuerSuccessfully() {
        // Given
        String issuerCode = "GOV001";
        String issuerName = "Government Agency";
        IssuerType issuerType = IssuerType.GOVERNMENT_AGENCY;
        OrganizationLevel organizationLevel = OrganizationLevel.NATIONAL;
        JurisdictionType jurisdictionType = JurisdictionType.TERRITORIAL;
        String jurisdictionDescription = "National territory";
        IssuerContactInfo contactInfo = IssuerContactInfo.of(
            "John Doe", "john@gov.cv", "+238 123456", "Praia, Cape Verde");
        AccreditationInfo accreditationInfo = AccreditationInfo.of(
            LocalDate.now().minusYears(1),
            LocalDate.now().plusYears(4),
            "Ministry of Interior");
        String notes = "Main government agency";
        String createdBy = "admin";
        
        // When
        LicenseIssuer issuer = LicenseIssuer.create(
            issuerCode, issuerName, issuerType, organizationLevel,
            jurisdictionType, jurisdictionDescription, contactInfo,
            accreditationInfo, notes, createdBy);
        
        // Then
        assertThat(issuer.getId()).isNotNull();
        assertThat(issuer.getIssuerCode()).isEqualTo(issuerCode);
        assertThat(issuer.getIssuerName()).isEqualTo(issuerName);
        assertThat(issuer.getIssuerType()).isEqualTo(issuerType);
        assertThat(issuer.getOrganizationLevel()).isEqualTo(organizationLevel);
        assertThat(issuer.getJurisdictionType()).isEqualTo(jurisdictionType);
        assertThat(issuer.getStatus()).isEqualTo(IssuerStatus.ACTIVE);
        assertThat(issuer.isActive()).isTrue();
        assertThat(issuer.hasValidAccreditation()).isTrue();
        assertThat(issuer.getDomainEvents()).hasSize(1);
        assertThat(issuer.getDomainEvents().get(0)).isInstanceOf(LicenseIssuerCreatedEvent.class);
    }
    
    @Test
    void shouldThrowExceptionWhenCreatingWithInvalidData() {
        // Given
        String issuerCode = "";
        String issuerName = "Government Agency";
        IssuerType issuerType = IssuerType.GOVERNMENT_AGENCY;
        OrganizationLevel organizationLevel = OrganizationLevel.NATIONAL;
        JurisdictionType jurisdictionType = JurisdictionType.TERRITORIAL;
        String createdBy = "admin";
        
        // When & Then
        assertThatThrownBy(() -> LicenseIssuer.create(
            issuerCode, issuerName, issuerType, organizationLevel,
            jurisdictionType, null, null, null, null, createdBy))
            .isInstanceOf(DomainException.class)
            .hasMessageContaining("Issuer code is required");
    }
    
    @Test
    void shouldGrantCompetenceSuccessfully() {
        // Given
        LicenseIssuer issuer = createValidIssuer();
        UUID licenseTypeId = UUID.randomUUID();
        CompetenceLevel competenceLevel = CompetenceLevel.FULL;
        LocalDate validFrom = LocalDate.now();
        LocalDate validUntil = LocalDate.now().plusYears(2);
        String competenceNotes = "Full competence granted";
        String grantedBy = "admin";
        
        // When
        IssuerCompetence competence = issuer.grantCompetence(
            licenseTypeId, competenceLevel, validFrom, validUntil,
            competenceNotes, grantedBy);
        
        // Then
        assertThat(competence).isNotNull();
        assertThat(competence.getLicenseTypeId()).isEqualTo(licenseTypeId);
        assertThat(competence.getCompetenceLevel()).isEqualTo(competenceLevel);
        assertThat(competence.getStatus()).isEqualTo(CompetenceStatus.ACTIVE);
        assertThat(issuer.canIssue(licenseTypeId)).isTrue();
        assertThat(issuer.getDomainEvents()).hasSize(2); // Creation + Competence granted
    }
    
    @Test
    void shouldSuspendIssuerAndCompetences() {
        // Given
        LicenseIssuer issuer = createValidIssuer();
        UUID licenseTypeId = UUID.randomUUID();
        issuer.grantCompetence(licenseTypeId, CompetenceLevel.FULL,
            LocalDate.now(), LocalDate.now().plusYears(2),
            "Test competence", "admin");
        String reason = "Regulatory violation";
        String suspendedBy = "supervisor";
        
        // When
        issuer.suspend(reason, suspendedBy);
        
        // Then
        assertThat(issuer.getStatus()).isEqualTo(IssuerStatus.SUSPENDED);
        assertThat(issuer.isActive()).isFalse();
        assertThat(issuer.canIssue(licenseTypeId)).isFalse();
        assertThat(issuer.getDomainEvents()).anyMatch(
            event -> event instanceof IssuerSuspendedEvent);
    }
    
    private LicenseIssuer createValidIssuer() {
        return LicenseIssuer.create(
            "GOV001", "Government Agency", IssuerType.GOVERNMENT_AGENCY,
            OrganizationLevel.NATIONAL, JurisdictionType.TERRITORIAL,
            "National territory", null, null, null, "admin");
    }
}
```

### 6.2 Testes de Integração

#### 6.2.1 LicenseIssuerControllerIntegrationTest

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@TestPropertySource(properties = {
    "spring.datasource.url=jdbc:h2:mem:testdb",
    "spring.jpa.hibernate.ddl-auto=create-drop"
})
class LicenseIssuerControllerIntegrationTest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private LicenseIssuerRepository issuerRepository;
    
    @BeforeEach
    void setUp() {
        issuerRepository.deleteAll();
    }
    
    @Test
    void shouldCreateLicenseIssuerSuccessfully() {
        // Given
        CreateLicenseIssuerCommand command = new CreateLicenseIssuerCommand();
        command.setIssuerCode("GOV001");
        command.setIssuerName("Government Agency");
        command.setIssuerType(IssuerType.GOVERNMENT_AGENCY);
        command.setOrganizationLevel(OrganizationLevel.NATIONAL);
        command.setJurisdictionType(JurisdictionType.TERRITORIAL);
        command.setJurisdictionDescription("National territory");
        command.setContactPerson("John Doe");
        command.setContactEmail("john@gov.cv");
        command.setContactPhone("+238 123456");
        command.setAddress("Praia, Cape Verde");
        command.setAccreditationDate(LocalDate.now().minusYears(1));
        command.setAccreditationExpiry(LocalDate.now().plusYears(4));
        command.setAccreditationAuthority("Ministry of Interior");
        command.setNotes("Main government agency");
        command.setCreatedBy("admin");
        
        // When
        ResponseEntity<ApiResponse> response = restTemplate.postForEntity(
            "/api/v1/license-issuers", command, ApiResponse.class);
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
        assertThat(response.getBody().isSuccess()).isTrue();
        assertThat(response.getBody().getMessage()).contains("created successfully");
        
        // Verify in database
        List<LicenseIssuer> issuers = issuerRepository.findAll();
        assertThat(issuers).hasSize(1);
        assertThat(issuers.get(0).getIssuerCode()).isEqualTo("GOV001");
    }
    
    @Test
    void shouldReturnValidationErrorForInvalidData() {
        // Given
        CreateLicenseIssuerCommand command = new CreateLicenseIssuerCommand();
        // Missing required fields
        
        // When
        ResponseEntity<ApiResponse> response = restTemplate.postForEntity(
            "/api/v1/license-issuers", command, ApiResponse.class);
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
        assertThat(response.getBody().isSuccess()).isFalse();
    }
    
    @Test
    void shouldRetrieveIssuerById() {
        // Given
        LicenseIssuer issuer = createAndSaveIssuer();
        
        // When
        ResponseEntity<ApiResponse> response = restTemplate.getForEntity(
            "/api/v1/license-issuers/" + issuer.getId(), ApiResponse.class);
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody().isSuccess()).isTrue();
    }
    
    private LicenseIssuer createAndSaveIssuer() {
        LicenseIssuer issuer = LicenseIssuer.create(
            "GOV001", "Government Agency", IssuerType.GOVERNMENT_AGENCY,
            OrganizationLevel.NATIONAL, JurisdictionType.TERRITORIAL,
            "National territory", null, null, null, "admin");
        return issuerRepository.save(issuer);
    }
}
```

## 4. REST API Specification

### 4.1 Base Configuration

**Base URL:** `/api/v1/issuers`

**Headers Obrigatórios:**

```
Content-Type: application/json
Authorization: Bearer {jwt_token}
X-Request-ID: {unique_request_id}
```

**Códigos de Status Padrão:**

* `200 OK` - Operação bem-sucedida

* `201 Created` - Recurso criado com sucesso

* `400 Bad Request` - Dados inválidos na requisição

* `401 Unauthorized` - Token de autenticação inválido

* `403 Forbidden` - Acesso negado

* `404 Not Found` - Recurso não encontrado

* `409 Conflict` - Conflito de dados (ex: código de emissor duplicado)

* `422 Unprocessable Entity` - Erro de validação de negócio

* `500 Internal Server Error` - Erro interno do servidor

### 4.2 Endpoints de Emissores

#### 4.2.1 Criar Emissor

**POST** `/api/v1/issuers`

**Request Body:**

```json
{
  "issuerCode": "CM-PRAIA-001",
  "name": "Câmara Municipal da Praia",
  "issuerType": "MUNICIPAL_CHAMBER",
  "jurisdiction": {
    "island": "Santiago",
    "municipality": "Praia",
    "parishes": ["Nossa Senhora da Graça", "São Nicolau Tolentino"],
    "geographicBounds": {
      "north": 14.9500,
      "south": 14.8800,
      "east": -23.4800,
      "west": -23.5500
    }
  },
  "contactInfo": {
    "primaryEmail": "licenciamento@cmpraia.cv",
    "secondaryEmail": "admin@cmpraia.cv",
    "primaryPhone": "+238 260 1234",
    "secondaryPhone": "+238 260 5678",
    "fax": "+238 260 9999",
    "website": "https://www.cmpraia.cv"
  },
  "address": {
    "street": "Avenida Cidade de Lisboa",
    "number": "1",
    "neighborhood": "Plateau",
    "municipality": "Praia",
    "island": "Santiago",
    "postalCode": "7600",
    "country": "Cabo Verde"
  },
  "legalInfo": {
    "registrationNumber": "REG-CM-PRAIA-001",
    "taxNumber": "TAX-123456789",
    "establishmentDate": "1975-07-05",
    "legalRepresentative": {
      "name": "Dr. Francisco Carvalho",
      "position": "Presidente da Câmara",
      "identification": {
        "type": "NATIONAL_ID",
        "number": "987654321"
      }
    }
  },
  "operationalInfo": {
    "businessHours": {
      "monday": {"open": "08:00", "close": "16:00"},
      "tuesday": {"open": "08:00", "close": "16:00"},
      "wednesday": {"open": "08:00", "close": "16:00"},
      "thursday": {"open": "08:00", "close": "16:00"},
      "friday": {"open": "08:00", "close": "16:00"},
      "saturday": {"open": "08:00", "close": "12:00"},
      "sunday": {"closed": true}
    },
    "serviceCapacity": {
      "maxDailyApplications": 50,
      "maxConcurrentProcesses": 200,
      "averageProcessingDays": 15
    }
  },
  "authorizedLicenseTypes": [
    "COMMERCIAL_OPERATION",
    "TOURISM",
    "CONSTRUCTION",
    "FOOD_SERVICE"
  ],
  "fees": {
    "baseFee": 2500.00,
    "processingFee": 500.00,
    "inspectionFee": 1000.00,
    "urgentProcessingFee": 1500.00,
    "currency": "CVE"
  }
}
```

**Response (201 Created):**

```json
{
  "success": true,
  "data": {
    "id": "issuer-550e8400-e29b-41d4-a716-446655440000",
    "issuerCode": "CM-PRAIA-001",
    "name": "Câmara Municipal da Praia",
    "issuerType": "MUNICIPAL_CHAMBER",
    "status": "ACTIVE",
    "jurisdiction": {
      "island": "Santiago",
      "municipality": "Praia",
      "parishes": ["Nossa Senhora da Graça", "São Nicolau Tolentino"]
    },
    "contactInfo": {
      "primaryEmail": "licenciamento@cmpraia.cv",
      "primaryPhone": "+238 260 1234",
      "website": "https://www.cmpraia.cv"
    },
    "authorizedLicenseTypes": [
      "COMMERCIAL_OPERATION",
      "TOURISM",
      "CONSTRUCTION",
      "FOOD_SERVICE"
    ],
    "isActive": true,
    "canIssue": true,
    "totalLicensesIssued": 0,
    "activeLicenses": 0,
    "createdAt": "2024-01-15T10:30:00Z",
    "createdBy": "admin123"
  },
  "message": "Emissor criado com sucesso"
}
```

**Exemplo cURL:**

```bash
curl -X POST "https://api.licenciamento.cv/api/v1/issuers" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." \
  -d '{
    "issuerCode": "CM-PRAIA-001",
    "name": "Câmara Municipal da Praia",
    "issuerType": "MUNICIPAL_CHAMBER",
    "jurisdiction": {
      "island": "Santiago",
      "municipality": "Praia"
    }
  }'
```

#### 4.2.2 Buscar Emissor por ID

**GET** `/api/v1/issuers/{id}`

**Path Parameters:**

* `id` (UUID) - ID único do emissor

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "id": "issuer-550e8400-e29b-41d4-a716-446655440000",
    "issuerCode": "CM-PRAIA-001",
    "name": "Câmara Municipal da Praia",
    "issuerType": "MUNICIPAL_CHAMBER",
    "status": "ACTIVE",
    "jurisdiction": {
      "island": "Santiago",
      "municipality": "Praia",
      "parishes": ["Nossa Senhora da Graça", "São Nicolau Tolentino"],
      "geographicBounds": {
        "north": 14.9500,
        "south": 14.8800,
        "east": -23.4800,
        "west": -23.5500
      }
    },
    "contactInfo": {
      "primaryEmail": "licenciamento@cmpraia.cv",
      "secondaryEmail": "admin@cmpraia.cv",
      "primaryPhone": "+238 260 1234",
      "secondaryPhone": "+238 260 5678",
      "website": "https://www.cmpraia.cv"
    },
    "address": {
      "street": "Avenida Cidade de Lisboa",
      "number": "1",
      "neighborhood": "Plateau",
      "municipality": "Praia",
      "island": "Santiago",
      "postalCode": "7600",
      "country": "Cabo Verde"
    },
    "legalInfo": {
      "registrationNumber": "REG-CM-PRAIA-001",
      "taxNumber": "TAX-123456789",
      "establishmentDate": "1975-07-05",
      "legalRepresentative": {
        "name": "Dr. Francisco Carvalho",
        "position": "Presidente da Câmara"
      }
    },
    "operationalInfo": {
      "businessHours": {
        "monday": {"open": "08:00", "close": "16:00"},
        "tuesday": {"open": "08:00", "close": "16:00"}
      },
      "serviceCapacity": {
        "maxDailyApplications": 50,
        "maxConcurrentProcesses": 200,
        "averageProcessingDays": 15
      }
    },
    "authorizedLicenseTypes": [
      "COMMERCIAL_OPERATION",
      "TOURISM",
      "CONSTRUCTION",
      "FOOD_SERVICE"
    ],
    "fees": {
      "baseFee": 2500.00,
      "processingFee": 500.00,
      "currency": "CVE"
    },
    "statistics": {
      "totalLicensesIssued": 1250,
      "activeLicenses": 980,
      "pendingApplications": 45,
      "averageProcessingTime": 12.5,
      "approvalRate": 92.5
    },
    "isActive": true,
    "canIssue": true,
    "lastActivityAt": "2024-01-15T14:30:00Z",
    "createdAt": "2024-01-01T10:00:00Z",
    "updatedAt": "2024-01-15T14:30:00Z"
  }
}
```

#### 4.2.3 Buscar Emissor por Código

**GET** `/api/v1/issuers/by-code/{issuerCode}`

**Path Parameters:**

* `issuerCode` (string) - Código único do emissor

#### 4.2.4 Listar Emissores

**GET** `/api/v1/issuers`

**Query Parameters:**

* `page` (int, default: 0) - Número da página

* `size` (int, default: 20, max: 100) - Tamanho da página

* `sort` (string, default: "name,asc") - Ordenação

* `issuerType` (string) - Filtrar por tipo de emissor

* `status` (string) - Filtrar por status

* `island` (string) - Filtrar por ilha

* `municipality` (string) - Filtrar por município

* `canIssue` (boolean) - Filtrar por capacidade de emissão

* `licenseType` (string) - Filtrar por tipo de licença autorizada

* `search` (string) - Busca textual em nome ou código

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "content": [
      {
        "id": "issuer-550e8400-e29b-41d4-a716-446655440000",
        "issuerCode": "CM-PRAIA-001",
        "name": "Câmara Municipal da Praia",
        "issuerType": "MUNICIPAL_CHAMBER",
        "status": "ACTIVE",
        "jurisdiction": {
          "island": "Santiago",
          "municipality": "Praia"
        },
        "contactInfo": {
          "primaryEmail": "licenciamento@cmpraia.cv",
          "primaryPhone": "+238 260 1234"
        },
        "authorizedLicenseTypes": [
          "COMMERCIAL_OPERATION",
          "TOURISM"
        ],
        "statistics": {
          "totalLicensesIssued": 1250,
          "activeLicenses": 980,
          "pendingApplications": 45
        },
        "isActive": true,
        "canIssue": true,
        "createdAt": "2024-01-01T10:00:00Z"
      }
    ],
    "pageable": {
      "page": 0,
      "size": 20,
      "sort": "name,asc"
    },
    "totalElements": 1,
    "totalPages": 1,
    "first": true,
    "last": true
  }
}
```

#### 4.2.5 Atualizar Emissor

**PUT** `/api/v1/issuers/{id}`

**Request Body:**

```json
{
  "contactInfo": {
    "primaryEmail": "novo-email@cmpraia.cv",
    "primaryPhone": "+238 260 9999",
    "website": "https://www.novosite-cmpraia.cv"
  },
  "operationalInfo": {
    "businessHours": {
      "monday": {"open": "07:30", "close": "16:30"},
      "tuesday": {"open": "07:30", "close": "16:30"}
    },
    "serviceCapacity": {
      "maxDailyApplications": 60,
      "maxConcurrentProcesses": 250
    }
  },
  "fees": {
    "baseFee": 3000.00,
    "processingFee": 600.00,
    "currency": "CVE"
  },
  "notes": "Atualização de capacidade e taxas para 2024"
}
```

#### 4.2.6 Alterar Status do Emissor

**PATCH** `/api/v1/issuers/{id}/status`

**Request Body:**

```json
{
  "status": "SUSPENDED",
  "reason": "Auditoria em andamento",
  "notes": "Suspensão temporária para auditoria interna",
  "effectiveDate": "2024-01-20T00:00:00Z",
  "suspensionPeriod": 15,
  "reviewDate": "2024-02-05T00:00:00Z",
  "notifyStakeholders": true
}
```

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "id": "issuer-550e8400-e29b-41d4-a716-446655440000",
    "status": "SUSPENDED",
    "statusHistory": [
      {
        "previousStatus": "ACTIVE",
        "newStatus": "SUSPENDED",
        "changedAt": "2024-01-20T10:00:00Z",
        "changedBy": "admin123",
        "reason": "Auditoria em andamento"
      }
    ],
    "canIssue": false,
    "suspensionInfo": {
      "suspendedAt": "2024-01-20T10:00:00Z",
      "suspensionPeriod": 15,
      "reviewDate": "2024-02-05T00:00:00Z",
      "reason": "Auditoria em andamento"
    },
    "updatedAt": "2024-01-20T10:00:00Z"
  },
  "message": "Status do emissor alterado com sucesso"
}
```

### 4.3 Endpoints de Licenças do Emissor

#### 4.3.1 Listar Licenças Emitidas

**GET** `/api/v1/issuers/{id}/licenses`

**Query Parameters:**

* `page` (int, default: 0) - Número da página

* `size` (int, default: 20) - Tamanho da página

* `licenseType` (string) - Filtrar por tipo de licença

* `status` (string) - Filtrar por status

* `issueDate` (date) - Filtrar por data de emissão

* `expiryDate` (date) - Filtrar por data de expiração

* `holderName` (string) - Filtrar por nome do titular

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "issuer": {
      "id": "issuer-550e8400-e29b-41d4-a716-446655440000",
      "name": "Câmara Municipal da Praia",
      "issuerCode": "CM-PRAIA-001"
    },
    "licenses": {
      "content": [
        {
          "id": "license-123",
          "licenseNumber": "LIC-2024-001",
          "licenseType": "COMMERCIAL_OPERATION",
          "status": "ACTIVE",
          "holder": {
            "name": "João Silva Santos",
            "holderType": "INDIVIDUAL"
          },
          "establishment": {
            "name": "Restaurante Sabores da Terra",
            "municipality": "Praia"
          },
          "issueDate": "2024-01-15",
          "expiryDate": "2025-01-15",
          "daysUntilExpiry": 365,
          "fees": {
            "totalAmount": 6500.00,
            "paymentStatus": "PAID"
          }
        }
      ],
      "totalElements": 1250,
      "totalPages": 63
    }
  }
}
```

#### 4.3.2 Estatísticas de Licenças do Emissor

**GET** `/api/v1/issuers/{id}/licenses/statistics`

**Query Parameters:**

* `period` (string) - Período (DAILY, WEEKLY, MONTHLY, YEARLY)

* `fromDate` (date) - Data inicial

* `toDate` (date) - Data final

* `groupBy` (string) - Agrupar por (licenseType, status)

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "issuer": {
      "id": "issuer-550e8400-e29b-41d4-a716-446655440000",
      "name": "Câmara Municipal da Praia"
    },
    "period": {
      "from": "2024-01-01",
      "to": "2024-01-31",
      "type": "MONTHLY"
    },
    "statistics": {
      "totalLicensesIssued": 45,
      "activeLicenses": 980,
      "pendingApplications": 12,
      "approvedApplications": 40,
      "rejectedApplications": 5,
      "byType": {
        "COMMERCIAL_OPERATION": 25,
        "TOURISM": 15,
        "FOOD_SERVICE": 5
      },
      "byStatus": {
        "ACTIVE": 35,
        "PENDING": 8,
        "SUSPENDED": 2
      },
      "revenue": {
        "totalFees": 292500.00,
        "averageFeePerLicense": 6500.00,
        "currency": "CVE"
      },
      "processingMetrics": {
        "averageProcessingDays": 12.5,
        "fastestProcessing": 5,
        "slowestProcessing": 25,
        "onTimeDelivery": 88.9
      }
    }
  }
}
```

### 4.4 Endpoints de Tipos de Licença Autorizados

#### 4.4.1 Adicionar Tipo de Licença Autorizado

**POST** `/api/v1/issuers/{id}/authorized-license-types`

**Request Body:**

```json
{
  "licenseType": "ENVIRONMENTAL",
  "effectiveDate": "2024-02-01T00:00:00Z",
  "specialConditions": [
    "Requer inspeção ambiental prévia",
    "Válido apenas para atividades de baixo impacto"
  ],
  "additionalFees": {
    "environmentalAssessmentFee": 1500.00,
    "inspectionFee": 800.00
  },
  "notes": "Autorização para licenças ambientais de baixo impacto"
}
```

#### 4.4.2 Remover Tipo de Licença Autorizado

**DELETE** `/api/v1/issuers/{issuerId}/authorized-license-types/{licenseType}`

**Query Parameters:**

* `effectiveDate` (datetime) - Data efetiva da remoção

* `reason` (string) - Motivo da remoção

#### 4.4.3 Listar Tipos de Licença Autorizados

**GET** `/api/v1/issuers/{id}/authorized-license-types`

**Query Parameters:**

* `includeInactive` (boolean, default: false) - Incluir tipos inativos

* `effectiveDate` (date) - Filtrar por data efetiva

### 4.5 Endpoints de Usuários do Emissor

#### 4.5.1 Listar Usuários do Emissor

**GET** `/api/v1/issuers/{id}/users`

**Query Parameters:**

* `role` (string) - Filtrar por função

* `status` (string) - Filtrar por status

* `includeInactive` (boolean, default: false) - Incluir usuários inativos

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "issuer": {
      "id": "issuer-550e8400-e29b-41d4-a716-446655440000",
      "name": "Câmara Municipal da Praia"
    },
    "users": [
      {
        "id": "user-123",
        "name": "Maria Santos Silva",
        "email": "maria.santos@cmpraia.cv",
        "role": "LICENSE_OFFICER",
        "status": "ACTIVE",
        "permissions": [
          "ISSUE_LICENSES",
          "REVIEW_APPLICATIONS",
          "APPROVE_RENEWALS"
        ],
        "lastLoginAt": "2024-01-15T09:30:00Z",
        "createdAt": "2024-01-01T10:00:00Z"
      },
      {
        "id": "user-456",
        "name": "João Pereira Costa",
        "email": "joao.pereira@cmpraia.cv",
        "role": "SUPERVISOR",
        "status": "ACTIVE",
        "permissions": [
          "MANAGE_USERS",
          "APPROVE_COMPLEX_CASES",
          "VIEW_REPORTS"
        ],
        "lastLoginAt": "2024-01-15T14:15:00Z",
        "createdAt": "2024-01-01T10:00:00Z"
      }
    ]
  }
}
```

#### 4.5.2 Adicionar Usuário ao Emissor

**POST** `/api/v1/issuers/{id}/users`

**Request Body:**

```json
{
  "userId": "user-789",
  "role": "LICENSE_OFFICER",
  "permissions": [
    "ISSUE_LICENSES",
    "REVIEW_APPLICATIONS"
  ],
  "effectiveDate": "2024-01-20T00:00:00Z",
  "notes": "Novo funcionário do departamento de licenciamento"
}
```

#### 4.5.3 Atualizar Função do Usuário

**PATCH** `/api/v1/issuers/{issuerId}/users/{userId}/role`

**Request Body:**

```json
{
  "newRole": "SUPERVISOR",
  "permissions": [
    "MANAGE_USERS",
    "APPROVE_COMPLEX_CASES",
    "VIEW_REPORTS"
  ],
  "effectiveDate": "2024-02-01T00:00:00Z",
  "reason": "Promoção por mérito"
}
```

### 4.6 Endpoints de Validação

#### 4.6.1 Validar Código de Emissor

**POST** `/api/v1/issuers/validate-code`

**Request Body:**

```json
{
  "issuerCode": "CM-PRAIA-001",
  "excludeIssuerId": "issuer-123" // Opcional, para excluir da validação
}
```

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "isValid": true,
    "isUnique": false,
    "formatValid": true,
    "existingIssuer": {
      "id": "issuer-existing-123",
      "issuerCode": "CM-PRAIA-001",
      "name": "Câmara Municipal da Praia",
      "status": "ACTIVE"
    },
    "validationDetails": {
      "formatChecks": {
        "prefixValid": true,
        "structureValid": true,
        "lengthValid": true
      }
    }
  }
}
```

#### 4.6.2 Verificar Jurisdição

**POST** `/api/v1/issuers/check-jurisdiction`

**Request Body:**

```json
{
  "location": {
    "island": "Santiago",
    "municipality": "Praia",
    "parish": "Nossa Senhora da Graça",
    "coordinates": {
      "latitude": 14.9177,
      "longitude": -23.5092
    }
  },
  "licenseType": "COMMERCIAL_OPERATION"
}
```

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "hasJurisdiction": true,
    "competentIssuers": [
      {
        "id": "issuer-550e8400-e29b-41d4-a716-446655440000",
        "name": "Câmara Municipal da Praia",
        "issuerCode": "CM-PRAIA-001",
        "jurisdictionMatch": "EXACT",
        "canIssue": true,
        "authorizedForLicenseType": true
      }
    ],
    "jurisdictionDetails": {
      "island": "Santiago",
      "municipality": "Praia",
      "parish": "Nossa Senhora da Graça",
      "withinBounds": true
    }
  }
}
```

### 4.7 Endpoints de Busca Avançada

#### 4.7.1 Busca por Critérios Múltiplos

**POST** `/api/v1/issuers/search`

**Request Body:**

```json
{
  "criteria": {
    "issuerTypes": ["MUNICIPAL_CHAMBER", "GOVERNMENT_AGENCY"],
    "statuses": ["ACTIVE"],
    "location": {
      "islands": ["Santiago", "São Vicente"],
      "municipalities": ["Praia", "Mindelo"]
    },
    "authorizedLicenseTypes": ["COMMERCIAL_OPERATION", "TOURISM"],
    "canIssue": true,
    "hasActiveUsers": true,
    "minLicensesIssued": 100,
    "establishmentDateRange": {
      "from": "1970-01-01",
      "to": "2020-12-31"
    }
  },
  "pagination": {
    "page": 0,
    "size": 25
  },
  "sorting": [
    {
      "field": "totalLicensesIssued",
      "direction": "DESC"
    }
  ]
}
```

#### 4.7.2 Emissores por Localização

**GET** `/api/v1/issuers/by-location`

**Query Parameters:**

* `island` (string) - Filtrar por ilha

* `municipality` (string) - Filtrar por município

* `parish` (string) - Filtrar por freguesia

* `latitude` (double) - Coordenada de latitude

* `longitude` (double) - Coordenada de longitude

* `radius` (double) - Raio de busca em km

* `licenseType` (string) - Tipo de licença requerida

### 4.8 Endpoints de Relatórios

#### 4.8.1 Relatório de Performance dos Emissores

**GET** `/api/v1/issuers/performance-report`

**Query Parameters:**

* `period` (string) - Período (MONTHLY, QUARTERLY, YEARLY)

* `fromDate` (date) - Data inicial

* `toDate` (date) - Data final

* `includeInactive` (boolean, default: false) - Incluir emissores inativos

* `groupBy` (string) - Agrupar por (issuerType, island, municipality)

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "reportPeriod": {
      "from": "2024-01-01",
      "to": "2024-01-31",
      "type": "MONTHLY"
    },
    "summary": {
      "totalIssuers": 15,
      "activeIssuers": 14,
      "totalLicensesIssued": 1250,
      "averageProcessingTime": 13.2,
      "totalRevenue": 8125000.00,
      "currency": "CVE"
    },
    "issuerPerformance": [
      {
        "issuer": {
          "id": "issuer-550e8400-e29b-41d4-a716-446655440000",
          "name": "Câmara Municipal da Praia",
          "issuerCode": "CM-PRAIA-001"
        },
        "metrics": {
          "licensesIssued": 45,
          "averageProcessingDays": 12.5,
          "approvalRate": 92.5,
          "revenue": 292500.00,
          "customerSatisfaction": 4.2,
          "onTimeDelivery": 88.9
        },
        "ranking": {
          "overall": 2,
          "efficiency": 1,
          "quality": 3
        }
      }
    ],
    "trends": {
      "licensesIssuedGrowth": 15.2,
      "processingTimeImprovement": -8.5,
      "revenueGrowth": 22.1
    }
  }
}
```

### 4.9 Tratamento de Erros

#### 4.9.1 Erro de Validação (400 Bad Request)

```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Dados de entrada inválidos",
    "details": [
      {
        "field": "issuerCode",
        "message": "Código do emissor deve seguir o formato XX-YYYY-NNN"
      },
      {
        "field": "jurisdiction.island",
        "message": "Ilha é obrigatória"
      },
      {
        "field": "contactInfo.primaryEmail",
        "message": "Email primário deve ser um endereço válido"
      }
    ]
  },
  "timestamp": "2024-01-15T10:30:00Z",
  "path": "/api/v1/issuers"
}
```

#### 4.9.2 Código de Emissor Duplicado (409 Conflict)

```json
{
  "success": false,
  "error": {
    "code": "DUPLICATE_ISSUER_CODE",
    "message": "Código de emissor já existe",
    "details": {
      "issuerCode": "CM-PRAIA-001",
      "existingIssuerId": "issuer-existing-123",
      "existingIssuerName": "Câmara Municipal da Praia",
      "createdAt": "2024-01-01T10:00:00Z"
    }
  },
  "timestamp": "2024-01-15T10:30:00Z",
  "path": "/api/v1/issuers"
}
```

#### 4.9.3 Emissor Não Encontrado (404 Not Found)

```json
{
  "success": false,
  "error": {
    "code": "ISSUER_NOT_FOUND",
    "message": "Emissor não encontrado",
    "details": {
      "issuerId": "issuer-550e8400-e29b-41d4-a716-446655440000"
    }
  },
  "timestamp": "2024-01-15T10:30:00Z",
  "path": "/api/v1/issuers/issuer-550e8400-e29b-41d4-a716-446655440000"
}
```

#### 4.9.4 Operação Não Permitida (422 Unprocessable Entity)

```json
{
  "success": false,
  "error": {
    "code": "OPERATION_NOT_ALLOWED",
    "message": "Operação não permitida no status atual do emissor",
    "details": {
      "issuerId": "issuer-123",
      "currentStatus": "SUSPENDED",
      "attemptedOperation": "ISSUE_LICENSE",
      "allowedOperations": ["VIEW", "UPDATE_CONTACT_INFO"],
      "reason": "Emissores suspensos não podem emitir licenças"
    }
  },
  "timestamp": "2024-01-15T10:30:00Z",
  "path": "/api/v1/issuers/issuer-123/licenses"
}
```

## 7. Considerações de Implementação

### 7.1 Performance

* **Índices de busca**: Implementar índices compostos para consultas frequentes por tipo, status e jurisdição

* **Cache de competências**: Implementar cache Redis para consultas de competências ativas por tipo de licença

* **Paginação**: Usar paginação em todas as consultas de listagem para evitar sobrecarga

* **Lazy loading**: Configurar carregamento lazy para relacionamentos não essenciais

### 7.2 Segurança

* **Autorização**: Implementar controle de acesso baseado em roles para operações de gestão de emissores

* **Auditoria**: Registrar todas as operações de criação, atualização e concessão de competências

* **Validação**: Validar dados de entrada rigorosamente, especialmente códigos de emissor e competências

* **Encriptação**: Proteger informações sensíveis de contato e acreditação

### 7.3 Integração

* **Eventos de domínio**: Publicar eventos para notificar outros bounded contexts sobre mudanças de emissores

* **APIs externas**: Integrar com sistemas de acreditação governamental para validação automática

* **Sincronização**: Implementar mecanismos de sincronização com registros oficiais de entidades

### 7.4 Testes e Qualidade

* **Cobertura de testes**: Manter cobertura mínima de 90% para lógica de domínio

* **Testes de contrato**: Implementar testes de contrato para APIs públicas

* **Testes de performance**: Validar performance das consultas de competências e jurisdições

* **Monitoramento**: Implementar métricas para acompanhar uso de competências e expiração de acreditações

```
```

