# PR02.02-BE-LIC-Gestão de Titulares de Licença

## 1. Visão Geral

Este documento especifica a implementação do módulo de **Gestão de Titulares de Licença** para o Sistema de Licenciamento de Cabo Verde. O módulo é responsável pelo registro, validação e gestão de pessoas físicas e jurídicas que podem ser titulares de licenças, incluindo validação de documentos de identificação, verificação de capacidade legal e gestão de representantes legais.

### 1.1 Objetivos

* Implementar modelo de dados unificado para pessoas físicas e jurídicas

* Implementar arquitetura DDD para gestão de titulares e suas capacidades

* Fornecer APIs REST para registro, consulta e atualização de titulares

* Garantir validações robustas de documentos de identificação

* Suportar gestão de representantes legais e procurações

* Implementar verificações de capacidade legal e conformidade

## 2. Modelo de Dados Normalizado

### 2.1 Diagrama ER

```mermaid
erDiagram
    T_LICENSE_HOLDER {
        uuid id PK
        varchar holder_type
        varchar identification_number
        varchar identification_type
        varchar name
        varchar trade_name
        varchar email
        varchar phone
        varchar address
        varchar parish
        varchar municipality
        varchar island
        varchar postal_code
        varchar nationality
        date birth_date
        varchar gender
        varchar marital_status
        varchar tax_number
        varchar social_security_number
        varchar legal_capacity_status
        varchar status
        boolean active
        jsonb metadata
        timestamp created_date
        timestamp last_modified_date
        varchar created_by
        varchar last_modified_by
    }

    T_INDIVIDUAL_HOLDER {
        uuid id PK
        uuid holder_id_fk FK
        varchar full_name
        varchar father_name
        varchar mother_name
        varchar birth_place
        varchar profession
        varchar education_level
        timestamp created_date
        timestamp last_modified_date
    }

    T_CORPORATE_HOLDER {
        uuid id PK
        uuid holder_id_fk FK
        varchar legal_name
        varchar trade_name
        varchar company_type
        varchar business_sector
        varchar registration_number
        date incorporation_date
        varchar incorporation_country
        decimal share_capital
        timestamp created_date
        timestamp last_modified_date
    }

    T_LEGAL_REPRESENTATIVE {
        uuid id PK
        uuid corporate_holder_id_fk FK
        varchar representative_name
        varchar identification_type
        varchar identification_number
        varchar representation_type
        text powers_description
        date appointment_date
        date termination_date
        varchar status
        timestamp created_date
        timestamp last_modified_date
    }

    T_HOLDER_DOCUMENT {
        uuid id PK
        uuid holder_id_fk FK
        varchar document_type
        varchar document_name
        varchar document_url
        varchar mime_type
        bigint file_size
        varchar status
        date issue_date
        date expiry_date
        varchar issuing_authority
        timestamp created_date
        timestamp last_modified_date
    }

    T_LICENSE_HOLDER ||--o| T_INDIVIDUAL_HOLDER : "extends"
    T_LICENSE_HOLDER ||--o| T_CORPORATE_HOLDER : "extends"
    T_CORPORATE_HOLDER ||--o{ T_LEGAL_REPRESENTATIVE : "has representatives"
    T_LICENSE_HOLDER ||--o{ T_HOLDER_DOCUMENT : "has documents"
```

## 3. Arquitetura DDD

### 3.1 Domain Layer

#### 3.1.1 Aggregate Root: LicenseHolder

```java
@Entity
@Table(name = "t_license_holder")
@Inheritance(strategy = InheritanceType.JOINED)
@DiscriminatorColumn(name = "holder_type")
public abstract class LicenseHolder extends AggregateRoot<LicenseHolderId> {
    
    @EmbeddedId
    private LicenseHolderId id;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "holder_type", insertable = false, updatable = false)
    private HolderType holderType;
    
    @Embedded
    private Identification identification;
    
    @Column(name = "name", nullable = false)
    private String name;
    
    @Embedded
    private ContactInfo contactInfo;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "legal_capacity_status")
    private LegalCapacityStatus legalCapacityStatus;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status")
    private HolderStatus status;
    
    @OneToMany(mappedBy = "holder", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<HolderDocument> documents = new ArrayList<>();
    
    // Métodos de negócio abstratos
    public abstract boolean isEligibleForLicense(LicenseType licenseType);
    public abstract void validateForLicenseApplication(LicenseType licenseType);
    
    // Métodos de negócio comuns
    public void updateContactInfo(ContactInfo newContactInfo, String updatedBy) {
        this.contactInfo = newContactInfo;
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
        
        addDomainEvent(new HolderContactUpdatedEvent(this.id));
    }
    
    public void addDocument(String documentType, String documentName, 
                           String documentUrl, String mimeType, Long fileSize,
                           LocalDate issueDate, LocalDate expiryDate, 
                           String issuingAuthority, String uploadedBy) {
        
        HolderDocument document = HolderDocument.create(
            this, documentType, documentName, documentUrl, mimeType, 
            fileSize, issueDate, expiryDate, issuingAuthority, uploadedBy
        );
        
        this.documents.add(document);
        
        addDomainEvent(new HolderDocumentAddedEvent(this.id, document.getId()));
    }
    
    public void activate(String updatedBy) {
        if (this.status == HolderStatus.ACTIVE) {
            throw new DomainException("Holder is already active");
        }
        
        validateLegalCapacity();
        
        this.status = HolderStatus.ACTIVE;
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
        
        addDomainEvent(new HolderActivatedEvent(this.id));
    }
    
    public void suspend(String reason, String updatedBy) {
        if (this.status != HolderStatus.ACTIVE) {
            throw new DomainException("Only active holders can be suspended");
        }
        
        this.status = HolderStatus.SUSPENDED;
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
        
        addDomainEvent(new HolderSuspendedEvent(this.id, reason));
    }
    
    private void validateLegalCapacity() {
        if (this.legalCapacityStatus != LegalCapacityStatus.CAPABLE) {
            throw new DomainException("Holder does not have legal capacity");
        }
    }
    
    // Getters
    public LicenseHolderId getId() { return id; }
    public HolderType getHolderType() { return holderType; }
    public Identification getIdentification() { return identification; }
    public String getName() { return name; }
    public ContactInfo getContactInfo() { return contactInfo; }
    public LegalCapacityStatus getLegalCapacityStatus() { return legalCapacityStatus; }
    public HolderStatus getStatus() { return status; }
    public List<HolderDocument> getDocuments() { return Collections.unmodifiableList(documents); }
}
```

### 3.2 Value Objects

#### 3.2.1 LicenseHolderId

```java
@Embeddable
public class LicenseHolderId {
    @Column(name = "id")
    private UUID value;
    
    protected LicenseHolderId() {}
    
    private LicenseHolderId(UUID value) {
        this.value = Objects.requireNonNull(value, "LicenseHolderId cannot be null");
    }
    
    public static LicenseHolderId of(UUID value) {
        return new LicenseHolderId(value);
    }
    
    public static LicenseHolderId generate() {
        return new LicenseHolderId(UUID.randomUUID());
    }
    
    public UUID getValue() {
        return value;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        LicenseHolderId that = (LicenseHolderId) o;
        return Objects.equals(value, that.value);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }
    
    @Override
    public String toString() {
        return value.toString();
    }
}
```

#### 3.2.2 Identification

```java
@Embeddable
public class Identification {
    @Enumerated(EnumType.STRING)
    @Column(name = "identification_type")
    private IdentificationType type;
    
    @Column(name = "identification_number")
    private String number;
    
    @Column(name = "issuing_country")
    private String issuingCountry;
    
    @Column(name = "issue_date")
    private LocalDate issueDate;
    
    @Column(name = "expiry_date")
    private LocalDate expiryDate;
    
    protected Identification() {}
    
    private Identification(IdentificationType type, String number, String issuingCountry,
                          LocalDate issueDate, LocalDate expiryDate) {
        validateParameters(type, number, issuingCountry);
        
        this.type = type;
        this.number = number.trim().toUpperCase();
        this.issuingCountry = issuingCountry.trim().toUpperCase();
        this.issueDate = issueDate;
        this.expiryDate = expiryDate;
    }
    
    public static Identification of(IdentificationType type, String number, String issuingCountry,
                                   LocalDate issueDate, LocalDate expiryDate) {
        return new Identification(type, number, issuingCountry, issueDate, expiryDate);
    }
    
    public boolean isExpired() {
        return expiryDate != null && expiryDate.isBefore(LocalDate.now());
    }
    
    public boolean isValid() {
        return !isExpired() && isValidFormat();
    }
    
    private boolean isValidFormat() {
        return switch (type) {
            case PASSPORT -> number.matches("[A-Z]{2}\\d{7}");
            case NATIONAL_ID -> number.matches("\\d{8,12}");
            case DRIVER_LICENSE -> number.matches("[A-Z0-9]{8,15}");
            case TAX_ID -> number.matches("\\d{9,15}");
            case COMPANY_REGISTRATION -> number.matches("[A-Z0-9]{6,20}");
        };
    }
    
    private static void validateParameters(IdentificationType type, String number, String issuingCountry) {
        if (type == null) {
            throw new DomainException("Identification type is required");
        }
        if (number == null || number.trim().isEmpty()) {
            throw new DomainException("Identification number is required");
        }
        if (issuingCountry == null || issuingCountry.trim().isEmpty()) {
            throw new DomainException("Issuing country is required");
        }
    }
    
    // Getters
    public IdentificationType getType() { return type; }
    public String getNumber() { return number; }
    public String getIssuingCountry() { return issuingCountry; }
    public LocalDate getIssueDate() { return issueDate; }
    public LocalDate getExpiryDate() { return expiryDate; }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Identification that = (Identification) o;
        return type == that.type && Objects.equals(number, that.number) &&
               Objects.equals(issuingCountry, that.issuingCountry);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(type, number, issuingCountry);
    }
}
```

#### 3.2.3 ContactInfo

```java
@Embeddable
public class ContactInfo {
    @Column(name = "primary_phone")
    private String primaryPhone;
    
    @Column(name = "secondary_phone")
    private String secondaryPhone;
    
    @Column(name = "email")
    private String email;
    
    @Column(name = "website")
    private String website;
    
    @Embedded
    @AttributeOverrides({
        @AttributeOverride(name = "street", column = @Column(name = "address_street")),
        @AttributeOverride(name = "city", column = @Column(name = "address_city")),
        @AttributeOverride(name = "state", column = @Column(name = "address_state")),
        @AttributeOverride(name = "postalCode", column = @Column(name = "address_postal_code")),
        @AttributeOverride(name = "country", column = @Column(name = "address_country"))
    })
    private Address address;
    
    protected ContactInfo() {}
    
    private ContactInfo(String primaryPhone, String secondaryPhone, String email,
                       String website, Address address) {
        this.primaryPhone = primaryPhone;
        this.secondaryPhone = secondaryPhone;
        this.email = validateAndNormalizeEmail(email);
        this.website = website;
        this.address = address;
    }
    
    public static ContactInfo of(String primaryPhone, String secondaryPhone, String email,
                                String website, Address address) {
        return new ContactInfo(primaryPhone, secondaryPhone, email, website, address);
    }
    
    private String validateAndNormalizeEmail(String email) {
        if (email != null && !email.trim().isEmpty()) {
            String normalizedEmail = email.trim().toLowerCase();
            if (!normalizedEmail.matches("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$")) {
                throw new DomainException("Invalid email format");
            }
            return normalizedEmail;
        }
        return email;
    }
    
    // Getters
    public String getPrimaryPhone() { return primaryPhone; }
    public String getSecondaryPhone() { return secondaryPhone; }
    public String getEmail() { return email; }
    public String getWebsite() { return website; }
    public Address getAddress() { return address; }
}
```

#### 3.2.4 PersonalInfo

```java
@Embeddable
public class PersonalInfo {
    @Column(name = "birth_date")
    private LocalDate birthDate;
    
    @Column(name = "birth_place")
    private String birthPlace;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "gender")
    private Gender gender;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "marital_status")
    private MaritalStatus maritalStatus;
    
    @Column(name = "nationality")
    private String nationality;
    
    @Column(name = "profession")
    private String profession;
    
    protected PersonalInfo() {}
    
    private PersonalInfo(LocalDate birthDate, String birthPlace, Gender gender,
                        MaritalStatus maritalStatus, String nationality, String profession) {
        validateParameters(birthDate, gender);
        
        this.birthDate = birthDate;
        this.birthPlace = birthPlace;
        this.gender = gender;
        this.maritalStatus = maritalStatus;
        this.nationality = nationality;
        this.profession = profession;
    }
    
    public static PersonalInfo of(LocalDate birthDate, String birthPlace, Gender gender,
                                 MaritalStatus maritalStatus, String nationality, String profession) {
        return new PersonalInfo(birthDate, birthPlace, gender, maritalStatus, nationality, profession);
    }
    
    public int getAge() {
        return Period.between(birthDate, LocalDate.now()).getYears();
    }
    
    public boolean isOfLegalAge() {
        return getAge() >= 18;
    }
    
    private static void validateParameters(LocalDate birthDate, Gender gender) {
        if (birthDate == null) {
            throw new DomainException("Birth date is required");
        }
        if (birthDate.isAfter(LocalDate.now())) {
            throw new DomainException("Birth date cannot be in the future");
        }
        if (gender == null) {
            throw new DomainException("Gender is required");
        }
    }
    
    // Getters
    public LocalDate getBirthDate() { return birthDate; }
    public String getBirthPlace() { return birthPlace; }
    public Gender getGender() { return gender; }
    public MaritalStatus getMaritalStatus() { return maritalStatus; }
    public String getNationality() { return nationality; }
    public String getProfession() { return profession; }
}
```

#### 3.2.5 CompanyInfo

```java
@Embeddable
public class CompanyInfo {
    @Column(name = "incorporation_date")
    private LocalDate incorporationDate;
    
    @Column(name = "incorporation_country")
    private String incorporationCountry;
    
    @Column(name = "business_sector")
    private String businessSector;
    
    @Column(name = "company_size")
    private String companySize;
    
    @Column(name = "annual_revenue")
    private BigDecimal annualRevenue;
    
    @Column(name = "employee_count")
    private Integer employeeCount;
    
    protected CompanyInfo() {}
    
    private CompanyInfo(LocalDate incorporationDate, String incorporationCountry,
                       String businessSector, String companySize,
                       BigDecimal annualRevenue, Integer employeeCount) {
        validateParameters(incorporationDate, incorporationCountry);
        
        this.incorporationDate = incorporationDate;
        this.incorporationCountry = incorporationCountry.trim().toUpperCase();
        this.businessSector = businessSector;
        this.companySize = companySize;
        this.annualRevenue = annualRevenue;
        this.employeeCount = employeeCount;
    }
    
    public static CompanyInfo of(LocalDate incorporationDate, String incorporationCountry,
                                String businessSector, String companySize,
                                BigDecimal annualRevenue, Integer employeeCount) {
        return new CompanyInfo(incorporationDate, incorporationCountry, businessSector,
                              companySize, annualRevenue, employeeCount);
    }
    
    public int getCompanyAge() {
        return Period.between(incorporationDate, LocalDate.now()).getYears();
    }
    
    private static void validateParameters(LocalDate incorporationDate, String incorporationCountry) {
        if (incorporationDate == null) {
            throw new DomainException("Incorporation date is required");
        }
        if (incorporationDate.isAfter(LocalDate.now())) {
            throw new DomainException("Incorporation date cannot be in the future");
        }
        if (incorporationCountry == null || incorporationCountry.trim().isEmpty()) {
            throw new DomainException("Incorporation country is required");
        }
    }
    
    // Getters
    public LocalDate getIncorporationDate() { return incorporationDate; }
    public String getIncorporationCountry() { return incorporationCountry; }
    public String getBusinessSector() { return businessSector; }
    public String getCompanySize() { return companySize; }
    public BigDecimal getAnnualRevenue() { return annualRevenue; }
    public Integer getEmployeeCount() { return employeeCount; }
}
```

### 3.3 Enums

#### 3.3.1 HolderType

```java
public enum HolderType {
    INDIVIDUAL("Individual"),
    COMPANY("Company");
    
    private final String displayName;
    
    HolderType(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
}
```

#### 3.3.2 IdentificationType

```java
public enum IdentificationType {
    PASSPORT("Passport"),
    NATIONAL_ID("National ID"),
    DRIVER_LICENSE("Driver License"),
    TAX_ID("Tax ID"),
    COMPANY_REGISTRATION("Company Registration");
    
    private final String displayName;
    
    IdentificationType(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
    
    public boolean isForIndividual() {
        return this == PASSPORT || this == NATIONAL_ID || this == DRIVER_LICENSE || this == TAX_ID;
    }
    
    public boolean isForCompany() {
        return this == COMPANY_REGISTRATION || this == TAX_ID;
    }
}
```

#### 3.3.3 LegalCapacityStatus

```java
public enum LegalCapacityStatus {
    PENDING("Pending Verification"),
    VERIFIED("Verified"),
    RESTRICTED("Restricted"),
    SUSPENDED("Suspended");
    
    private final String displayName;
    
    LegalCapacityStatus(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
    
    public boolean allowsLicensing() {
        return this == VERIFIED;
    }
}
```

#### 3.3.4 HolderStatus

```java
public enum HolderStatus {
    ACTIVE("Active"),
    INACTIVE("Inactive"),
    SUSPENDED("Suspended"),
    BLOCKED("Blocked");
    
    private final String displayName;
    
    HolderStatus(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
    
    public boolean isOperational() {
        return this == ACTIVE;
    }
}
```

#### 3.3.5 Gender

```java
public enum Gender {
    MALE("Male"),
    FEMALE("Female"),
    OTHER("Other");
    
    private final String displayName;
    
    Gender(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
}
```

#### 3.3.6 MaritalStatus

```java
public enum MaritalStatus {
    SINGLE("Single"),
    MARRIED("Married"),
    DIVORCED("Divorced"),
    WIDOWED("Widowed"),
    SEPARATED("Separated");
    
    private final String displayName;
    
    MaritalStatus(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
}
```

#### 3.3.7 VerificationType

```java
public enum VerificationType {
    LEGAL_CAPACITY("Legal Capacity"),
    CRIMINAL_BACKGROUND("Criminal Background"),
    FINANCIAL_CAPACITY("Financial Capacity"),
    PROFESSIONAL_QUALIFICATION("Professional Qualification");
    
    private final String displayName;
    
    VerificationType(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
    
    public boolean isRequiredForIndividual() {
        return this == LEGAL_CAPACITY || this == CRIMINAL_BACKGROUND;
    }
    
    public boolean isRequiredForCompany() {
        return this == LEGAL_CAPACITY || this == FINANCIAL_CAPACITY;
    }
}
```

#### 3.3.8 VerificationStatus

```java
public enum VerificationStatus {
    PENDING("Pending"),
    IN_PROGRESS("In Progress"),
    VERIFIED("Verified"),
    REJECTED("Rejected"),
    EXPIRED("Expired");
    
    private final String displayName;
    
    VerificationStatus(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
    
    public boolean isCompleted() {
        return this == VERIFIED || this == REJECTED;
    }
}
```

### 3.4 Interfaces de Repositório

#### 3.4.1 LicenseHolderRepository

```java
@Repository
public interface LicenseHolderRepository extends JpaRepository<LicenseHolder, LicenseHolderId> {
    
    // Busca por identificação
    Optional<LicenseHolder> findByIdentification_TypeAndIdentification_Number(
        IdentificationType type, String number);
    
    // Busca por status
    Page<LicenseHolder> findByStatus(HolderStatus status, Pageable pageable);
    
    // Busca por tipo de titular
    Page<LicenseHolder> findByHolderType(HolderType holderType, Pageable pageable);
    
    // Busca por status de capacidade legal
    Page<LicenseHolder> findByLegalCapacityStatus(LegalCapacityStatus status, Pageable pageable);
    
    // Busca por nome (case insensitive)
    Page<LicenseHolder> findByNameContainingIgnoreCase(String name, Pageable pageable);
    
    // Busca por email
    Optional<LicenseHolder> findByContactInfo_Email(String email);
    
    // Busca por telefone
    Optional<LicenseHolder> findByContactInfo_PrimaryPhone(String phone);
    
    // Busca por critérios múltiplos
    @Query("SELECT h FROM LicenseHolder h WHERE " +
           "(:holderType IS NULL OR h.holderType = :holderType) AND " +
           "(:status IS NULL OR h.status = :status) AND " +
           "(:legalCapacityStatus IS NULL OR h.legalCapacityStatus = :legalCapacityStatus) AND " +
           "(:name IS NULL OR LOWER(h.name) LIKE LOWER(CONCAT('%', :name, '%'))) AND " +
           "(:identificationType IS NULL OR h.identification.type = :identificationType) AND " +
           "(:identificationNumber IS NULL OR h.identification.number = :identificationNumber)")
    Page<LicenseHolder> findByCriteria(
        @Param("holderType") HolderType holderType,
        @Param("status") HolderStatus status,
        @Param("legalCapacityStatus") LegalCapacityStatus legalCapacityStatus,
        @Param("name") String name,
        @Param("identificationType") IdentificationType identificationType,
        @Param("identificationNumber") String identificationNumber,
        Pageable pageable);
    
    // Verificar existência por identificação
    boolean existsByIdentification_TypeAndIdentification_Number(
        IdentificationType type, String number);
    
    // Verificar existência por email
    boolean existsByContactInfo_Email(String email);
    
    // Buscar titulares com documentos expirados
    @Query("SELECT DISTINCT h FROM LicenseHolder h JOIN h.documents d WHERE " +
           "d.expiryDate < CURRENT_DATE AND d.status = 'ACTIVE'")
    List<LicenseHolder> findHoldersWithExpiredDocuments();

## 4. REST API Specification

### 4.1 Base Configuration

**Base URL:** `/api/v1/license-holders`

**Headers Obrigatórios:**

```

Content-Type: application/json
Authorization: Bearer {jwt\_token}
X-Request-ID: {unique\_request\_id}

```

**Códigos de Status Padrão:**

```

* `200 OK` - Operação bem-sucedida

* `201 Created` - Recurso criado com sucesso

* `400 Bad Request` - Dados inválidos na requisição

* `401 Unauthorized` - Token de autenticação inválido

* `403 Forbidden` - Acesso negado

* `404 Not Found` - Recurso não encontrado

* `409 Conflict` - Conflito de dados (ex: documento duplicado)

* `422 Unprocessable Entity` - Erro de validação de negócio

* `500 Internal Server Error` - Erro interno do servidor

````

### 4.2 Endpoints de Titulares

#### 4.2.1 Criar Titular Pessoa Física

**POST** `/api/v1/license-holders`

**Request Body:**

```json
{
  "holderType": "INDIVIDUAL",
  "name": "João Silva Santos",
  "identification": {
    "type": "NATIONAL_ID",
    "number": "123456789",
    "issuingCountry": "CV",
    "issueDate": "2020-01-15",
    "expiryDate": "2030-01-15"
  },
  "personalInfo": {
    "birthDate": "1985-03-15",
    "birthPlace": "Praia, Santiago",
    "gender": "MALE",
    "maritalStatus": "SINGLE",
    "nationality": "CV",
    "profession": "Empresário"
  },
  "contactInfo": {
    "primaryPhone": "+238 991 2345",
    "email": "joao.santos@email.cv",
    "address": {
      "street": "Rua da Liberdade, 45",
      "city": "Praia",
      "state": "Santiago",
      "postalCode": "7600-010",
      "country": "CV"
    }
  }
}
````

**Response (201 Created):**

```json
{
  "success": true,
  "data": {
    "id": "holder-550e8400-e29b-41d4-a716-446655440000",
    "holderType": "INDIVIDUAL",
    "name": "João Silva Santos",
    "identification": {
      "type": "NATIONAL_ID",
      "number": "123456789",
      "issuingCountry": "CV",
      "issueDate": "2020-01-15",
      "expiryDate": "2030-01-15",
      "isValid": true,
      "isExpired": false
    },
    "personalInfo": {
      "birthDate": "1985-03-15",
      "age": 39,
      "gender": "MALE",
      "nationality": "CV",
      "isOfLegalAge": true
    },
    "status": "ACTIVE",
    "legalCapacityStatus": "PENDING",
    "createdAt": "2025-01-15T10:30:00Z",
    "createdBy": "user123"
  },
  "message": "Titular pessoa física criado com sucesso"
}
```

#### 4.2.2 Criar Titular Pessoa Jurídica

**POST** `/api/v1/license-holders`

**Request Body:**

```json
{
  "holderType": "COMPANY",
  "name": "Empresa Cabo Verde Lda",
  "tradeName": "CV Negócios",
  "identification": {
    "type": "COMPANY_REGISTRATION",
    "number": "REG789456123",
    "issuingCountry": "CV",
    "issueDate": "2020-05-10"
  },
  "companyInfo": {
    "incorporationDate": "2020-05-10",
    "incorporationCountry": "CV",
    "businessSector": "Comércio",
    "companySize": "SMALL",
    "annualRevenue": 500000.00,
    "employeeCount": 15
  },
  "contactInfo": {
    "primaryPhone": "+238 260 7890",
    "email": "contato@cvnegocios.cv",
    "website": "https://www.cvnegocios.cv",
    "address": {
      "street": "Avenida Cidade de Lisboa, 100",
      "city": "Praia",
      "state": "Santiago",
      "postalCode": "7600-020",
      "country": "CV"
    }
  }
}
```

#### 4.2.3 Buscar Titular por ID

**GET** `/api/v1/license-holders/{id}`

**Path Parameters:**

* `id` (UUID) - ID único do titular

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "id": "holder-550e8400-e29b-41d4-a716-446655440000",
    "holderType": "INDIVIDUAL",
    "name": "João Silva Santos",
    "identification": {
      "type": "NATIONAL_ID",
      "number": "123456789",
      "issuingCountry": "CV",
      "issueDate": "2020-01-15",
      "expiryDate": "2030-01-15",
      "isValid": true,
      "isExpired": false
    },
    "personalInfo": {
      "birthDate": "1985-03-15",
      "birthPlace": "Praia, Santiago",
      "age": 39,
      "gender": "MALE",
      "maritalStatus": "SINGLE",
      "nationality": "CV",
      "profession": "Empresário",
      "isOfLegalAge": true
    },
    "contactInfo": {
      "primaryPhone": "+238 991 2345",
      "email": "joao.santos@email.cv",
      "address": {
        "street": "Rua da Liberdade, 45",
        "city": "Praia",
        "state": "Santiago",
        "postalCode": "7600-010",
        "country": "CV"
      }
    },
    "licenses": [
      {
        "id": "license-123",
        "licenseNumber": "LIC-2025-001",
        "licenseType": "COMMERCIAL_OPERATION",
        "status": "ACTIVE",
        "issueDate": "2025-01-10",
        "expiryDate": "2025-01-10"
      }
    ],
    "verifications": [
      {
        "type": "LEGAL_CAPACITY",
        "status": "VERIFIED",
        "verifiedAt": "2025-01-12T14:30:00Z",
        "verifiedBy": "system"
      }
    ],
    "status": "ACTIVE",
    "legalCapacityStatus": "VERIFIED",
    "createdAt": "2025-01-15T10:30:00Z",
    "updatedAt": "2025-01-15T10:30:00Z"
  }
}
```

#### 4.2.4 Listar Titulares

**GET** `/api/v1/license-holders`

**Query Parameters:**

* `page` (int, default: 0) - Número da página

* `size` (int, default: 20, max: 100) - Tamanho da página

* `sort` (string, default: "createdAt,desc") - Ordenação

* `holderType` (string) - Filtrar por tipo (INDIVIDUAL, COMPANY)

* `status` (string) - Filtrar por status

* `legalCapacityStatus` (string) - Filtrar por status de capacidade legal

* `identificationType` (string) - Filtrar por tipo de identificação

* `nationality` (string) - Filtrar por nacionalidade

* `search` (string) - Busca textual em nome

* `email` (string) - Buscar por email

* `phone` (string) - Buscar por telefone

* `identificationNumber` (string) - Buscar por número de identificação

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "content": [
      {
        "id": "holder-550e8400-e29b-41d4-a716-446655440000",
        "holderType": "INDIVIDUAL",
        "name": "João Silva Santos",
        "identification": {
          "type": "NATIONAL_ID",
          "number": "123456789",
          "isExpired": false
        },
        "contactInfo": {
          "primaryPhone": "+238 991 2345",
          "email": "joao.santos@email.cv"
        },
        "status": "ACTIVE",
        "legalCapacityStatus": "VERIFIED",
        "activeLicensesCount": 2,
        "createdAt": "2025-01-15T10:30:00Z"
      }
    ],
    "pageable": {
      "page": 0,
      "size": 20,
      "sort": "createdAt,desc"
    },
    "totalElements": 1,
    "totalPages": 1,
    "first": true,
    "last": true
  }
}
```

#### 4.2.5 Atualizar Titular

**PUT** `/api/v1/license-holders/{id}`

**Request Body:**

```json
{
  "name": "João Silva Santos Atualizado",
  "contactInfo": {
    "primaryPhone": "+238 991 9999",
    "secondaryPhone": "+238 991 8888",
    "email": "joao.santos.novo@email.cv",
    "address": {
      "street": "Rua Nova da Liberdade, 50",
      "city": "Praia",
      "state": "Santiago",
      "postalCode": "7600-015",
      "country": "CV"
    }
  },
  "personalInfo": {
    "profession": "Consultor Empresarial",
    "maritalStatus": "MARRIED"
  }
}
```

#### 4.2.6 Atualizar Identificação

**PATCH** `/api/v1/license-holders/{id}/identification`

**Request Body:**

```json
{
  "type": "PASSPORT",
  "number": "CV1234567",
  "issuingCountry": "CV",
  "issueDate": "2023-06-01",
  "expiryDate": "2033-06-01"
}
```

#### 4.2.7 Alterar Status

**PATCH** `/api/v1/license-holders/{id}/status`

**Request Body:**

```json
{
  "status": "SUSPENDED",
  "reason": "Documentação vencida",
  "notes": "Documento de identificação expirado em 2025-01-01",
  "effectiveDate": "2025-01-15T10:00:00Z"
}
```

### 4.3 Endpoints de Verificações

#### 4.3.1 Iniciar Verificação

**POST** `/api/v1/license-holders/{holderId}/verifications`

**Request Body:**

```json
{
  "verificationType": "LEGAL_CAPACITY",
  "priority": "HIGH",
  "notes": "Verificação para emissão de licença comercial",
  "requiredDocuments": [
    "CRIMINAL_RECORD",
    "FINANCIAL_STATEMENT"
  ]
}
```

**Response (201 Created):**

```json
{
  "success": true,
  "data": {
    "id": "verification-789",
    "verificationType": "LEGAL_CAPACITY",
    "status": "PENDING",
    "priority": "HIGH",
    "requestedAt": "2025-01-15T11:00:00Z",
    "requestedBy": "user123",
    "estimatedCompletionDate": "2025-01-20T17:00:00Z"
  }
}
```

#### 4.3.2 Listar Verificações do Titular

**GET** `/api/v1/license-holders/{holderId}/verifications`

**Query Parameters:**

* `verificationType` (string) - Filtrar por tipo de verificação

* `status` (string) - Filtrar por status

* `includeCompleted` (boolean, default: true) - Incluir verificações concluídas

#### 4.3.3 Atualizar Status de Verificação

**PATCH** `/api/v1/license-holders/{holderId}/verifications/{verificationId}/status`

**Request Body:**

```json
{
  "status": "VERIFIED",
  "verifierNotes": "Documentação completa e válida",
  "verifiedBy": "verifier123",
  "verificationDate": "2025-01-18T15:30:00Z",
  "validUntil": "2025-01-18T23:59:59Z"
}
```

### 4.4 Endpoints de Licenças do Titular

#### 4.4.1 Listar Licenças do Titular

**GET** `/api/v1/license-holders/{holderId}/licenses`

**Query Parameters:**

* `status` (string) - Filtrar por status da licença

* `licenseType` (string) - Filtrar por tipo de licença

* `includeExpired` (boolean, default: false) - Incluir licenças expiradas

* `includeHistory` (boolean, default: false) - Incluir histórico completo

**Response (200 OK):**

```json
{
  "success": true,
  "data": [
    {
      "id": "license-123",
      "licenseNumber": "LIC-2025-001",
      "licenseType": "COMMERCIAL_OPERATION",
      "status": "ACTIVE",
      "issueDate": "2025-01-10",
      "expiryDate": "2025-01-10",
      "establishment": {
        "id": "est-456",
        "name": "Restaurante Sabores",
        "municipality": "Praia"
      },
      "issuer": {
        "id": "issuer-789",
        "name": "Câmara Municipal da Praia"
      },
      "renewalEligible": true,
      "daysUntilExpiry": 360
    }
  ]
}
```

#### 4.4.2 Histórico de Licenças

**GET** `/api/v1/license-holders/{holderId}/licenses/history`

**Query Parameters:**

* `page` (int, default: 0) - Número da página

* `size` (int, default: 20) - Tamanho da página

* `fromDate` (date) - Data inicial do período

* `toDate` (date) - Data final do período

* `licenseType` (string) - Filtrar por tipo de licença

### 4.5 Endpoints de Validação

#### 4.5.1 Validar Identificação

**POST** `/api/v1/license-holders/validate-identification`

**Request Body:**

```json
{
  "identificationType": "NATIONAL_ID",
  "identificationNumber": "123456789",
  "issuingCountry": "CV",
  "excludeHolderId": "holder-123" // Opcional, para excluir da validação
}
```

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "isValid": true,
    "isUnique": false,
    "formatValid": true,
    "checksumValid": true,
    "existingHolder": {
      "id": "holder-existing-123",
      "name": "João Silva Santos",
      "status": "ACTIVE"
    },
    "validationDetails": {
      "formatChecks": {
        "lengthValid": true,
        "patternValid": true,
        "characterSetValid": true
      }
    }
  }
}
```

#### 4.5.2 Verificar Elegibilidade para Licença

**POST** `/api/v1/license-holders/{holderId}/check-license-eligibility`

**Request Body:**

```json
{
  "licenseType": "COMMERCIAL_OPERATION",
  "establishmentId": "est-456",
  "checkCriteria": {
    "verifyLegalCapacity": true,
    "checkActiveRestrictions": true,
    "validateDocuments": true
  }
}
```

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "isEligible": true,
    "eligibilityScore": 95,
    "checks": {
      "legalCapacity": {
        "status": "PASSED",
        "details": "Capacidade legal verificada"
      },
      "activeRestrictions": {
        "status": "PASSED",
        "details": "Nenhuma restrição ativa encontrada"
      },
      "documentValidation": {
        "status": "PASSED",
        "details": "Todos os documentos válidos"
      }
    },
    "requirements": [],
    "warnings": [],
    "recommendedActions": []
  }
}
```

### 4.6 Endpoints de Busca Avançada

#### 4.6.1 Busca por Critérios Múltiplos

**POST** `/api/v1/license-holders/search`

**Request Body:**

```json
{
  "criteria": {
    "holderType": "INDIVIDUAL",
    "ageRange": {
      "min": 25,
      "max": 65
    },
    "location": {
      "countries": ["CV"],
      "cities": ["Praia", "Mindelo"]
    },
    "licenseStatus": ["ACTIVE", "PENDING"],
    "verificationStatus": ["VERIFIED"],
    "hasActiveLicenses": true,
    "businessSectors": ["Comércio", "Serviços"]
  },
  "pagination": {
    "page": 0,
    "size": 50
  },
  "sorting": [
    {
      "field": "name",
      "direction": "ASC"
    },
    {
      "field": "createdAt",
      "direction": "DESC"
    }
  ]
}
```

#### 4.6.2 Busca com Filtros Geográficos

**GET** `/api/v1/license-holders/by-location`

**Query Parameters:**

* `country` (string) - Filtrar por país

* `state` (string) - Filtrar por estado/ilha

* `city` (string) - Filtrar por cidade

* `postalCode` (string) - Filtrar por código postal

* `radius` (int) - Raio em km para busca por proximidade

* `latitude` (decimal) - Latitude para busca por proximidade

* `longitude` (decimal) - Longitude para busca por proximidade

### 4.7 Endpoints de Relatórios

#### 4.7.1 Estatísticas de Titulares

**GET** `/api/v1/license-holders/statistics`

**Query Parameters:**

* `period` (string) - Período para estatísticas (DAILY, WEEKLY, MONTHLY, YEARLY)

* `fromDate` (date) - Data inicial

* `toDate` (date) - Data final

* `groupBy` (string) - Agrupar por (holderType, status, location)

**Response (200 OK):**

```json
{
  "success": true,
  "data": {
    "totalHolders": 1250,
    "activeHolders": 1100,
    "byType": {
      "INDIVIDUAL": 800,
      "COMPANY": 450
    },
    "byStatus": {
      "ACTIVE": 1100,
      "INACTIVE": 100,
      "SUSPENDED": 50
    },
    "byLegalCapacityStatus": {
      "VERIFIED": 1000,
      "PENDING": 200,
      "RESTRICTED": 50
    },
    "recentActivity": {
      "newHoldersThisMonth": 45,
      "verificationsCompleted": 38,
      "statusChanges": 12
    }
  }
}
```

### 4.8 Tratamento de Erros

#### 4.8.1 Erro de Validação (400 Bad Request)

```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Dados de entrada inválidos",
    "details": [
      {
        "field": "identification.number",
        "message": "Número de identificação deve ter entre 8 e 12 dígitos"
      },
      {
        "field": "personalInfo.birthDate",
        "message": "Data de nascimento não pode ser futura"
      },
      {
        "field": "contactInfo.email",
        "message": "Formato de email inválido"
      }
    ]
  },
  "timestamp": "2025-01-15T10:30:00Z",
  "path": "/api/v1/license-holders"
}
```

#### 4.8.2 Identificação Duplicada (409 Conflict)

```json
{
  "success": false,
  "error": {
    "code": "DUPLICATE_IDENTIFICATION",
    "message": "Documento de identificação já cadastrado",
    "details": {
      "identificationType": "NATIONAL_ID",
      "identificationNumber": "123456789",
      "existingHolderId": "holder-existing-123",
      "existingHolderName": "João Silva Santos",
      "registrationDate": "2023-05-10T14:20:00Z"
    }
  },
  "timestamp": "2025-01-15T10:30:00Z",
  "path": "/api/v1/license-holders"
}
```

#### 4.8.3 Titular Não Encontrado (404 Not Found)

```json
{
  "success": false,
  "error": {
    "code": "LICENSE_HOLDER_NOT_FOUND",
    "message": "Titular não encontrado",
    "details": {
      "holderId": "holder-550e8400-e29b-41d4-a716-446655440000"
    }
  },
  "timestamp": "2025-01-15T10:30:00Z",
  "path": "/api/v1/license-holders/holder-550e8400-e29b-41d4-a716-446655440000"
}
```

#### 4.8.4 Capacidade Legal Insuficiente (422 Unprocessable Entity)

```json
{
  "success": false,
  "error": {
    "code": "INSUFFICIENT_LEGAL_CAPACITY",
    "message": "Titular não possui capacidade legal suficiente",
    "details": {
      "holderId": "holder-123",
      "currentStatus": "PENDING",
      "requiredStatus": "VERIFIED",
      "pendingVerifications": [
        "CRIMINAL_BACKGROUND",
        "FINANCIAL_CAPACITY"
      ],
      "estimatedResolutionDate": "2025-01-25T17:00:00Z"
    }
  },
  "timestamp": "2025-01-15T10:30:00Z",
  "path": "/api/v1/license-holders/holder-123/check-license-eligibility"
}
```

**Exemplo cURL:**

```bash
curl -X POST "https://api.licenciamento.cv/api/v1/license-holders" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." \
  -d '{
    "holderType": "INDIVIDUAL",
    "name": "João Silva Santos",
    "identification": {
      "type": "NATIONAL_ID",
      "number": "123456789",
      "issuingCountry": "CV"
    },
    "personalInfo": {
      "birthDate": "1985-03-15",
      "gender": "MALE",
      "nationality": "CV"
    }
  }'
```

```
// Buscar titulares com verificações pendentes
@Query("SELECT DISTINCT h FROM LicenseHolder h JOIN h.capacityVerifications v WHERE " +
       "v.verificationStatus = 'PENDING'")
List<LicenseHolder> findHoldersWithPendingVerifications();

// Estatísticas
@Query("SELECT h.holderType, COUNT(h) FROM LicenseHolder h GROUP BY h.holderType")
List<Object[]> countByHolderType();

@Query("SELECT h.status, COUNT(h) FROM LicenseHolder h GROUP BY h.status")
List<Object[]> countByStatus();

@Query("SELECT h.legalCapacityStatus, COUNT(h) FROM LicenseHolder h GROUP BY h.legalCapacityStatus")
List<Object[]> countByLegalCapacityStatus();
```

}

````

### 3.5 Domain Services

#### 3.5.1 IdentificationValidationService
```java
@Service
public class IdentificationValidationService {
    
    private final LicenseHolderRepository licenseHolderRepository;
    
    public IdentificationValidationService(LicenseHolderRepository licenseHolderRepository) {
        this.licenseHolderRepository = licenseHolderRepository;
    }
    
    public void validateUniqueIdentification(IdentificationType type, String number) {
        if (licenseHolderRepository.existsByIdentification_TypeAndIdentification_Number(type, number)) {
            throw new DomainException(
                String.format("License holder with %s number %s already exists", 
                    type.getDisplayName(), number));
        }
    }
    
    public void validateUniqueIdentificationForUpdate(LicenseHolderId holderId, 
                                                     IdentificationType type, String number) {
        licenseHolderRepository.findByIdentification_TypeAndIdentification_Number(type, number)
            .ifPresent(existingHolder -> {
                if (!existingHolder.getId().equals(holderId)) {
                    throw new DomainException(
                        String.format("License holder with %s number %s already exists", 
                            type.getDisplayName(), number));
                }
            });
    }
    
    public boolean isIdentificationValid(Identification identification) {
        return identification != null && identification.isValid();
    }
}
````

#### 3.5.2 LegalRepresentativeValidationService

```java
@Service
public class LegalRepresentativeValidationService {
    
    public void validateRepresentativeForCompany(LicenseHolder holder, LegalRepresentative representative) {
        if (holder.getHolderType() != HolderType.COMPANY) {
            throw new DomainException("Legal representatives can only be added to companies");
        }
        
        validateRepresentativeData(representative);
        validateRepresentativeUniqueness(holder, representative);
    }
    
    private void validateRepresentativeData(LegalRepresentative representative) {
        if (representative.getName() == null || representative.getName().trim().isEmpty()) {
            throw new DomainException("Representative name is required");
        }
        
        if (representative.getIdentification() == null || !representative.getIdentification().isValid()) {
            throw new DomainException("Valid representative identification is required");
        }
        
        if (representative.getRole() == null || representative.getRole().trim().isEmpty()) {
            throw new DomainException("Representative role is required");
        }
    }
    
    private void validateRepresentativeUniqueness(LicenseHolder holder, LegalRepresentative representative) {
        boolean exists = holder.getLegalRepresentatives().stream()
            .anyMatch(existing -> 
                existing.getIdentification().getType() == representative.getIdentification().getType() &&
                existing.getIdentification().getNumber().equals(representative.getIdentification().getNumber()) &&
                existing.getStatus() == RepresentativeStatus.ACTIVE);
        
        if (exists) {
            throw new DomainException("Representative with this identification already exists for this company");
        }
    }
}
```

#### 3.5.3 CapacityVerificationService

```java
@Service
public class CapacityVerificationService {
    
    public void validateVerificationRequest(LicenseHolder holder, VerificationType verificationType) {
        validateVerificationTypeForHolderType(holder.getHolderType(), verificationType);
        validateNoDuplicateActiveVerification(holder, verificationType);
    }
    
    private void validateVerificationTypeForHolderType(HolderType holderType, VerificationType verificationType) {
        boolean isValid = switch (holderType) {
            case INDIVIDUAL -> verificationType.isRequiredForIndividual() || 
                              verificationType == VerificationType.PROFESSIONAL_QUALIFICATION;
            case COMPANY -> verificationType.isRequiredForCompany() || 
                           verificationType == VerificationType.PROFESSIONAL_QUALIFICATION;
        };
        
        if (!isValid) {
            throw new DomainException(
                String.format("Verification type %s is not applicable for %s", 
                    verificationType.getDisplayName(), holderType.getDisplayName()));
        }
    }
    
    private void validateNoDuplicateActiveVerification(LicenseHolder holder, VerificationType verificationType) {
        boolean hasActiveVerification = holder.getCapacityVerifications().stream()
            .anyMatch(v -> v.getVerificationType() == verificationType &&
                          (v.getVerificationStatus() == VerificationStatus.PENDING ||
                           v.getVerificationStatus() == VerificationStatus.IN_PROGRESS ||
                           (v.getVerificationStatus() == VerificationStatus.VERIFIED &&
                            (v.getExpiryDate() == null || v.getExpiryDate().isAfter(LocalDate.now())))));
        
        if (hasActiveVerification) {
            throw new DomainException(
                String.format("Active verification of type %s already exists", 
                    verificationType.getDisplayName()));
        }
    }
    
    public boolean isEligibleForLicense(LicenseHolder holder, String licenseType) {
        return holder.isEligibleForLicense(licenseType);
    }
}
```

## 4. Camada de Aplicação

### 4.1 Use Cases

#### 4.1.1 CreateIndividualLicenseHolderUseCase

```java
@Service
@Transactional
public class CreateIndividualLicenseHolderUseCase {
    
    private final LicenseHolderRepository licenseHolderRepository;
    private final IdentificationValidationService identificationValidationService;
    private final ApplicationEventPublisher eventPublisher;
    
    public CreateIndividualLicenseHolderUseCase(
            LicenseHolderRepository licenseHolderRepository,
            IdentificationValidationService identificationValidationService,
            ApplicationEventPublisher eventPublisher) {
        this.licenseHolderRepository = licenseHolderRepository;
        this.identificationValidationService = identificationValidationService;
        this.eventPublisher = eventPublisher;
    }
    
    public LicenseHolderId execute(CreateIndividualLicenseHolderCommand command) {
        // Validar identificação única
        identificationValidationService.validateUniqueIdentification(
            command.getIdentificationType(), command.getIdentificationNumber());
        
        // Criar Value Objects
        Identification identification = Identification.of(
            command.getIdentificationType(),
            command.getIdentificationNumber(),
            command.getIssuingCountry(),
            command.getIssueDate(),
            command.getExpiryDate());
        
        ContactInfo contactInfo = ContactInfo.of(
            command.getPrimaryPhone(),
            command.getSecondaryPhone(),
            command.getEmail(),
            command.getWebsite(),
            command.getAddress());
        
        PersonalInfo personalInfo = PersonalInfo.of(
            command.getBirthDate(),
            command.getBirthPlace(),
            command.getGender(),
            command.getMaritalStatus(),
            command.getNationality(),
            command.getProfession());
        
        // Criar titular individual
        LicenseHolder holder = LicenseHolder.createIndividual(
            identification,
            command.getName(),
            contactInfo,
            personalInfo,
            command.getCreatedBy());
        
        // Persistir
        LicenseHolder savedHolder = licenseHolderRepository.save(holder);
        
        // Publicar eventos de domínio
        savedHolder.getDomainEvents().forEach(eventPublisher::publishEvent);
        savedHolder.clearDomainEvents();
        
        return savedHolder.getId();
    }
}
```

#### 4.1.2 CreateCompanyLicenseHolderUseCase

```java
@Service
@Transactional
public class CreateCompanyLicenseHolderUseCase {
    
    private final LicenseHolderRepository licenseHolderRepository;
    private final IdentificationValidationService identificationValidationService;
    private final ApplicationEventPublisher eventPublisher;
    
    public CreateCompanyLicenseHolderUseCase(
            LicenseHolderRepository licenseHolderRepository,
            IdentificationValidationService identificationValidationService,
            ApplicationEventPublisher eventPublisher) {
        this.licenseHolderRepository = licenseHolderRepository;
        this.identificationValidationService = identificationValidationService;
        this.eventPublisher = eventPublisher;
    }
    
    public LicenseHolderId execute(CreateCompanyLicenseHolderCommand command) {
        // Validar identificação única
        identificationValidationService.validateUniqueIdentification(
            command.getIdentificationType(), command.getIdentificationNumber());
        
        // Criar Value Objects
        Identification identification = Identification.of(
            command.getIdentificationType(),
            command.getIdentificationNumber(),
            command.getIssuingCountry(),
            command.getIssueDate(),
            command.getExpiryDate());
        
        ContactInfo contactInfo = ContactInfo.of(
            command.getPrimaryPhone(),
            command.getSecondaryPhone(),
            command.getEmail(),
            command.getWebsite(),
            command.getAddress());
        
        CompanyInfo companyInfo = CompanyInfo.of(
            command.getIncorporationDate(),
            command.getIncorporationCountry(),
            command.getBusinessSector(),
            command.getCompanySize(),
            command.getAnnualRevenue(),
            command.getEmployeeCount());
        
        // Criar titular empresa
        LicenseHolder holder = LicenseHolder.createCompany(
            identification,
            command.getName(),
            command.getTradeName(),
            contactInfo,
            companyInfo,
            command.getCreatedBy());
        
        // Persistir
        LicenseHolder savedHolder = licenseHolderRepository.save(holder);
        
        // Publicar eventos de domínio
        savedHolder.getDomainEvents().forEach(eventPublisher::publishEvent);
        savedHolder.clearDomainEvents();
        
        return savedHolder.getId();
    }
}
```

```
 T_LEGAL_REPRESENTATIVE {
    uuid id PK
    uuid license_holder_id_fk FK
    varchar representative_type
    varchar identification_number
    varchar identification_type
    varchar name
    varchar email
    varchar phone
    varchar position
    text powers_description
    date appointment_date
    date expiry_date
    varchar status
    timestamp created_date
    varchar created_by
    timestamp last_modified_date
    varchar last_modified_by
}

T_HOLDER_DOCUMENT {
    uuid id PK
    uuid license_holder_id_fk FK
    varchar document_type
    varchar document_number
    varchar document_name
    varchar document_url
    varchar mime_type
    bigint file_size
    date issue_date
    date expiry_date
    varchar issuing_authority
    varchar status
    timestamp upload_date
    varchar uploaded_by
    timestamp created_date
    timestamp last_modified_date
}

T_HOLDER_CAPACITY_VERIFICATION {
    uuid id PK
    uuid license_holder_id_fk FK
    varchar verification_type
    varchar verification_status
    text verification_details
    date verification_date
    varchar verified_by
    date expiry_date
    timestamp created_date
    varchar created_by
}

T_LICENSE_HOLDER ||--o{ T_LEGAL_REPRESENTATIVE : "has representatives"
T_LICENSE_HOLDER ||--o{ T_HOLDER_DOCUMENT : "has documents"
T_LICENSE_HOLDER ||--o{ T_HOLDER_CAPACITY_VERIFICATION : "has verifications"
```

````

### 2.2 Definição das Tabelas

#### 2.2.1 Tabela T_LICENSE_HOLDER

```sql
CREATE TABLE t_license_holder (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    holder_type VARCHAR(20) NOT NULL,
    identification_number VARCHAR(50) UNIQUE NOT NULL,
    identification_type VARCHAR(20) NOT NULL,
    name VARCHAR(255) NOT NULL,
    trade_name VARCHAR(255),
    email VARCHAR(255),
    phone VARCHAR(20),
    address TEXT,
    parish VARCHAR(100),
    municipality VARCHAR(100),
    island VARCHAR(50),
    postal_code VARCHAR(20),
    nationality VARCHAR(50),
    birth_date DATE,
    gender VARCHAR(10),
    marital_status VARCHAR(20),
    tax_number VARCHAR(50),
    social_security_number VARCHAR(50),
    legal_capacity_status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    active BOOLEAN NOT NULL DEFAULT true,
    metadata JSONB,
    created_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    last_modified_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100) NOT NULL,
    last_modified_by VARCHAR(100) NOT NULL,

    CONSTRAINT chk_holder_type
        CHECK (holder_type IN ('INDIVIDUAL', 'COMPANY')),
    CONSTRAINT chk_identification_type
        CHECK (identification_type IN ('NATIONAL_ID', 'PASSPORT', 'COMPANY_REGISTRATION', 'TAX_ID')),
    CONSTRAINT chk_gender
        CHECK (gender IS NULL OR gender IN ('MALE', 'FEMALE', 'OTHER')),
    CONSTRAINT chk_marital_status
        CHECK (marital_status IS NULL OR marital_status IN ('SINGLE', 'MARRIED', 'DIVORCED', 'WIDOWED')),
    CONSTRAINT chk_legal_capacity_status
        CHECK (legal_capacity_status IN ('PENDING', 'VERIFIED', 'RESTRICTED', 'INCAPACITATED')),
    CONSTRAINT chk_status
        CHECK (status IN ('ACTIVE', 'INACTIVE', 'SUSPENDED', 'BLOCKED')),
    CONSTRAINT chk_individual_birth_date
        CHECK (holder_type != 'INDIVIDUAL' OR birth_date IS NOT NULL),
    CONSTRAINT chk_individual_gender
        CHECK (holder_type != 'INDIVIDUAL' OR gender IS NOT NULL),
    CONSTRAINT chk_company_trade_name
        CHECK (holder_type != 'COMPANY' OR trade_name IS NOT NULL)
);
````

#### 2.2.2 Tabela T\_LEGAL\_REPRESENTATIVE

```sql
CREATE TABLE t_legal_representative (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    license_holder_id_fk UUID NOT NULL,
    representative_type VARCHAR(30) NOT NULL,
    identification_number VARCHAR(50) NOT NULL,
    identification_type VARCHAR(20) NOT NULL,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255),
    phone VARCHAR(20),
    position VARCHAR(100),
    powers_description TEXT,
    appointment_date DATE NOT NULL,
    expiry_date DATE,
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    created_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100) NOT NULL,
    last_modified_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    last_modified_by VARCHAR(100) NOT NULL,

    CONSTRAINT fk_legal_representative_holder
        FOREIGN KEY (license_holder_id_fk) REFERENCES t_license_holder(id),
    CONSTRAINT chk_representative_type
        CHECK (representative_type IN ('LEGAL_REPRESENTATIVE', 'ATTORNEY', 'ADMINISTRATOR', 'DIRECTOR')),
    CONSTRAINT chk_representative_identification_type
        CHECK (identification_type IN ('NATIONAL_ID', 'PASSPORT')),
    CONSTRAINT chk_representative_status
        CHECK (status IN ('ACTIVE', 'INACTIVE', 'REVOKED', 'EXPIRED')),
    CONSTRAINT chk_expiry_after_appointment
        CHECK (expiry_date IS NULL OR expiry_date > appointment_date),
    CONSTRAINT uk_holder_representative_identification
        UNIQUE (license_holder_id_fk, identification_number)
);
```

#### 2.2.3 Tabela T\_HOLDER\_DOCUMENT

```sql
CREATE TABLE t_holder_document (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    license_holder_id_fk UUID NOT NULL,
    document_type VARCHAR(50) NOT NULL,
    document_number VARCHAR(100),
    document_name VARCHAR(255) NOT NULL,
    document_url VARCHAR(500) NOT NULL,
    mime_type VARCHAR(100) NOT NULL,
    file_size BIGINT NOT NULL CHECK (file_size > 0),
    issue_date DATE,
    expiry_date DATE,
    issuing_authority VARCHAR(255),
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    upload_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    uploaded_by VARCHAR(100) NOT NULL,
    created_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    last_modified_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),

    CONSTRAINT fk_holder_document_holder
        FOREIGN KEY (license_holder_id_fk) REFERENCES t_license_holder(id),
    CONSTRAINT chk_holder_document_status
        CHECK (status IN ('ACTIVE', 'EXPIRED', 'REPLACED', 'INVALID', 'PENDING_VERIFICATION')),
    CONSTRAINT chk_expiry_after_issue
        CHECK (expiry_date IS NULL OR issue_date IS NULL OR expiry_date > issue_date)
);
```

#### 2.2.4 Tabela T\_HOLDER\_CAPACITY\_VERIFICATION

```sql
CREATE TABLE t_holder_capacity_verification (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    license_holder_id_fk UUID NOT NULL,
    verification_type VARCHAR(50) NOT NULL,
    verification_status VARCHAR(20) NOT NULL,
    verification_details TEXT,
    verification_date DATE NOT NULL,
    verified_by VARCHAR(100) NOT NULL,
    expiry_date DATE,
    created_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    created_by VARCHAR(100) NOT NULL,

    CONSTRAINT fk_capacity_verification_holder
        FOREIGN KEY (license_holder_id_fk) REFERENCES t_license_holder(id),
    CONSTRAINT chk_verification_type
        CHECK (verification_type IN ('LEGAL_CAPACITY', 'FINANCIAL_CAPACITY', 'TECHNICAL_CAPACITY', 'CRIMINAL_BACKGROUND')),
    CONSTRAINT chk_verification_status
        CHECK (verification_status IN ('VERIFIED', 'REJECTED', 'PENDING', 'EXPIRED')),
    CONSTRAINT chk_verification_expiry
        CHECK (expiry_date IS NULL OR expiry_date > verification_date)
);
```

### 2.3 Índices de Performance

```sql
-- Índices principais
CREATE INDEX idx_license_holder_identification ON t_license_holder(identification_number);
CREATE INDEX idx_license_holder_type ON t_license_holder(holder_type);
CREATE INDEX idx_license_holder_status ON t_license_holder(status) WHERE status = 'ACTIVE';
CREATE INDEX idx_license_holder_capacity ON t_license_holder(legal_capacity_status);
CREATE INDEX idx_license_holder_municipality ON t_license_holder(municipality, island);
CREATE INDEX idx_license_holder_name ON t_license_holder USING gin(to_tsvector('portuguese', name));

-- Índices para representantes legais
CREATE INDEX idx_legal_representative_holder ON t_legal_representative(license_holder_id_fk);
CREATE INDEX idx_legal_representative_identification ON t_legal_representative(identification_number);
CREATE INDEX idx_legal_representative_expiry ON t_legal_representative(expiry_date) 
    WHERE expiry_date IS NOT NULL AND status = 'ACTIVE';

-- Índices para documentos
CREATE INDEX idx_holder_document_holder ON t_holder_document(license_holder_id_fk);
CREATE INDEX idx_holder_document_type ON t_holder_document(document_type);
CREATE INDEX idx_holder_document_expiry ON t_holder_document(expiry_date) 
    WHERE expiry_date IS NOT NULL AND status = 'ACTIVE';

-- Índices para verificações de capacidade
CREATE INDEX idx_capacity_verification_holder ON t_holder_capacity_verification(license_holder_id_fk);
CREATE INDEX idx_capacity_verification_type ON t_holder_capacity_verification(verification_type);
CREATE INDEX idx_capacity_verification_status ON t_holder_capacity_verification(verification_status);
```

## 3. Arquitetura DDD

### 3.1 Domain Layer

#### 3.1.1 Aggregate Root: LicenseHolder

```java
@Entity
@Table(name = "t_license_holder")
public class LicenseHolder extends AggregateRoot<LicenseHolderId> {
    
    @EmbeddedId
    private LicenseHolderId id;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "holder_type", nullable = false)
    private HolderType holderType;
    
    @Embedded
    private Identification identification;
    
    @Column(name = "name", nullable = false)
    private String name;
    
    @Column(name = "trade_name")
    private String tradeName;
    
    @Embedded
    private ContactInfo contactInfo;
    
    @Embedded
    private Address address;
    
    @Embedded
    private PersonalInfo personalInfo; // Apenas para pessoas físicas
    
    @Embedded
    private CompanyInfo companyInfo; // Apenas para pessoas jurídicas
    
    @Enumerated(EnumType.STRING)
    @Column(name = "legal_capacity_status", nullable = false)
    private LegalCapacityStatus legalCapacityStatus;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private HolderStatus status;
    
    @OneToMany(mappedBy = "licenseHolder", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<LegalRepresentative> legalRepresentatives = new ArrayList<>();
    
    @OneToMany(mappedBy = "licenseHolder", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<HolderDocument> documents = new ArrayList<>();
    
    @OneToMany(mappedBy = "licenseHolder", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<CapacityVerification> capacityVerifications = new ArrayList<>();
    
    // Métodos de negócio
    public static LicenseHolder createIndividual(
            Identification identification,
            String name,
            ContactInfo contactInfo,
            Address address,
            PersonalInfo personalInfo,
            String createdBy,
            IdentificationValidationService validationService) {
        
        validateIndividualCreationParameters(identification, name, personalInfo);
        
        // Validar identificação
        validationService.validateIndividualIdentification(identification);
        
        LicenseHolder holder = new LicenseHolder(
            LicenseHolderId.generate(),
            HolderType.INDIVIDUAL,
            identification,
            name,
            null, // trade name não aplicável
            contactInfo,
            address,
            personalInfo,
            null, // company info não aplicável
            LegalCapacityStatus.PENDING,
            HolderStatus.ACTIVE,
            createdBy
        );
        
        holder.addDomainEvent(new LicenseHolderCreatedEvent(holder.getId(), HolderType.INDIVIDUAL));
        
        return holder;
    }
    
    public static LicenseHolder createCompany(
            Identification identification,
            String name,
            String tradeName,
            ContactInfo contactInfo,
            Address address,
            CompanyInfo companyInfo,
            String createdBy,
            IdentificationValidationService validationService) {
        
        validateCompanyCreationParameters(identification, name, tradeName, companyInfo);
        
        // Validar identificação
        validationService.validateCompanyIdentification(identification);
        
        LicenseHolder holder = new LicenseHolder(
            LicenseHolderId.generate(),
            HolderType.COMPANY,
            identification,
            name,
            tradeName,
            contactInfo,
            address,
            null, // personal info não aplicável
            companyInfo,
            LegalCapacityStatus.PENDING,
            HolderStatus.ACTIVE,
            createdBy
        );
        
        holder.addDomainEvent(new LicenseHolderCreatedEvent(holder.getId(), HolderType.COMPANY));
        
        return holder;
    }
    
    public void addLegalRepresentative(
            String representativeType,
            Identification representativeId,
            String representativeName,
            ContactInfo representativeContact,
            String position,
            String powersDescription,
            LocalDate appointmentDate,
            LocalDate expiryDate,
            String createdBy,
            LegalRepresentativeValidationService validationService) {
        
        // Validar se é pessoa jurídica
        if (this.holderType != HolderType.COMPANY) {
            throw new DomainException("Legal representatives can only be added to companies");
        }
        
        // Validar representante
        validationService.validateRepresentativeEligibility(representativeId);
        
        // Verificar se já existe representante com mesma identificação
        boolean alreadyExists = this.legalRepresentatives.stream()
            .anyMatch(rep -> rep.getIdentification().equals(representativeId) && 
                           rep.getStatus() == RepresentativeStatus.ACTIVE);
        
        if (alreadyExists) {
            throw new DomainException("Representative with this identification already exists");
        }
        
        LegalRepresentative representative = LegalRepresentative.create(
            this,
            RepresentativeType.valueOf(representativeType),
            representativeId,
            representativeName,
            representativeContact,
            position,
            powersDescription,
            appointmentDate,
            expiryDate,
            createdBy
        );
        
        this.legalRepresentatives.add(representative);
        
        addDomainEvent(new LegalRepresentativeAddedEvent(
            this.id, representative.getId(), representativeType));
    }
    
    public void addDocument(
            String documentType,
            String documentNumber,
            String documentName,
            String documentUrl,
            String mimeType,
            Long fileSize,
            LocalDate issueDate,
            LocalDate expiryDate,
            String issuingAuthority,
            String uploadedBy,
            DocumentValidationService documentValidationService) {
        
        // Validar tipo de documento para o tipo de titular
        documentValidationService.validateDocumentTypeForHolderType(documentType, this.holderType);
        
        HolderDocument document = HolderDocument.create(
            this,
            documentType,
            documentNumber,
            documentName,
            documentUrl,
            mimeType,
            fileSize,
            issueDate,
            expiryDate,
            issuingAuthority,
            uploadedBy
        );
        
        this.documents.add(document);
        
        addDomainEvent(new HolderDocumentAddedEvent(
            this.id, document.getId(), documentType));
    }
    
    public void verifyCapacity(
            String verificationType,
            String verificationDetails,
            LocalDate verificationDate,
            LocalDate expiryDate,
            String verifiedBy,
            CapacityVerificationService verificationService) {
        
        // Validar tipo de verificação
        VerificationType type = VerificationType.valueOf(verificationType);
        
        // Executar verificação específica
        VerificationResult result = verificationService.performVerification(
            this, type, verificationDetails);
        
        CapacityVerification verification = CapacityVerification.create(
            this,
            type,
            result.getStatus(),
            verificationDetails,
            verificationDate,
            verifiedBy,
            expiryDate
        );
        
        this.capacityVerifications.add(verification);
        
        // Atualizar status de capacidade legal se necessário
        updateLegalCapacityStatus();
        
        addDomainEvent(new CapacityVerificationCompletedEvent(
            this.id, verification.getId(), type, result.getStatus()));
    }
    
    public void updateContactInfo(
            ContactInfo newContactInfo,
            String updatedBy) {
        
        ContactInfo oldContactInfo = this.contactInfo;
        this.contactInfo = newContactInfo;
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
        
        addDomainEvent(new HolderContactInfoUpdatedEvent(
            this.id, oldContactInfo, newContactInfo));
    }
    
    public void suspend(String reason, String updatedBy) {
        if (this.status == HolderStatus.SUSPENDED) {
            throw new DomainException("Holder is already suspended");
        }
        
        this.status = HolderStatus.SUSPENDED;
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
        
        addDomainEvent(new LicenseHolderSuspendedEvent(this.id, reason));
    }
    
    public void reactivate(String updatedBy) {
        if (this.status != HolderStatus.SUSPENDED) {
            throw new DomainException("Only suspended holders can be reactivated");
        }
        
        this.status = HolderStatus.ACTIVE;
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
        
        addDomainEvent(new LicenseHolderReactivatedEvent(this.id));
    }
    
    // Métodos de consulta
    public boolean hasValidLegalCapacity() {
        return this.legalCapacityStatus == LegalCapacityStatus.VERIFIED;
    }
    
    public boolean hasActiveRepresentatives() {
        return this.legalRepresentatives.stream()
            .anyMatch(rep -> rep.getStatus() == RepresentativeStatus.ACTIVE &&
                           (rep.getExpiryDate() == null || rep.getExpiryDate().isAfter(LocalDate.now())));
    }
    
    public List<HolderDocument> getExpiredDocuments() {
        return this.documents.stream()
            .filter(doc -> doc.getExpiryDate() != null &&
                          doc.getExpiryDate().isBefore(LocalDate.now()) &&
                          doc.getStatus() == DocumentStatus.ACTIVE)
            .toList();
    }
    
    public boolean isEligibleForLicense(String licenseType) {
        // Verificar status ativo
        if (this.status != HolderStatus.ACTIVE) {
            return false;
        }
        
        // Verificar capacidade legal
        if (!hasValidLegalCapacity()) {
            return false;
        }
        
        // Para empresas, verificar representantes ativos
        if (this.holderType == HolderType.COMPANY && !hasActiveRepresentatives()) {
            return false;
        }
        
        // Verificar documentos não expirados
        if (!getExpiredDocuments().isEmpty()) {
            return false;
        }
        
        return true;
    }
    
    // Validações privadas
    private static void validateIndividualCreationParameters(
            Identification identification,
            String name,
            PersonalInfo personalInfo) {
        
        if (identification == null) {
            throw new DomainException("Identification is required");
        }
        if (name == null || name.trim().isEmpty()) {
            throw new DomainException("Name is required");
        }
        if (personalInfo == null) {
            throw new DomainException("Personal information is required for individuals");
        }
        if (personalInfo.getBirthDate() == null) {
            throw new DomainException("Birth date is required for individuals");
        }
        if (personalInfo.getGender() == null) {
            throw new DomainException("Gender is required for individuals");
        }
    }
    
    private static void validateCompanyCreationParameters(
            Identification identification,
            String name,
            String tradeName,
            CompanyInfo companyInfo) {
        
        if (identification == null) {
            throw new DomainException("Identification is required");
        }
        if (name == null || name.trim().isEmpty()) {
            throw new DomainException("Company name is required");
        }
        if (tradeName == null || tradeName.trim().isEmpty()) {
            throw new DomainException("Trade name is required for companies");
        }
        if (companyInfo == null) {
            throw new DomainException("Company information is required");
        }
    }
    
    private void updateLegalCapacityStatus() {
        // Verificar se todas as verificações obrigatórias foram concluídas com sucesso
        List<VerificationType> requiredVerifications = getRequiredVerifications();
        
        boolean allVerified = requiredVerifications.stream()
            .allMatch(type -> hasValidVerification(type));
        
        if (allVerified) {
            this.legalCapacityStatus = LegalCapacityStatus.VERIFIED;
        } else {
            // Verificar se alguma verificação foi rejeitada
            boolean anyRejected = this.capacityVerifications.stream()
                .anyMatch(v -> v.getVerificationStatus() == VerificationStatus.REJECTED);
            
            if (anyRejected) {
                this.legalCapacityStatus = LegalCapacityStatus.RESTRICTED;
            }
        }
    }
    
    private List<VerificationType> getRequiredVerifications() {
        return switch (this.holderType) {
            case INDIVIDUAL -> List.of(
                VerificationType.LEGAL_CAPACITY,
                VerificationType.CRIMINAL_BACKGROUND
            );
            case COMPANY -> List.of(
                VerificationType.LEGAL_CAPACITY,
                VerificationType.FINANCIAL_CAPACITY
            );
        };
    }
    
    private boolean hasValidVerification(VerificationType type) {
        return this.capacityVerifications.stream()
            .anyMatch(v -> v.getVerificationType() == type &&
                          v.getVerificationStatus() == VerificationStatus.VERIFIED &&
                          (v.getExpiryDate() == null || v.getExpiryDate().isAfter(LocalDate.now())));
    }
}
        this.updatedBy = updatedBy;
        this.updatedAt = Instant.now();
        
        addDomainEvent(new LicenseHolderReactivatedEvent(this.id));
    }
    
    // Métodos de consulta
    public boolean hasValidLegalCapacity() {
        return this.legalCapacityStatus == LegalCapacityStatus.VERIFIED;
    }
    
    public boolean hasActiveRepresentatives() {
        return this.legalRepresentatives.stream()
            .anyMatch(rep -> rep.getStatus() == RepresentativeStatus.ACTIVE &&
                           (rep.getExpiryDate() == null || rep.getExpiryDate().isAfter(LocalDate.now())));
    }
    
    public List<HolderDocument> getExpiredDocuments() {
        return this.documents.stream()
            .filter(doc -> doc.getExpiryDate() != null &&
                          doc.getExpiryDate().isBefore(LocalDate.now()) &&
                          doc.getStatus() == DocumentStatus.ACTIVE)
            .toList();
    }
    
    public boolean isEligibleForLicense(String licenseType) {
        // Verificar status ativo
        if (this.status != HolderStatus.ACTIVE) {
            return false;
        }
        
        // Verificar capacidade legal
        if (!hasValidLegalCapacity()) {
            return false;
        }
        
        // Para empresas, verificar representantes ativos
        if (this.holderType == HolderType.COMPANY && !hasActiveRepresentatives()) {
            return false;
        }
        
        // Verificar documentos não expirados
        if (!getExpiredDocuments().isEmpty()) {
            return false;
        }
        
        return true;
    }
    
    // Validações privadas
    private static void validateIndividualCreationParameters(
            Identification identification,
            String name,
            PersonalInfo personalInfo) {
        
        if (identification == null) {
            throw new DomainException("Identification is required");
        }
        if (name == null || name.trim().isEmpty()) {
            throw new DomainException("Name is required");
        }
        if (personalInfo == null) {
            throw new DomainException("Personal information is required for individuals");
        }
        if (personalInfo.getBirthDate() == null) {
            throw new DomainException("Birth date is required for individuals");
        }
        if (personalInfo.getGender() == null) {
            throw new DomainException("Gender is required for individuals");
        }
    }
    
    private static void validateCompanyCreationParameters(
            Identification identification,
            String name,
            String tradeName,
            CompanyInfo companyInfo) {
        
        if (identification == null) {
            throw new DomainException("Identification is required");
        }
        if (name == null || name.trim().isEmpty()) {
            throw new DomainException("Company name is required");
        }
        if (tradeName == null || tradeName.trim().isEmpty()) {
            throw new DomainException("Trade name is required for companies");
        }
        if (companyInfo == null) {
            throw new DomainException("Company information is required");
        }
    }
    
    private void updateLegalCapacityStatus() {
        // Verificar se todas as verificações obrigatórias foram concluídas com sucesso
        List<VerificationType> requiredVerifications = getRequiredVerifications();
        
        boolean allVerified = requiredVerifications.stream()
            .allMatch(type -> hasValidVerification(type));
        
        if (allVerified) {
            this.legalCapacityStatus = LegalCapacityStatus.VERIFIED;
        } else {
            // Verificar se alguma verificação foi rejeitada
            boolean anyRejected = this.capacityVerifications.stream()
                .anyMatch(v -> v.getVerificationStatus() == VerificationStatus.REJECTED);
            
            if (anyRejected) {
                this.legalCapacityStatus = LegalCapacityStatus.RESTRICTED;
            }
        }
    }
    
    private List<VerificationType> getRequiredVerifications() {
        return switch (this.holderType) {
            case INDIVIDUAL -> List.of(
                VerificationType.LEGAL_CAPACITY,
                VerificationType.CRIMINAL_BACKGROUND
            );
            case COMPANY -> List.of(
                VerificationType.LEGAL_CAPACITY,
                VerificationType.FINANCIAL_CAPACITY
            );
        };
    }
    
    private boolean hasValidVerification(VerificationType type) {
        return this.capacityVerifications.stream()
            .anyMatch(v -> v.getVerificationType() == type &&
                          v.getVerificationStatus() == VerificationStatus.VERIFIED &&
                          (v.getExpiryDate() == null || v.getExpiryDate().isAfter(LocalDate.now())));
    }
}
```

#### 3.1.2 Value Objects

```java
@Embeddable
public class LicenseHolderId {
    @Column(name = "id")
    private UUID value;
    
    public static LicenseHolderId generate() {
        return new LicenseHolderId(UUID.randomUUID());
    }
    
    public static LicenseHolderId of(UUID value) {
        if (value == null) {
            throw new IllegalArgumentException("LicenseHolderId cannot be null");
        }
        return new LicenseHolderId(value);
    }
}

@Embeddable
public class Identification {
    @Column(name = "identification_number")
    private String number;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "identification_type")
    private IdentificationType type;
    
    public static Identification of(String number, IdentificationType type) {
        validateIdentification(number, type);
        return new Identification(number, type);
    }
    
    private static void validateIdentification(String number, IdentificationType type) {
        if (number == null || number.trim().isEmpty()) {
            throw new DomainException("Identification number cannot be empty");
        }
        if (type == null) {
            throw new DomainException("Identification type is required");
        }
        
        // Validações específicas por tipo
        switch (type) {
            case NATIONAL_ID -> {
                if (!number.matches("^\\d{9}$")) {
                    throw new DomainException("Invalid national ID format. Expected: 9 digits");
                }
            }
            case PASSPORT -> {
                if (!number.matches("^[A-Z]{2}\\d{7}$")) {
                    throw new DomainException("Invalid passport format. Expected: XX1234567");
                }
            }
            case COMPANY_REGISTRATION -> {
                if (!number.matches("^\\d{4}/\\d{4}$")) {
                    throw new DomainException("Invalid company registration format. Expected: 1234/5678");
                }
            }
            case TAX_ID -> {
                if (!number.matches("^\\d{9}$")) {
                    throw new DomainException("Invalid tax ID format. Expected: 9 digits");
                }
            }
        }
    }
}

@Embeddable
public class ContactInfo {
    @Column(name = "email")
    private String email;
    
    @Column(name = "phone")
    private String phone;
    
    public static ContactInfo of(String email, String phone) {
        validateContactInfo(email, phone);
        return new ContactInfo(email, phone);
    }
    
    private static void validateContactInfo(String email, String phone) {
        if (email != null && !email.matches("^[A-Za-z0-9+_.-]+@(.+)$")) {
            throw new DomainException("Invalid email format");
        }
        if (phone != null && !phone.matches("^\\+?[0-9\\s\\-\\(\\)]{7,15}$")) {
            throw new DomainException("Invalid phone format");
        }
    }
}

@Embeddable
public class PersonalInfo {
    @Column(name = "birth_date")
    private LocalDate birthDate;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "gender")
    private Gender gender;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "marital_status")
    private MaritalStatus maritalStatus;
    
    @Column(name = "nationality")
    private String nationality;
    
    public static PersonalInfo of(
            LocalDate birthDate,
            Gender gender,
            MaritalStatus maritalStatus,
            String nationality) {
        
        validatePersonalInfo(birthDate, gender);
        return new PersonalInfo(birthDate, gender, maritalStatus, nationality);
    }
    
    private static void validatePersonalInfo(LocalDate birthDate, Gender gender) {
        if (birthDate == null) {
            throw new DomainException("Birth date is required");
        }
        if (birthDate.isAfter(LocalDate.now().minusYears(18))) {
            throw new DomainException("Person must be at least 18 years old");
        }
        if (gender == null) {
            throw new DomainException("Gender is required");
        }
    }
    
    public int getAge() {
        return Period.between(birthDate, LocalDate.now()).getYears();
    }
}

@Embeddable
public class CompanyInfo {
    @Column(name = "tax_number")
    private String taxNumber;
    
    @Column(name = "social_security_number")
    private String socialSecurityNumber;
    
    public static CompanyInfo of(String taxNumber, String socialSecurityNumber) {
        validateCompanyInfo(taxNumber);
        return new CompanyInfo(taxNumber, socialSecurityNumber);
    }
    
    private static void validateCompanyInfo(String taxNumber) {
        if (taxNumber == null || taxNumber.trim().isEmpty()) {
            throw new DomainException("Tax number is required for companies");
        }
        if (!taxNumber.matches("^\\d{9}$")) {
            throw new DomainException("Invalid tax number format. Expected: 9 digits");
        }
    }
}
```

#### 3.1.3 Enums

```java
public enum HolderType {
    INDIVIDUAL("Pessoa Física"),
    COMPANY("Pessoa Jurídica");
    
    private final String description;
    
    HolderType(String description) {
        this.description = description;
    }
}

public enum IdentificationType {
    NATIONAL_ID("Bilhete de Identidade"),
    PASSPORT("Passaporte"),
    COMPANY_REGISTRATION("Registo Comercial"),
    TAX_ID("Número de Identificação Fiscal");
    
    private final String description;
    
    IdentificationType(String description) {
        this.description = description;
    }
}

public enum LegalCapacityStatus {
    PENDING("Pendente"),
    VERIFIED("Verificado"),
    RESTRICTED("Restrito"),
    INCAPACITATED("Incapacitado");
    
    private final String description;
    
    LegalCapacityStatus(String description) {
        this.description = description;
    }
}

public enum HolderStatus {
    ACTIVE("Ativo"),
    INACTIVE("Inativo"),
    SUSPENDED("Suspenso"),
    BLOCKED("Bloqueado");
    
    private final String description;
    
    HolderStatus(String description) {
        this.description = description;
    }
}

public enum Gender {
    MALE("Masculino"),
    FEMALE("Feminino"),
    OTHER("Outro");
    
    private final String description;
    
    Gender(String description) {
        this.description = description;
    }
}

public enum MaritalStatus {
    SINGLE("Solteiro"),
    MARRIED("Casado"),
    DIVORCED("Divorciado"),
    WIDOWED("Viúvo");
    
    private final String description;
    
    MaritalStatus(String description) {
        this.description = description;
    }
}

public enum VerificationType {
    LEGAL_CAPACITY("Capacidade Legal"),
    FINANCIAL_CAPACITY("Capacidade Financeira"),
    TECHNICAL_CAPACITY("Capacidade Técnica"),
    CRIMINAL_BACKGROUND("Antecedentes Criminais");
    
    private final String description;
    
    VerificationType(String description) {
        this.description = description;
    }
}

public enum VerificationStatus {
    VERIFIED("Verificado"),
    REJECTED("Rejeitado"),
    PENDING("Pendente"),
    EXPIRED("Expirado");
    
    private final String description;
    
    VerificationStatus(String description) {
        this.description = description;
    }
}
```

#### 3.1.4 Repository Interface

```java
public interface LicenseHolderRepository {
    Optional<LicenseHolder> findById(LicenseHolderId id);
    Optional<LicenseHolder> findByIdentification(Identification identification);
    List<LicenseHolder> findByHolderType(HolderType holderType);
    List<LicenseHolder> findByStatus(HolderStatus status);
    List<LicenseHolder> findByLegalCapacityStatus(LegalCapacityStatus status);
    Page<LicenseHolder> findAll(Pageable pageable);
    Page<LicenseHolder> findByFilters(HolderSearchCriteria criteria, Pageable pageable);
    List<LicenseHolder> findByNameContaining(String name);
    List<LicenseHolder> findByMunicipality(String municipality);
    List<LicenseHolder> findWithExpiredDocuments();
    List<LicenseHolder> findWithExpiringRepresentatives(LocalDate expiryDate);
    LicenseHolder save(LicenseHolder licenseHolder);
    void delete(LicenseHolder licenseHolder);
    boolean existsByIdentification(Identification identification);
    long countByHolderType(HolderType holderType);
    long countByStatus(HolderStatus status);
}
```

#### 3.1.5 Domain Services

```java
@Service
public class IdentificationValidationService {
    
    private final LicenseHolderRepository licenseHolderRepository;
    private final ExternalIdentificationService externalService;
    
    public void validateIndividualIdentification(Identification identification) {
        // Verificar unicidade
        if (licenseHolderRepository.existsByIdentification(identification)) {
            throw new DomainException("Identification number already exists: " + identification.getNumber());
        }
        
        // Validar com serviços externos
        switch (identification.getType()) {
            case NATIONAL_ID -> validateNationalId(identification.getNumber());
            case PASSPORT -> validatePassport(identification.getNumber());
            default -> throw new DomainException("Invalid identification type for individual");
        }
    }
    
    public void validateCompanyIdentification(Identification identification) {
        // Verificar unicidade
        if (licenseHolderRepository.existsByIdentification(identification)) {
            throw new DomainException("Identification number already exists: " + identification.getNumber());
        }
        
        // Validar com serviços externos
        switch (identification.getType()) {
            case COMPANY_REGISTRATION -> validateCompanyRegistration(identification.getNumber());
            case TAX_ID -> validateTaxId(identification.getNumber());
            default -> throw new DomainException("Invalid identification type for company");
        }
    }
    
    private void validateNationalId(String nationalId) {
        // Validar com serviço de identificação civil
        if (!externalService.validateNationalId(nationalId)) {
            throw new DomainException("Invalid or non-existent national ID: " + nationalId);
        }
    }
    
    private void validatePassport(String passport) {
        // Validar formato e existência
        if (!externalService.validatePassport(passport)) {
            throw new DomainException("Invalid or non-existent passport: " + passport);
        }
    }
    
    private void validateCompanyRegistration(String registration) {
        // Validar com registo comercial
        if (!externalService.validateCompanyRegistration(registration)) {
            throw new DomainException("Invalid or non-existent company registration: " + registration);
        }
    }
    
    private void validateTaxId(String taxId) {
        // Validar com serviço fiscal
        if (!externalService.validateTaxId(taxId)) {
            throw new DomainException("Invalid or non-existent tax ID: " + taxId);
        }
    }
}

@Service
public class LegalRepresentativeValidationService {
    
    private final IdentificationValidationService identificationService;
    private final ExternalIdentificationService externalService;
    
    public void validateRepresentativeEligibility(Identification representativeId) {
        // Verificar se a identificação é válida
        if (representativeId.getType() != IdentificationType.NATIONAL_ID &&
            representativeId.getType() != IdentificationType.PASSPORT) {
            throw new DomainException("Representatives must have national ID or passport");
        }
        
        // Verificar se a pessoa existe e tem capacidade legal
        PersonInfo personInfo = externalService.getPersonInfo(representativeId.getNumber());
        if (personInfo == null) {
            throw new DomainException("Representative not found in official records");
        }
        
        // Verificar idade mínima
        if (personInfo.getAge() < 18) {
            throw new DomainException("Representative must be at least 18 years old");
        }
        
        // Verificar antecedentes criminais (se aplicável)
        if (personInfo.hasCriminalRecord()) {
            throw new DomainException("Representative has criminal record");
        }
    }
    
    public void validateRepresentativePowers(String powersDescription, RepresentativeType type) {
        if (powersDescription == null || powersDescription.trim().isEmpty()) {
            throw new DomainException("Powers description is required");
        }
        
        // Validar poderes específicos por tipo
        switch (type) {
            case LEGAL_REPRESENTATIVE -> {
                if (!powersDescription.contains("representação legal")) {
                    throw new DomainException("Legal representative must have legal representation powers");
                }
            }
            case ATTORNEY -> {
                if (!powersDescription.contains("procuração")) {
                    throw new DomainException("Attorney must have power of attorney");
                }
            }
        }
    }
}

@Service
public class CapacityVerificationService {
    
    private final ExternalVerificationService externalService;
    private final CriminalBackgroundService criminalService;
    private final FinancialVerificationService financialService;
    
    public VerificationResult performVerification(
            LicenseHolder holder,
            VerificationType type,
            String details) {
        
        return switch (type) {
            case LEGAL_CAPACITY -> verifyLegalCapacity(holder, details);
            case FINANCIAL_CAPACITY -> verifyFinancialCapacity(holder, details);
            case TECHNICAL_CAPACITY -> verifyTechnicalCapacity(holder, details);
            case CRIMINAL_BACKGROUND -> verifyCriminalBackground(holder, details);
        };
    }
    
    private VerificationResult verifyLegalCapacity(LicenseHolder holder, String details) {
        // Verificar capacidade legal básica
        if (holder.getHolderType() == HolderType.INDIVIDUAL) {
            // Para pessoas físicas: verificar maioridade e capacidade civil
            PersonalInfo personalInfo = holder.getPersonalInfo();
            if (personalInfo.getAge() < 18) {
                return VerificationResult.rejected("Person is under 18 years old");
            }
        } else {
            // Para empresas: verificar situação legal da empresa
            CompanyLegalStatus status = externalService.getCompanyLegalStatus(
                holder.getIdentification().getNumber());
            if (status != CompanyLegalStatus.ACTIVE) {
                return VerificationResult.rejected("Company is not in active legal status");
            }
        }
        
        return VerificationResult.verified("Legal capacity verified");
    }
    
    private VerificationResult verifyFinancialCapacity(LicenseHolder holder, String details) {
        // Verificar capacidade financeira (apenas para empresas)
        if (holder.getHolderType() != HolderType.COMPANY) {
            throw new DomainException("Financial capacity verification only applies to companies");
        }
        
        FinancialReport report = financialService.getFinancialReport(
            holder.getCompanyInfo().getTaxNumber());
        
        if (report.hasFinancialIssues()) {
            return VerificationResult.rejected("Company has financial issues: " + report.getIssues());
        }
        
        return VerificationResult.verified("Financial capacity verified");
    }
    
    private VerificationResult verifyCriminalBackground(LicenseHolder holder, String details) {
        // Verificar antecedentes criminais
        String identificationNumber = holder.getIdentification().getNumber();
        
        CriminalRecord record = criminalService.getCriminalRecord(identificationNumber);
        
        if (record.hasRelevantConvictions()) {
            return VerificationResult.rejected("Has relevant criminal convictions");
        }
        
        return VerificationResult.verified("No relevant criminal background");
    }
    
    private VerificationResult verifyTechnicalCapacity(LicenseHolder holder, String details) {
        // Verificação técnica específica (implementação dependente do contexto)
        // Por exemplo, verificar certificações profissionais
        
        return VerificationResult.verified("Technical capacity verified");
    }
}

public class VerificationResult {
    private final VerificationStatus status;
    private final String message;
    
    public static VerificationResult verified(String message) {
        return new VerificationResult(VerificationStatus.VERIFIED, message);
    }
    
    public static VerificationResult rejected(String message) {
        return new VerificationResult(VerificationStatus.REJECTED, message);
    }
    
    public static VerificationResult pending(String message) {
        return new VerificationResult(VerificationStatus.PENDING, message);
    }
}
```

### 3.2 Application Layer

#### 3.2.1 Use Cases

```java
@UseCase
@Transactional
public class CreateIndividualHolderUseCase {
    
    private final LicenseHolderRepository licenseHolderRepository;
    private final IdentificationValidationService validationService;
    
    public LicenseHolderResponse execute(CreateIndividualHolderCommand command) {
        // Criar objetos de valor
        Identification identification = Identification.of(
            command.getIdentificationNumber(),
            command.getIdentificationType()
        );
        
        ContactInfo contactInfo = ContactInfo.of(
            command.getEmail(),
            command.getPhone()
        );
        
        Address address = Address.of(
            command.getAddress(),
            command.getParish(),
            command.getMunicipality(),
            command.getIsland(),
            command.getPostalCode()
        );
        
        PersonalInfo personalInfo = PersonalInfo.of(
            command.getBirthDate(),
            command.getGender(),
            command.getMaritalStatus(),
            command.getNationality()
        );
        
        // Criar titular
        LicenseHolder holder = LicenseHolder.createIndividual(
            identification,
            command.getName(),
            contactInfo,
            address,
            personalInfo,
            command.getCreatedBy(),
            validationService
        );
        
        // Salvar
        LicenseHolder saved = licenseHolderRepository.save(holder);
        
        return LicenseHolderResponse.from(saved);
    }
}

@UseCase
@Transactional
public class CreateCompanyHolderUseCase {
    
    private final LicenseHolderRepository licenseHolderRepository;
    private final IdentificationValidationService validationService;
    
    public LicenseHolderResponse execute(CreateCompanyHolderCommand command) {
        // Criar objetos de valor
        Identification identification = Identification.of(
            command.getIdentificationNumber(),
            command.getIdentificationType()
        );
        
        ContactInfo contactInfo = ContactInfo.of(
            command.getEmail(),
            command.getPhone()
        );
        
        Address address = Address.of(
            command.getAddress(),
            command.getParish(),
            command.getMunicipality(),
            command.getIsland(),
            command.getPostalCode()
        );
        
        CompanyInfo companyInfo = CompanyInfo.of(
            command.getTaxNumber(),
            command.getSocialSecurityNumber()
        );
        
        // Criar titular
        LicenseHolder holder = LicenseHolder.createCompany(
            identification,
            command.getName(),
            command.getTradeName(),
            contactInfo,
            address,
            companyInfo,
            command.getCreatedBy(),
            validationService
        );
        
        // Salvar
        LicenseHolder saved = licenseHolderRepository.save(holder);
        
        return LicenseHolderResponse.from(saved);
    }
}

@UseCase
@Transactional
public class AddLegalRepresentativeUseCase {
    
    private final LicenseHolderRepository licenseHolderRepository;
    private final LegalRepresentativeValidationService validationService;
    
    public LegalRepresentativeResponse execute(AddLegalRepresentativeCommand command) {
        // Buscar titular
        LicenseHolder holder = licenseHolderRepository
            .findById(command.getHolderId())
            .orElseThrow(() -> new EntityNotFoundException("License holder not found"));
        
        // Criar identificação do representante
        Identification representativeId = Identification.of(
            command.getIdentificationNumber(),
            command.getIdentificationType()
        );
        
        ContactInfo representativeContact = ContactInfo.of(
            command.getEmail(),
            command.getPhone()
        );
        
        // Adicionar representante
        holder.addLegalRepresentative(
            command.getRepresentativeType(),
            representativeId,
            command.getName(),
            representativeContact,
            command.getPosition(),
            command.getPowersDescription(),
            command.getAppointmentDate(),
            command.getExpiryDate(),
            command.getCreatedBy(),
            validationService
        );
        
        // Salvar
        LicenseHolder updated = licenseHolderRepository.save(holder);
        
        // Retornar representante adicionado
        LegalRepresentative addedRepresentative = updated.getLegalRepresentatives().stream()
            .filter(rep -> rep.getIdentification().equals(representativeId))
            .findFirst()
            .orElseThrow();
        
        return LegalRepresentativeResponse.from(addedRepresentative);
    }
}

@UseCase
@Transactional
public class VerifyHolderCapacityUseCase {
    
    private final LicenseHolderRepository licenseHolderRepository;
    private final CapacityVerificationService verificationService;
    
    public CapacityVerificationResponse execute(VerifyHolderCapacityCommand command) {
        // Buscar titular
        LicenseHolder holder = licenseHolderRepository
            .findById(command.getHolderId())
            .orElseThrow(() -> new EntityNotFoundException("License holder not found"));
        
        // Executar verificação
        holder.verifyCapacity(
            command.getVerificationType(),
            command.getVerificationDetails(),
            command.getVerificationDate(),
            command.getExpiryDate(),
            command.getVerifiedBy(),
            verificationService
        );
        
        // Salvar
        LicenseHolder updated = licenseHolderRepository.save(holder);
        
        // Retornar verificação adicionada
        CapacityVerification addedVerification = updated.getCapacityVerifications().stream()
            .filter(v -> v.getVerificationType().name().equals(command.getVerificationType()))
            .max(Comparator.comparing(CapacityVerification::getCreatedAt))
            .orElseThrow();
        
        return CapacityVerificationResponse.from(addedVerification);
    }
}

@UseCase
@Transactional(readOnly = true)
public class CheckHolderEligibilityUseCase {
    
    private final LicenseHolderRepository licenseHolderRepository;
    
    public HolderEligibilityResponse execute(CheckHolderEligibilityQuery query) {
        // Buscar titular
        LicenseHolder holder = licenseHolderRepository
            .findById(query.getHolderId())
            .orElseThrow(() -> new EntityNotFoundException("License holder not found"));
        
        // Verificar elegibilidade
        boolean isEligible = holder.isEligibleForLicense(query.getLicenseType());
        
        // Coletar razões de inelegibilidade
        List<String> ineligibilityReasons = new ArrayList<>();
        
        if (holder.getStatus() != HolderStatus.ACTIVE) {
            ineligibilityReasons.add("Holder status is not active: " + holder.getStatus());
        }
        
        if (!holder.hasValidLegalCapacity()) {
            ineligibilityReasons.add("Legal capacity not verified: " + holder.getLegalCapacityStatus());
        }
        
        if (holder.getHolderType() == HolderType.COMPANY && !holder.hasActiveRepresentatives()) {
            ineligibilityReasons.add("Company does not have active legal representatives");
        }
        
        List<HolderDocument> expiredDocs = holder.getExpiredDocuments();
        if (!expiredDocs.isEmpty()) {
            ineligibilityReasons.add("Has expired documents: " + 
                expiredDocs.stream().map(HolderDocument::getDocumentType).collect(Collectors.joining(", ")));
        }
        
        return HolderEligibilityResponse.builder()
            .holderId(holder.getId().getValue())
            .licenseType(query.getLicenseType())
            .isEligible(isEligible)
            .ineligibilityReasons(ineligibilityReasons)
            .checkedAt(Instant.now())
            .build();
    }
}
```

## 4. Interface Layer (REST Controllers)

### 4.1 LicenseHolderController

```java
@RestController
@RequestMapping("/api/v1/license-holders")
@RequiredArgsConstructor
@Validated
public class LicenseHolderController {
    
    private final CreateIndividualHolderUseCase createIndividualUseCase;
    private final CreateCompanyHolderUseCase createCompanyUseCase;
    private final AddLegalRepresentativeUseCase addRepresentativeUseCase;
    private final VerifyHolderCapacityUseCase verifyCapacityUseCase;
    private final CheckHolderEligibilityUseCase checkEligibilityUseCase;
    private final LicenseHolderQueryService queryService;
    
    @GetMapping
    public ResponseEntity<PagedResponse<LicenseHolderResponse>> getAllHolders(
            @Valid @ModelAttribute HolderSearchRequest request,
            Pageable pageable) {
        
        Page<LicenseHolderResponse> holders = queryService.searchHolders(request, pageable);
        PagedResponse<LicenseHolderResponse> response = PagedResponse.from(holders);
        
        return ResponseEntity.ok(response);
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<LicenseHolderResponse> getHolderById(
            @PathVariable UUID id) {
        
        LicenseHolderResponse holder = queryService.findById(LicenseHolderId.of(id));
        return ResponseEntity.ok(holder);
    }
    
    @PostMapping("/individuals")
    public ResponseEntity<LicenseHolderResponse> createIndividualHolder(
            @Valid @RequestBody CreateIndividualHolderCommand command) {
        
        LicenseHolderResponse created = createIndividualUseCase.execute(command);
        
        return ResponseEntity.status(HttpStatus.CREATED)
            .location(URI.create("/api/v1/license-holders/" + created.getId()))
            .body(created);
    }
    
    @PostMapping("/companies")
    public ResponseEntity<LicenseHolderResponse> createCompanyHolder(
            @Valid @RequestBody CreateCompanyHolderCommand command) {
        
        LicenseHolderResponse created = createCompanyUseCase.execute(command);
        
        return ResponseEntity.status(HttpStatus.CREATED)
            .location(URI.create("/api/v1/license-holders/" + created.getId()))
            .body(created);
    }
    
    @PostMapping("/{id}/representatives")
    public ResponseEntity<LegalRepresentativeResponse> addLegalRepresentative(
            @PathVariable UUID id,
            @Valid @RequestBody AddLegalRepresentativeCommand command) {
        
        command.setHolderId(LicenseHolderId.of(id));
        LegalRepresentativeResponse representative = addRepresentativeUseCase.execute(command);
        
        return ResponseEntity.status(HttpStatus.CREATED).body(representative);
    }
    
    @PostMapping("/{id}/capacity-verifications")
    public ResponseEntity<CapacityVerificationResponse> verifyCapacity(
            @PathVariable UUID id,
            @Valid @RequestBody VerifyHolderCapacityCommand command) {
        
        command.setHolderId(LicenseHolderId.of(id));
        CapacityVerificationResponse verification = verifyCapacityUseCase.execute(command);
        
        return ResponseEntity.status(HttpStatus.CREATED).body(verification);
    }
    
    @GetMapping("/{id}/eligibility")
    public ResponseEntity
```

